---
title: LEC4
date: 2019-02-07 08:52:12
tags:
---

**今天的主题**

1.主/从复制

- 广泛使用，例如GFS的区块服务器
- 但是今天被广泛应用于强一致
- 特别重要，我们需要深入探索它

2.VM-FT案例的学习

**容错性**

1.我们需要构建一个即使失败也能继续的服务

2.高可用：在一些失败后仍然可用

3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。

4.非常困难！

5.非常有用！

**需要一个服务失败模型：我们将尝试处理什么？**

1.独立的故障，停止计算机的故障

- VM-FT假设一次只出现一个故障

2.停电（最终重启）

3.网络分区

4.没有bugs，没有恶意攻击

**核心的想法：复制**

1.两台服务器

2.每个副本保持着服务所需要的状态

3.如果一个副本失效了，其他的可以继续提供服务

**例子：MapReduce里面的matser模型**

1.lab1里面的worker是高可用的，但是没有master

- master是单点故障的

2.我们可以有两个master吗，在一个失败的情况下？

[架构图：M1, M2, workers]

状态：

- worker列表
- 那些job做完了
- 那些worker空闲
- TCP连接的状态
- 程序计数器

**大的问题**

1.要复制的状态是什么？

2.副本如何获得状态？

3.何时切换到副本服务器？

4.切换的时候是否会表现出异常状态？

5.如何修复，重新集成？

**两个主要的方法**

1.状态转换

- 主服务器执行服务
- 主服务器项备服务器发送新的状态

2.副本的状态机

- 所有的副本执行所有的操作
- 如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态

**状态转换更简单**

1.但是状态空间可能比较大，转换起来很慢

2.VM-FT使用复制状态机

**复制状态机是很高效的**

1.与数据相比，如果操作很小，但要正确执行则很复杂

例如：多核心处理器执行操作的顺序，确定性

2.实验使用了复制状态机

**什么是复制状态机？**

1.K/V对的put和get操作

2.x86指令集

3.影响性能和易于实现

- 主/备之间需要多少交互
- 高度抽象的机器可以交互更少的信息
- 在x86级别上处理不确定性很难，但在Put/Get级别上更容易实现

4.高级RSM仅适用于使用高级接口的程序

- x86 RSM可以执行任意x86程序

**一种实用的容错虚拟机系统设计**

Scales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010

**非常健壮的系统**

1.整个系统复制

2.对应用程序和客户端完全透明

3.任何现有软件的高可用性

4.如果它效果好的话会很神奇的

5.失效模型：

- 独立硬件故障
- 全站停电

6.仅限于单处理器虚拟机

问题：多核处理器有什么困难

**概述**

1.两种机器，主和备，以及其他机器

2.两种网络连接：客户端到服务器，日志交换的通道

3.用于持久化存储的共享磁盘

4.在“锁定步骤”中备份主

- 主服务器将所有的输入发送到备份
- 备份输出将被丢弃

5.主和备之间保持心跳

- 如果主失败，开始备执行

**输入是什么？**

1.时钟中断

2.网络中断

3.磁盘中断

**挑战:**

1.使整个系统看起来像一台可靠的服务器


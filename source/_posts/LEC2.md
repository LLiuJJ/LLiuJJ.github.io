---
title: LEC2
date: 2019-01-17 12:50:09
tags: 分布式系统6.824笔记
---

#### 基础设施: RPC 和 线程

**一个最常被问到的问题:为什么使用Go**

***6.824这门课原先是使用C++的***

学生花了很多时间去修与构建分布式系统无关的bug

例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象

***Go 语言可以让你更专注的处理分布式系统的问题***

1.Go语言是类型安全的

2.它有垃圾收集器（不会存在对象没有free导致的程序bug）

3.对并发编程的支持很友好

4.对RPC的支持很友好

***我们喜欢用Go编程***

1.Go很容易学习

2.Go语言推荐资料 https://golang.org/doc/effective_go.html#generality

**远程过程调用 (RPC)**

1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写

2.隐藏了客户端/服务器通信的大部分细节

3.通过RPC客户端的远程调用就像普通的过程调用

4.服务器的处理程序和普通的程序类似

5.RPC被广泛使用

**理想情况下，RPC使得网络通信看起来就像函数的调用**

客户端：

```
z = fn(x, y)
```

服务器：

```
fn(x, y) {
    compute
    return z
}
```

RPC旨在实现这种透明度的调用

Go语言RPC的库 https://golang.org/pkg/net/rpc/

**RPC 消息图**

Client				Server

request --->

​			<--- response

**软件架构**

客户端应用存根			处理调用

RPC 库					RPC库

Net   ——————————   Net

**更多的细节**

1.要调用服务器的那个处理函数

2.Marshalling（编组）：将数据格式化为数据包

​	1）处理数组、指针和对象是很棘手的

​	2）Go的RPC库是相当强大的

​	3）有一些东西你不能传送：例如，channels（通道）,functions（函数）

3.Binding（绑定）:客户端如何知道与谁交互?

​       1）客户端被提供了服务器的主机名

​       2）也许名称服务将服务映射到最佳的服务器主机

4.线程：

​	1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应

​	2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序

**RPC问题：如何处理失败**

​	例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃

**客户端RPC库中的故障是什么样的?**

1.客户端从未收到服务器的响应

2.客户端不知道服务器是否能看到请求

3.可能服务器或者网络在发送回复之前失败了

**最简单的方案：“至少一次”行为**

1.RPC库等待响应一段时间

2.如果没有响应到达，重新发送请求

3.多次尝试

4.仍然没有响应的话，向应用程序返回一个错误

5.问题：应用程序容易处理至少一次的操作吗？

​	至少一次：客户端发送“从银行账户中扣除5美元”

6.问题：这个客户端程序有什么问题？

​	put("k", 10) 通过RPC在数据库服务器中设置key的值	

​	put("k", 20) 然后客户端执行第二次put操作到同一个key

7.问题：至少一次总是OK的吗？

​	1）重复操作是可以的，例如只读操作

​	2）如果应用程序有自己对于写副本的执行计划

**更好的PRC行为：“至多一次”**

1.想法：服务器RPC代码检测重复请求

2.返回上一个reply，而不是重新运行处理程序

**如何检测重复的请求**

1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送	

```
server:
if seen[xid]:
	r = old[xid]
else
	r = handler()
	old[xid] = r
	seen[xid] = true
```

**至多一次请求的复杂之处**

1.这将在实验2和以后的实验中出现

2.如何确保XID是唯一的？

​	大的随机数？

​	合并唯一客户端ID（IP地址？）有序列？

​	服务器必须最终放弃优化旧的RPC的信息

​	1）什么时候丢弃是安全的

​	想法：

​	唯一的客户端ID

​	上一次客户端RPC请求的序列号

​	客户端的每一个RPCC包含"seen all replies <= X"

​	像TCP的sequence号一样

​	或者一次只允许一个客户端PRC

​	当seq + 1到达允许服务器放弃所有的 <= seq 的请求

​	或者客户端同意小于5分钟的重试，5分钟后服务器放弃

如何处理相同的请求当原来的请求仍然在执行？

​	服务器不知道要回复，不想重复运行

​	想法：给每个正在执行的RPC设置一个"pending" flag；等待或者忽略相同的请求

**当一个 at-most-once 服务器宕机和重启怎么办？**

1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求

2.也许它应该吧重复的信息写到磁盘？

3.也许副本服务器也应该复制重复的信息？

**"一次就好"怎么样？**

最多一次加上无限制的重试加上容错服务

**Go的RPC是 “at-most-once”**

1.打开TCP连接

2.向TCP连接中写入请求

3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求

4.Go的代码里面没有重试

5.Go RPC代码在没有得到回复的时候会返回一个error

1）可能在一个TCP超时之后

2）可能服务器没有看到请求

3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败

**Go RPC的 at-most-once 不足以应对Lab1**

1.它只适用于单个RPC调用

2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败

3.Go的RPC不能检测出这种重复

1）在lab1中没问题，它在应用层处理了

2）Lab2需要明确的检测重复提交

**线程**

1.线程是一个基本的服务结构工具

2.你将会在lab中广泛的使用它

3.它们可能很棘手

4.但是对PRC非常有用

5.Go称它们为Goroutines，也有很多人称它们为线程

**Thread = "Thread of control"**

1.多线程允许程序逻辑上在同一时刻同时做很多事情

2.线程共享内存

3.线程之间共享程序计数器，寄存器，栈空间

**多线程的一些挑战**

1.共享数据

1）两个线程如果同时修改了相同的变量会怎么样？

2）一个线程正在读数据，另一个线程改变数据呢？

3）需要保护共享数据上的不变量

4）使用Go sync.Mutex锁

2.线程之间的通过

例如：等待所有的Map线程完成

使用Go channels

3.死锁

1）线程1等待线程2

2）线程2等待线程1

4.锁粒度

1）粗粒度->实现简单，但是并发性能不好

2）细粒度->更好的并发性能，更多的锁竞争(races)和死锁

5.让我们来看labrpc 包里如何解决这些问题

1）它类似于Go的RPC系统，但是网络是一个模拟网络

- 网络延迟请求和响应
- 网络丢包请求和响应
- 网络的重发请求和响应

2）说明 threads，mutexes，channels的用法

3）使用Go实现了一个完整的RPC包

**网络的结构**

1.网络的描述

1）服务器

2）客户端

2.每个网络都是互斥的

**RPC概述**

1.在test_test.go文件里面有很多例子

2.应用调用RPC

```
reply := end.Call("Raft.AppendEntries", args, &reply) //发出一个RPC请求，等待回复
```

3.服务端

```
srv := MakeServer()
srv.AddService(svc) -- 一个服务器可以有多种服务
```

4.k/v

将srv传递给 net.AddServer()

```
svc := MakeService(recevierPbject) -- obj's 方法会处理RPC请求
```

非常像Go的rpcs.Register()

传递svc给 srv.AddService()

5.服务器的数据结构

1）AddService()

添加一个服务名

问题：为什么使用锁？

问题：什么事defer()？

2）Dispatch()

分发一个请求到正确的服务

问题：为什么持有锁？

问题：为什么持有锁的范围互道函数的末尾？

3）Call()

使用反射查找参数的类型

使用gob编码参数

e.ch 是网络发送请求的通道

使用一个通道来接收网络的回复（<- req.replyCh）

4）MakeEnd()

有一个模拟网络的线程/goroutine

从e.ch中读取并处理请求

每个请求都在一个单独的goroutine中处理

Q：一个endpoint 可以有很多未完成的请求吗

Q：为什么使用rn.mu.Lock()？

Q：锁保护了什么？

5）ProcessReq()

查找一个服务endpoint

如果网络不可靠，可能会延迟或者丢失请求

分发请求到一个新的线程

通过读取ech中的数据等待服务端回复直到100ms过去

100ms只是用来验证服务器是不是宕机了

然后回复

Q：谁将会读取回复？

Q：如果ProcessReq不持有rn的锁可以吗？

6）Service.dispatch()

给请求找到一个处理的方法

解码参数

调用函数

编码回复

返回回复信息

Go的内存模型需要显示同步才能进行通信

下面代码是不正确的

```
var x int
done := false
go func() { x = f(...); done = true }
while done == false { }
```

这是一个非常诱人的写法，但是Go会说这是为定义的

使用通道或者sync.WaitGroup代替

**学习Go的goroutines和channels**

https://golang.org/doc/articles/race_detector.html
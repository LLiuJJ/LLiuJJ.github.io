{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"3dfdb13f5c87fbc05e139def419d9c6cf3134d59","modified":1546841984251},{"_id":"source/favicon.ico","hash":"da48f1f7091f64d77ff8f79694381fb880f753d4","modified":1546927738866},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1546873650406},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1546873650407},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1546873650407},{"_id":"themes/maupassant/README.md","hash":"a3dcfa9b646980ee5811ec03b4c5786618b85ff9","modified":1546873650407},{"_id":"themes/maupassant/_config.yml","hash":"e25e4fe13d4437cb260f1ee6e5111bc910eb7b05","modified":1551687554952},{"_id":"themes/maupassant/package.json","hash":"33ed7d93880cdf98bd84b366aef22f089202527f","modified":1546875101656},{"_id":"source/LINUX/index.md","hash":"f2fff3675b5b022bf6816950eb947276d5331b88","modified":1551687737803},{"_id":"source/_posts/2018总结.md","hash":"0c7c3ad5febbdabcfd84d8a6fbc65ca7dce83a0a","modified":1547554715226},{"_id":"source/MIT-6-824/index.md","hash":"773b2c248a27a84a7ac053fdc89c2f9bd8bc2e6e","modified":1551338451469},{"_id":"source/_posts/LEC1-vedio.md","hash":"5b988aefc99504ae1bf2853e46dcc60eeb0bb819","modified":1547700798179},{"_id":"source/_posts/LEC1.md","hash":"8c282e5022d93f47bee1b49c62611c8134d0573b","modified":1547700036131},{"_id":"source/_posts/LEC10-vedio.md","hash":"5e940c9365c11cbcbd91919b5a54e95788b55ff6","modified":1547700619729},{"_id":"source/_posts/LEC13-vedio.md","hash":"a60aeeba5ee4926cb2a0cbe7a1194946a583bdd4","modified":1547700619728},{"_id":"source/_posts/LEC12-vedio.md","hash":"b32068cd5bf06fd74b70d5426912be2801a82840","modified":1547700619729},{"_id":"source/_posts/LEC15-vedio.md","hash":"9707bfaa85b1942eb4b252c733f7c55a69583176","modified":1547700619738},{"_id":"source/_posts/LEC16-vedio.md","hash":"de95a6d1dbd15815282f5acbda63bbf18d0dab98","modified":1547700619738},{"_id":"source/_posts/LEC17-vedio.md","hash":"e25d097a9245e12dce038b46dc42097a69ab23a5","modified":1547700901617},{"_id":"source/_posts/LEC2-vedio.md","hash":"b8aec07f91e03a3750290f75fe59383f46727c04","modified":1547700801730},{"_id":"source/_posts/LEC20-vedio.md","hash":"9ce857803f18068fcb42b9d026c3e6ffe74071eb","modified":1547700203603},{"_id":"source/_posts/LEC2.md","hash":"576e1fac0e2a6dbad9b30f293c369e92142727a7","modified":1548343950148},{"_id":"source/_posts/LEC3-vedio.md","hash":"666a51921fce83637e1131ef6e3a12f6e7618e21","modified":1547700619728},{"_id":"source/_posts/LEC4-vedio.md","hash":"08b8550af4981b0a07a97d1918964c4f91fde50c","modified":1547700619729},{"_id":"source/_posts/LEC3.md","hash":"8bd66310ee72d819aec75c88d48c8d58a10381d1","modified":1548652683684},{"_id":"source/_posts/LEC5-vedio.md","hash":"f2de840e5bb5d921f4a2b8465720b55483e410cf","modified":1547700619729},{"_id":"source/_posts/LEC4.md","hash":"227f840a373c9269aa81cc1c635b242d107a60e8","modified":1551337756321},{"_id":"source/_posts/LEC6-vedio.md","hash":"bc2cc920fedf6f2ecd121ff82855c3644afe1d8e","modified":1547700619730},{"_id":"source/_posts/LEC7-vedio.md","hash":"99cdac660d77588c2b5fa3e1bd37dbb1a8177faa","modified":1547700619729},{"_id":"source/_posts/LEC8-vedio.md","hash":"45d9e4ef1e510ffaad3c57ab69c2021862cbda68","modified":1547700619729},{"_id":"source/_posts/LEC9-vedio.md","hash":"7dc5ce2ddd6a6a106996bb156a0b8e17b17affac","modified":1547700619730},{"_id":"source/about/index.md","hash":"4eaf089e0626c3657ace852cb535dcac4527bb37","modified":1547532871641},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1546873650384},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1546873650390},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1546873600651},{"_id":"themes/maupassant/.git/index","hash":"ea4dd78bcda3744c083c6fff7b59f64808cf01ef","modified":1546878941216},{"_id":"themes/maupassant/.git/packed-refs","hash":"3d1060ac070341c07c117aace6e93ee59887ec2b","modified":1546873650376},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1546873650411},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1546873650411},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1546873650412},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1546873650412},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1546873650412},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1546873650412},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1546873650413},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1546873650413},{"_id":"themes/maupassant/layout/archive.pug","hash":"665582bb4092fcd81bfaf4d08fc1689abee1e6c4","modified":1546873650425},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1546873650425},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1546873650426},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1546873650426},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1546873650427},{"_id":"themes/maupassant/layout/post.pug","hash":"bfe10ecfb515d241bb9a07e7d08be5779f2ef119","modified":1546873650427},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1546873650427},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1546873650427},{"_id":"source/_posts/2018总结/2018.jpeg","hash":"4b5535ac167a1817a0ead3a0e9b84804f8ed3552","modified":1546877871543},{"_id":"source/_posts/LEC1/MapReduce.png","hash":"4a0fbb1ac7fe41d83b669f5b465d104a5ad253d6","modified":1547615007681},{"_id":"source/_posts/LEC1/MapReduceApi.png","hash":"94de3afa77383512abd1791e90dfed0ef7dce162","modified":1547615637530},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1546873600652},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1546873600655},{"_id":"themes/maupassant/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1546873600656},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1546873600658},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1546873600659},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1546873600655},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1546873600659},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1546873600653},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1546873600657},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1546873600658},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1546873600648},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1546873600661},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"5cd7abcc6dfa2d7a81f6eecea61b9ca55e22bc4d","modified":1546873650388},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"06969aefa52218aa2320b7d735f751df4a7b5e1d","modified":1546873650414},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"ff14baa25f6db34dedfb5e029c25687a335ad430","modified":1546873650417},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1546873650418},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"025c34e4e89d99b866fd5af2924e60e9f63e386b","modified":1546873650419},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1546873650419},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"0ca48cbf73f5a5bbf5e2f615ce6c6366fe5662e7","modified":1546873650420},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1546873650420},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1546873650421},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"10fb2af46002c57b6a38e2c530eaa8c3e0a77c67","modified":1546873650420},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1546873650421},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1546873650421},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1546873650422},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1546873650422},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1546873650423},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1546873650424},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1546873650424},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1546873650424},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1546873650425},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1546873650428},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1546873650428},{"_id":"themes/maupassant/source/donate/index.html","hash":"04fb043ed312f6eaf8435440739febac2d465de0","modified":1546873650429},{"_id":"themes/maupassant/source/css/style.scss","hash":"b44da192f0875e144bf7990a99b42e31e986e099","modified":1546873650429},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1546873650430},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1546873650430},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1546873650431},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1546873650431},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1546873650432},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1546873650435},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1546873650432},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1546873650433},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1546873650436},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1546873650435},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1546873650435},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1546873650436},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1546873650438},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1546873650438},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1546873650437},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1546873650439},{"_id":"themes/maupassant/.git/objects/pack/pack-c9f899d4b09b3e87558ae12626842798eb209708.idx","hash":"5823786eecf1806bb11faf62fa89fbbb363b31f4","modified":1546873650349},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"8d6c2028163017f65bb54fb912c65c6455ce7583","modified":1546873650388},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1546873650437},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"5cd7abcc6dfa2d7a81f6eecea61b9ca55e22bc4d","modified":1546873650388},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1546873650383},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"5cd7abcc6dfa2d7a81f6eecea61b9ca55e22bc4d","modified":1546873650383},{"_id":"themes/maupassant/db.json","hash":"a6ebfe09d5ed47bb797c9816b0d79d78d00a0cb8","modified":1546875136590},{"_id":"themes/maupassant/.git/objects/pack/pack-c9f899d4b09b3e87558ae12626842798eb209708.pack","hash":"1de01345e0b6f0e93c2a9f5c6b78b261ef76d051","modified":1546873650345}],"Category":[],"Data":[],"Page":[{"title":"LINUX","date":"2019-03-04T08:17:30.000Z","_content":"\nLINUX 官网 https://www.kernel.org/\n\nLINUX 源码阅读网站 https://elixir.bootlin.com/linux/v4.20.13/source\n\n\n","source":"LINUX/index.md","raw":"---\ntitle: LINUX\ndate: 2019-03-04 16:17:30\n---\n\nLINUX 官网 https://www.kernel.org/\n\nLINUX 源码阅读网站 https://elixir.bootlin.com/linux/v4.20.13/source\n\n\n","updated":"2019-03-04T08:22:17.803Z","path":"LINUX/index.html","_id":"cjsu2niig00002yw3fc5f8je8","comments":1,"layout":"page","content":"<p>LINUX 官网 <a href=\"https://www.kernel.org/\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/</a></p>\n<p>LINUX 源码阅读网站 <a href=\"https://elixir.bootlin.com/linux/v4.20.13/source\" target=\"_blank\" rel=\"noopener\">https://elixir.bootlin.com/linux/v4.20.13/source</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>LINUX 官网 <a href=\"https://www.kernel.org/\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/</a></p>\n<p>LINUX 源码阅读网站 <a href=\"https://elixir.bootlin.com/linux/v4.20.13/source\" target=\"_blank\" rel=\"noopener\">https://elixir.bootlin.com/linux/v4.20.13/source</a></p>\n"},{"title":"MIT-6.824","date":"2019-01-15T12:12:41.000Z","_content":"\n#### 翻译MIT Distributed-Systems 系列课程的资料\n| 课程视频                                                     | 课程笔记                                         | Paper阅读笔记                                   | Lab            |\n| ------------------------------------------------------------ | ------------------------------------------------ | ----------------------------------------------- | -------------- |\n| 1.[课程介绍](https://turingturing.cn/2019/01/16/LEC1-vedio/) | [LEC1](https://turingturing.cn/2019/01/15/LEC1/) | MapReduce                                       | MapReduceLab   |\n| 2.[RPC和多线程编程](https://turingturing.cn/2019/01/17/LEC2-vedio/) | [LEC2](https://turingturing.cn/2019/01/17/LEC2/) |                                                 | RpcLab         |\n| 3.GFS                                                        | [LEC3](https://turingturing.cn/2019/01/24/LEC3/) | GFS                                             |                |\n| 4.(Primary/Backup Replication)主/备 复制                     |                                                  | Fault Tolerance Virtual Machines - 容错的虚拟机 |                |\n| 5.Raft1                                                      |                                                  | Raft-extended                                   | RaftLab        |\n| 6.Raft2                                                      |                                                  | Raft-extended                                   | KVRaft Lab     |\n| 7.Go语言讲解-Guest lecturer                                  |                                                  | Go的内存模型                                    |                |\n| 8.Zookeeper                                                  |                                                  | ZooKeeper                                       |                |\n| 9.Distributed Transactions (分布式事务)                      |                                                  |                                                 |                |\n| 10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口) |                                                  |                                                 |                |\n| 11.FaRM                                                      |                                                  |                                                 |                |\n| 12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性) |                                                  | ThreadMarks                                     | Sharded KV Lab |\n| 13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性) |                                                  | Bayou                                           |                |\n| 14.Case Studies: Relaxed Consistency (案例研究：弱一致性)    |                                                  | PNUTS                                           |                |\n| 15.Case Studies:Dynamo (案例研究：Dynamo)                    |                                                  | Dynamo                                          |                |\n| 16.Wide-Area Publish/Subscribe (广域的发布和订阅)            |                                                  | Wormhole                                        |                |\n| 17.Measuring Consisitency (衡量一致性)                       |                                                  | Existential Consistency                         |                |\n| 18.Case Studies: Spark (案例学习：Spark)                     |                                                  | Spark                                           |                |\n| 19.Cluster Management (集群管理)                             |                                                  | Borg                                            |                |\n| 20.Peer-to-peer: Trackerless Bittrrent and DHTs              |                                                  | Trackerless Bittrrent                           |                |\n| 21.Peer-to-peer: Bitcoin （点对点 比特币）                   |                                                  | Bitcoin summary                                 |                |\n| 22: Guest lecturer: Frank Dabek of Google                    |                                                  | The Tail at Scale                               |                |\n| 23: Project Demos                                            |                                                  | Analogicfs                                      |                |\n\n**一些有用的链接**\n\n- 动画理解Raft http://thesecretlivesofdata.com/raft/\n\n","source":"MIT-6-824/index.md","raw":"---\ntitle: MIT-6.824\ndate: 2019-01-15 20:12:41\n---\n\n#### 翻译MIT Distributed-Systems 系列课程的资料\n| 课程视频                                                     | 课程笔记                                         | Paper阅读笔记                                   | Lab            |\n| ------------------------------------------------------------ | ------------------------------------------------ | ----------------------------------------------- | -------------- |\n| 1.[课程介绍](https://turingturing.cn/2019/01/16/LEC1-vedio/) | [LEC1](https://turingturing.cn/2019/01/15/LEC1/) | MapReduce                                       | MapReduceLab   |\n| 2.[RPC和多线程编程](https://turingturing.cn/2019/01/17/LEC2-vedio/) | [LEC2](https://turingturing.cn/2019/01/17/LEC2/) |                                                 | RpcLab         |\n| 3.GFS                                                        | [LEC3](https://turingturing.cn/2019/01/24/LEC3/) | GFS                                             |                |\n| 4.(Primary/Backup Replication)主/备 复制                     |                                                  | Fault Tolerance Virtual Machines - 容错的虚拟机 |                |\n| 5.Raft1                                                      |                                                  | Raft-extended                                   | RaftLab        |\n| 6.Raft2                                                      |                                                  | Raft-extended                                   | KVRaft Lab     |\n| 7.Go语言讲解-Guest lecturer                                  |                                                  | Go的内存模型                                    |                |\n| 8.Zookeeper                                                  |                                                  | ZooKeeper                                       |                |\n| 9.Distributed Transactions (分布式事务)                      |                                                  |                                                 |                |\n| 10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口) |                                                  |                                                 |                |\n| 11.FaRM                                                      |                                                  |                                                 |                |\n| 12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性) |                                                  | ThreadMarks                                     | Sharded KV Lab |\n| 13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性) |                                                  | Bayou                                           |                |\n| 14.Case Studies: Relaxed Consistency (案例研究：弱一致性)    |                                                  | PNUTS                                           |                |\n| 15.Case Studies:Dynamo (案例研究：Dynamo)                    |                                                  | Dynamo                                          |                |\n| 16.Wide-Area Publish/Subscribe (广域的发布和订阅)            |                                                  | Wormhole                                        |                |\n| 17.Measuring Consisitency (衡量一致性)                       |                                                  | Existential Consistency                         |                |\n| 18.Case Studies: Spark (案例学习：Spark)                     |                                                  | Spark                                           |                |\n| 19.Cluster Management (集群管理)                             |                                                  | Borg                                            |                |\n| 20.Peer-to-peer: Trackerless Bittrrent and DHTs              |                                                  | Trackerless Bittrrent                           |                |\n| 21.Peer-to-peer: Bitcoin （点对点 比特币）                   |                                                  | Bitcoin summary                                 |                |\n| 22: Guest lecturer: Frank Dabek of Google                    |                                                  | The Tail at Scale                               |                |\n| 23: Project Demos                                            |                                                  | Analogicfs                                      |                |\n\n**一些有用的链接**\n\n- 动画理解Raft http://thesecretlivesofdata.com/raft/\n\n","updated":"2019-02-28T07:20:51.469Z","path":"MIT-6-824/index.html","comments":1,"layout":"page","_id":"cjsu2niin00022yw3cwn7z71r","content":"<h4 id=\"翻译MIT-Distributed-Systems-系列课程的资料\"><a href=\"#翻译MIT-Distributed-Systems-系列课程的资料\" class=\"headerlink\" title=\"翻译MIT Distributed-Systems 系列课程的资料\"></a>翻译MIT Distributed-Systems 系列课程的资料</h4><table>\n<thead>\n<tr>\n<th>课程视频</th>\n<th>课程笔记</th>\n<th>Paper阅读笔记</th>\n<th>Lab</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.<a href=\"https://turingturing.cn/2019/01/16/LEC1-vedio/\">课程介绍</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/15/LEC1/\">LEC1</a></td>\n<td>MapReduce</td>\n<td>MapReduceLab</td>\n</tr>\n<tr>\n<td>2.<a href=\"https://turingturing.cn/2019/01/17/LEC2-vedio/\">RPC和多线程编程</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/17/LEC2/\">LEC2</a></td>\n<td></td>\n<td>RpcLab</td>\n</tr>\n<tr>\n<td>3.GFS</td>\n<td><a href=\"https://turingturing.cn/2019/01/24/LEC3/\">LEC3</a></td>\n<td>GFS</td>\n<td></td>\n</tr>\n<tr>\n<td>4.(Primary/Backup Replication)主/备 复制</td>\n<td></td>\n<td>Fault Tolerance Virtual Machines - 容错的虚拟机</td>\n<td></td>\n</tr>\n<tr>\n<td>5.Raft1</td>\n<td></td>\n<td>Raft-extended</td>\n<td>RaftLab</td>\n</tr>\n<tr>\n<td>6.Raft2</td>\n<td></td>\n<td>Raft-extended</td>\n<td>KVRaft Lab</td>\n</tr>\n<tr>\n<td>7.Go语言讲解-Guest lecturer</td>\n<td></td>\n<td>Go的内存模型</td>\n<td></td>\n</tr>\n<tr>\n<td>8.Zookeeper</td>\n<td></td>\n<td>ZooKeeper</td>\n<td></td>\n</tr>\n<tr>\n<td>9.Distributed Transactions (分布式事务)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11.FaRM</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性)</td>\n<td></td>\n<td>ThreadMarks</td>\n<td>Sharded KV Lab</td>\n</tr>\n<tr>\n<td>13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性)</td>\n<td></td>\n<td>Bayou</td>\n<td></td>\n</tr>\n<tr>\n<td>14.Case Studies: Relaxed Consistency (案例研究：弱一致性)</td>\n<td></td>\n<td>PNUTS</td>\n<td></td>\n</tr>\n<tr>\n<td>15.Case Studies:Dynamo (案例研究：Dynamo)</td>\n<td></td>\n<td>Dynamo</td>\n<td></td>\n</tr>\n<tr>\n<td>16.Wide-Area Publish/Subscribe (广域的发布和订阅)</td>\n<td></td>\n<td>Wormhole</td>\n<td></td>\n</tr>\n<tr>\n<td>17.Measuring Consisitency (衡量一致性)</td>\n<td></td>\n<td>Existential Consistency</td>\n<td></td>\n</tr>\n<tr>\n<td>18.Case Studies: Spark (案例学习：Spark)</td>\n<td></td>\n<td>Spark</td>\n<td></td>\n</tr>\n<tr>\n<td>19.Cluster Management (集群管理)</td>\n<td></td>\n<td>Borg</td>\n<td></td>\n</tr>\n<tr>\n<td>20.Peer-to-peer: Trackerless Bittrrent and DHTs</td>\n<td></td>\n<td>Trackerless Bittrrent</td>\n<td></td>\n</tr>\n<tr>\n<td>21.Peer-to-peer: Bitcoin （点对点 比特币）</td>\n<td></td>\n<td>Bitcoin summary</td>\n<td></td>\n</tr>\n<tr>\n<td>22: Guest lecturer: Frank Dabek of Google</td>\n<td></td>\n<td>The Tail at Scale</td>\n<td></td>\n</tr>\n<tr>\n<td>23: Project Demos</td>\n<td></td>\n<td>Analogicfs</td>\n</tr>\n</tbody>\n</table>\n<p><strong>一些有用的链接</strong></p>\n<ul>\n<li>动画理解Raft <a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"noopener\">http://thesecretlivesofdata.com/raft/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"翻译MIT-Distributed-Systems-系列课程的资料\"><a href=\"#翻译MIT-Distributed-Systems-系列课程的资料\" class=\"headerlink\" title=\"翻译MIT Distributed-Systems 系列课程的资料\"></a>翻译MIT Distributed-Systems 系列课程的资料</h4><table>\n<thead>\n<tr>\n<th>课程视频</th>\n<th>课程笔记</th>\n<th>Paper阅读笔记</th>\n<th>Lab</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.<a href=\"https://turingturing.cn/2019/01/16/LEC1-vedio/\">课程介绍</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/15/LEC1/\">LEC1</a></td>\n<td>MapReduce</td>\n<td>MapReduceLab</td>\n</tr>\n<tr>\n<td>2.<a href=\"https://turingturing.cn/2019/01/17/LEC2-vedio/\">RPC和多线程编程</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/17/LEC2/\">LEC2</a></td>\n<td></td>\n<td>RpcLab</td>\n</tr>\n<tr>\n<td>3.GFS</td>\n<td><a href=\"https://turingturing.cn/2019/01/24/LEC3/\">LEC3</a></td>\n<td>GFS</td>\n<td></td>\n</tr>\n<tr>\n<td>4.(Primary/Backup Replication)主/备 复制</td>\n<td></td>\n<td>Fault Tolerance Virtual Machines - 容错的虚拟机</td>\n<td></td>\n</tr>\n<tr>\n<td>5.Raft1</td>\n<td></td>\n<td>Raft-extended</td>\n<td>RaftLab</td>\n</tr>\n<tr>\n<td>6.Raft2</td>\n<td></td>\n<td>Raft-extended</td>\n<td>KVRaft Lab</td>\n</tr>\n<tr>\n<td>7.Go语言讲解-Guest lecturer</td>\n<td></td>\n<td>Go的内存模型</td>\n<td></td>\n</tr>\n<tr>\n<td>8.Zookeeper</td>\n<td></td>\n<td>ZooKeeper</td>\n<td></td>\n</tr>\n<tr>\n<td>9.Distributed Transactions (分布式事务)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11.FaRM</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性)</td>\n<td></td>\n<td>ThreadMarks</td>\n<td>Sharded KV Lab</td>\n</tr>\n<tr>\n<td>13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性)</td>\n<td></td>\n<td>Bayou</td>\n<td></td>\n</tr>\n<tr>\n<td>14.Case Studies: Relaxed Consistency (案例研究：弱一致性)</td>\n<td></td>\n<td>PNUTS</td>\n<td></td>\n</tr>\n<tr>\n<td>15.Case Studies:Dynamo (案例研究：Dynamo)</td>\n<td></td>\n<td>Dynamo</td>\n<td></td>\n</tr>\n<tr>\n<td>16.Wide-Area Publish/Subscribe (广域的发布和订阅)</td>\n<td></td>\n<td>Wormhole</td>\n<td></td>\n</tr>\n<tr>\n<td>17.Measuring Consisitency (衡量一致性)</td>\n<td></td>\n<td>Existential Consistency</td>\n<td></td>\n</tr>\n<tr>\n<td>18.Case Studies: Spark (案例学习：Spark)</td>\n<td></td>\n<td>Spark</td>\n<td></td>\n</tr>\n<tr>\n<td>19.Cluster Management (集群管理)</td>\n<td></td>\n<td>Borg</td>\n<td></td>\n</tr>\n<tr>\n<td>20.Peer-to-peer: Trackerless Bittrrent and DHTs</td>\n<td></td>\n<td>Trackerless Bittrrent</td>\n<td></td>\n</tr>\n<tr>\n<td>21.Peer-to-peer: Bitcoin （点对点 比特币）</td>\n<td></td>\n<td>Bitcoin summary</td>\n<td></td>\n</tr>\n<tr>\n<td>22: Guest lecturer: Frank Dabek of Google</td>\n<td></td>\n<td>The Tail at Scale</td>\n<td></td>\n</tr>\n<tr>\n<td>23: Project Demos</td>\n<td></td>\n<td>Analogicfs</td>\n</tr>\n</tbody>\n</table>\n<p><strong>一些有用的链接</strong></p>\n<ul>\n<li>动画理解Raft <a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"noopener\">http://thesecretlivesofdata.com/raft/</a></li>\n</ul>\n"},{"title":"关于我","date":"2019-01-07T15:37:55.000Z","_content":"\n一个喜欢看各种书籍的书呆子！\n\n一个追求极致计算能力的疯子！\n\n一个追寻自由自在生活的浪子！\n\nemail: jay_jieliu@outlook.com\n\n知乎: [JAYL](https://www.zhihu.com/people/liu-jie-84-52/activities)\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2019-01-07 23:37:55\n---\n\n一个喜欢看各种书籍的书呆子！\n\n一个追求极致计算能力的疯子！\n\n一个追寻自由自在生活的浪子！\n\nemail: jay_jieliu@outlook.com\n\n知乎: [JAYL](https://www.zhihu.com/people/liu-jie-84-52/activities)\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n","updated":"2019-01-15T06:14:31.641Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjsu2niiq00042yw35jql0udj","content":"<p>一个喜欢看各种书籍的书呆子！</p>\n<p>一个追求极致计算能力的疯子！</p>\n<p>一个追寻自由自在生活的浪子！</p>\n<p>email: <a href=\"mailto:jay_jieliu@outlook.com\" target=\"_blank\" rel=\"noopener\">jay_jieliu@outlook.com</a></p>\n<p>知乎: <a href=\"https://www.zhihu.com/people/liu-jie-84-52/activities\" target=\"_blank\" rel=\"noopener\">JAYL</a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<p>一个喜欢看各种书籍的书呆子！</p>\n<p>一个追求极致计算能力的疯子！</p>\n<p>一个追寻自由自在生活的浪子！</p>\n<p>email: <a href=\"mailto:jay_jieliu@outlook.com\" target=\"_blank\" rel=\"noopener\">jay_jieliu@outlook.com</a></p>\n<p>知乎: <a href=\"https://www.zhihu.com/people/liu-jie-84-52/activities\" target=\"_blank\" rel=\"noopener\">JAYL</a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n"}],"Post":[{"title":"2018总结","date":"2019-01-07T16:11:48.000Z","_content":"\n  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。\n  \n  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。\n  \n  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！\n  \n  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。\n  \n  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。\n  \n 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。\n \n 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。\n \n 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。\n \n<div style=\"width: 360px; margin: auto\">![2018](2018总结/2018.jpeg)</div>\n\n\n","source":"_posts/2018总结.md","raw":"---\ntitle: 2018总结\ndate: 2019-01-08 00:11:48\ntags:\n---\n\n  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。\n  \n  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。\n  \n  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！\n  \n  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。\n  \n  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。\n  \n 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。\n \n 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。\n \n 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。\n \n<div style=\"width: 360px; margin: auto\">![2018](2018总结/2018.jpeg)</div>\n\n\n","slug":"2018总结","published":1,"updated":"2019-01-15T12:18:35.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2niii00012yw3hugf8jtz","content":"<p>  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。</p>\n<p>  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。</p>\n<p>  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！</p>\n<p>  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。</p>\n<p>  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。</p>\n<p> 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。</p>\n<p> 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。</p>\n<p> 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。</p>\n<div style=\"width: 360px; margin: auto\"><img src=\"/2019/01/08/2018总结/2018.jpeg\" alt=\"2018\"></div>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。</p>\n<p>  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。</p>\n<p>  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！</p>\n<p>  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。</p>\n<p>  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。</p>\n<p> 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。</p>\n<p> 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。</p>\n<p> 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。</p>\n<div style=\"width: 360px; margin: auto\"><img src=\"/2019/01/08/2018总结/2018.jpeg\" alt=\"2018\"></div>\n\n\n"},{"title":"LEC1-vedio","date":"2019-01-16T14:03:56.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC1-vedio.md","raw":"---\ntitle: LEC1-vedio\ndate: 2019-01-16 22:03:56\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC1-vedio","published":1,"updated":"2019-01-17T04:53:18.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2niio00032yw3z5slbvc7","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC1","date":"2019-01-15T15:03:03.000Z","_content":"\n**不敢确认的翻译给出了原文，避免误解**\n\n**什么是分布式系统**？\n\n1.多台主机合作\n\n2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的\n\n**为什么需要分布式**？\n\n1.连接物理上分离的实体\n\n2.通过隔离实现安全\n\n3.通过副本来实现容错\n\n4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量\n\n5.但是：\n\n1) 分布式系统具有复杂性，包括很多并发的部分\n\n2) 必须应对系统中部分部分失败\n\n3) 很难实现性能潜力\n\n**实验的目标**：\n\n1.更加深入的了解一些重要技术\n\n2.积累分布式系统的编程经验\n\n**主话题**\n\n1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用\n\n2.用来应用程序分布的复杂性\n\n1）三大抽象\n\n存储，交互，计算\n\n2）实现分布式系统的一些基础知识\n\nRPC，线程，并发控制\n\n3）分布式系统的性能\n\n**理想：可扩展的吞吐量**\n\n可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现\n\n所以可以通过购买更多的服务器来处理更多的负载\n\n**现实：扩展变得越来越困难**\n\n负载均衡，(stragglers)性能落后的机器\n\n很小的，不可以并行化的部分\n\n隐藏共享资源，比如网络\n\n分布式系统的容错性(fault tolerance)\n\n1000个服务器，复杂的网络连接，总是会出现一些问题\n我们想通过应用程序来隐藏(容忍)这些失败\n\n可用性：尽管失败，我仍然可以继续使用我的文件\n\n耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复\n\n一个好主意：使用副本服务器(replicated servers)\n\n如果一个服务宕机了，客户端可以选择使用其他的服务器\n\n**分布式系统的一致性**\n\n通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的\n\n1.客户端提交并行的操作\n2.服务器在尴尬的时候崩溃\n3.网络问题可能是服务器看起来像是死机了\n4.脑裂的风险(split brain)\n\n**一致性和性能是相对的**\n\n1.一致性需要交互\n2.具有令人满意(\"严格\")语以的系统通常很慢\n3.快速的系统通常可以使应用程序面对复杂的行为\n\n案例学习: MapReduce\n\n**MapReduce概述**\n\n1.Context: 对多个TB的数据集进行多个小时的计算\n\n例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的\n\n2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理\n\n3.程序员定义Map和Reduce函数的顺序代码，通常很简单\n\n4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节\n\n**MapReduce的抽象视图**\n\n输入(input)被分为M个文件\n\n[maps 生成多行 K-V对，reduces合并列]\n\n![MapReduce](LEC1/MapReduce.png)\n\nMR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。\n\nMR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 <k2, v3> 对，结果存储在R输出文件中\n\n[MapReduce API]\n\n![MapReduceApi](LEC1/MapReduceApi.png)\n\n**MapReduce隐藏了一些细节痛点**\n\n1.在服务器上启动 s/w\n\n2.跟踪哪些任务已经完成了\n\n3.数据移动\n\n4.任务失败后恢复\n\n**Mapreduce 具有很好的扩展性**\n\n1.用N台服务器可以获得Nx的吞吐量\n\n假设 M和R >= N （即：很多的输入文件和map输出的key）\n\nMaps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的\n\n唯一的交互是maps和reduces之间的 \"shuffle\"\n\n2.因此，你可以通过购买更多的服务器来获得更多的吞吐量\n\n而不是对每个应用程序做特殊，高效的并行化\n\n**限制性能的因素是什么？**\n\n1.我们关心这个因为这正是系统性能的优化点\nCPU? 内存? 磁盘? 网络？\n\n2.网络带宽的限制\n\n网络的内部总容量，通常远小于主机之间网络链路的速度总和\n\n难以建立一个比单台计算机运行速度快1000倍的网络\n\n所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动\n\n**容灾处理**\n\n如果有服务器在MR job过程中宕机怎么处理\n\n隐藏失败是实现模型简易编程一个大的部分\n\n为什么不从一开始就重启整个job\n\nMR过程只会重新运行失败的Map()和Reduce()\n\n它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果\n\nMR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要\n\n**更多的细节**\n\n1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片\n\n输入数据存在GFS中，每个分片存了3个副本\n\n2.所有的计算机同时运行GFS和MR workers\n\n3.输入分片数比workers数要多\n\n4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务\n\n5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘\n\n直到所有Maps操作结束后才会进行Reduce计算\n\n6.Master告诉Reducers从Map操作的workers那里获取中间数据分块\n\n7.Reduce操作的workers将最终输出结果写到GFS中\n\n**如何通过细节处的设计来提高网络性能**\n\n1.Map的输入从本地磁盘读取，不是通过网络\n\n2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS\n\n3.生成的中间数据分块保存很多的key，并存储在文件中\n\n4.大块的网络传输效率更高\n\n**如果更均衡的分配负载**\n\n1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益\n\n2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件\n\n3.解决方案：split的数多于workes数\n\nMaster将新的splits分发给已经完成先前任务的workers\n\n所以更快的服务器比慢速的服务器做更多的工作，并同时完成。\n\n**MR如何应对worker崩溃呢**\n\n1.Map worker 崩溃\n\nmaster重新运行，通过其他GFS的副本作为输入\n\n即使worker已经完成，因为我们仍需要磁盘上的中间数据\n\n一些Reduce workers可能已经督过workers的中间数据\n\n2.Master怎么知道worker崩溃了(通过 pings)\n\n如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行\n\n3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker\n\n4.Reduce worker在写输出的过程中崩溃\n\nGFS具有 atomic rename ,可以防止输出在完成之前可见\n\n5.所以master在其他的地方重新运行Reduce 任务是安全的\n\n","source":"_posts/LEC1.md","raw":"---\ntitle: LEC1\ndate: 2019-01-15 23:03:03\ntags: 分布式系统6.824笔记\n---\n\n**不敢确认的翻译给出了原文，避免误解**\n\n**什么是分布式系统**？\n\n1.多台主机合作\n\n2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的\n\n**为什么需要分布式**？\n\n1.连接物理上分离的实体\n\n2.通过隔离实现安全\n\n3.通过副本来实现容错\n\n4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量\n\n5.但是：\n\n1) 分布式系统具有复杂性，包括很多并发的部分\n\n2) 必须应对系统中部分部分失败\n\n3) 很难实现性能潜力\n\n**实验的目标**：\n\n1.更加深入的了解一些重要技术\n\n2.积累分布式系统的编程经验\n\n**主话题**\n\n1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用\n\n2.用来应用程序分布的复杂性\n\n1）三大抽象\n\n存储，交互，计算\n\n2）实现分布式系统的一些基础知识\n\nRPC，线程，并发控制\n\n3）分布式系统的性能\n\n**理想：可扩展的吞吐量**\n\n可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现\n\n所以可以通过购买更多的服务器来处理更多的负载\n\n**现实：扩展变得越来越困难**\n\n负载均衡，(stragglers)性能落后的机器\n\n很小的，不可以并行化的部分\n\n隐藏共享资源，比如网络\n\n分布式系统的容错性(fault tolerance)\n\n1000个服务器，复杂的网络连接，总是会出现一些问题\n我们想通过应用程序来隐藏(容忍)这些失败\n\n可用性：尽管失败，我仍然可以继续使用我的文件\n\n耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复\n\n一个好主意：使用副本服务器(replicated servers)\n\n如果一个服务宕机了，客户端可以选择使用其他的服务器\n\n**分布式系统的一致性**\n\n通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的\n\n1.客户端提交并行的操作\n2.服务器在尴尬的时候崩溃\n3.网络问题可能是服务器看起来像是死机了\n4.脑裂的风险(split brain)\n\n**一致性和性能是相对的**\n\n1.一致性需要交互\n2.具有令人满意(\"严格\")语以的系统通常很慢\n3.快速的系统通常可以使应用程序面对复杂的行为\n\n案例学习: MapReduce\n\n**MapReduce概述**\n\n1.Context: 对多个TB的数据集进行多个小时的计算\n\n例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的\n\n2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理\n\n3.程序员定义Map和Reduce函数的顺序代码，通常很简单\n\n4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节\n\n**MapReduce的抽象视图**\n\n输入(input)被分为M个文件\n\n[maps 生成多行 K-V对，reduces合并列]\n\n![MapReduce](LEC1/MapReduce.png)\n\nMR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。\n\nMR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 <k2, v3> 对，结果存储在R输出文件中\n\n[MapReduce API]\n\n![MapReduceApi](LEC1/MapReduceApi.png)\n\n**MapReduce隐藏了一些细节痛点**\n\n1.在服务器上启动 s/w\n\n2.跟踪哪些任务已经完成了\n\n3.数据移动\n\n4.任务失败后恢复\n\n**Mapreduce 具有很好的扩展性**\n\n1.用N台服务器可以获得Nx的吞吐量\n\n假设 M和R >= N （即：很多的输入文件和map输出的key）\n\nMaps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的\n\n唯一的交互是maps和reduces之间的 \"shuffle\"\n\n2.因此，你可以通过购买更多的服务器来获得更多的吞吐量\n\n而不是对每个应用程序做特殊，高效的并行化\n\n**限制性能的因素是什么？**\n\n1.我们关心这个因为这正是系统性能的优化点\nCPU? 内存? 磁盘? 网络？\n\n2.网络带宽的限制\n\n网络的内部总容量，通常远小于主机之间网络链路的速度总和\n\n难以建立一个比单台计算机运行速度快1000倍的网络\n\n所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动\n\n**容灾处理**\n\n如果有服务器在MR job过程中宕机怎么处理\n\n隐藏失败是实现模型简易编程一个大的部分\n\n为什么不从一开始就重启整个job\n\nMR过程只会重新运行失败的Map()和Reduce()\n\n它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果\n\nMR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要\n\n**更多的细节**\n\n1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片\n\n输入数据存在GFS中，每个分片存了3个副本\n\n2.所有的计算机同时运行GFS和MR workers\n\n3.输入分片数比workers数要多\n\n4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务\n\n5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘\n\n直到所有Maps操作结束后才会进行Reduce计算\n\n6.Master告诉Reducers从Map操作的workers那里获取中间数据分块\n\n7.Reduce操作的workers将最终输出结果写到GFS中\n\n**如何通过细节处的设计来提高网络性能**\n\n1.Map的输入从本地磁盘读取，不是通过网络\n\n2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS\n\n3.生成的中间数据分块保存很多的key，并存储在文件中\n\n4.大块的网络传输效率更高\n\n**如果更均衡的分配负载**\n\n1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益\n\n2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件\n\n3.解决方案：split的数多于workes数\n\nMaster将新的splits分发给已经完成先前任务的workers\n\n所以更快的服务器比慢速的服务器做更多的工作，并同时完成。\n\n**MR如何应对worker崩溃呢**\n\n1.Map worker 崩溃\n\nmaster重新运行，通过其他GFS的副本作为输入\n\n即使worker已经完成，因为我们仍需要磁盘上的中间数据\n\n一些Reduce workers可能已经督过workers的中间数据\n\n2.Master怎么知道worker崩溃了(通过 pings)\n\n如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行\n\n3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker\n\n4.Reduce worker在写输出的过程中崩溃\n\nGFS具有 atomic rename ,可以防止输出在完成之前可见\n\n5.所以master在其他的地方重新运行Reduce 任务是安全的\n\n","slug":"LEC1","published":1,"updated":"2019-01-17T04:40:36.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2niir00052yw39rktw9iq","content":"<p><strong>不敢确认的翻译给出了原文，避免误解</strong></p>\n<p><strong>什么是分布式系统</strong>？</p>\n<p>1.多台主机合作</p>\n<p>2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的</p>\n<p><strong>为什么需要分布式</strong>？</p>\n<p>1.连接物理上分离的实体</p>\n<p>2.通过隔离实现安全</p>\n<p>3.通过副本来实现容错</p>\n<p>4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量</p>\n<p>5.但是：</p>\n<p>1) 分布式系统具有复杂性，包括很多并发的部分</p>\n<p>2) 必须应对系统中部分部分失败</p>\n<p>3) 很难实现性能潜力</p>\n<p><strong>实验的目标</strong>：</p>\n<p>1.更加深入的了解一些重要技术</p>\n<p>2.积累分布式系统的编程经验</p>\n<p><strong>主话题</strong></p>\n<p>1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用</p>\n<p>2.用来应用程序分布的复杂性</p>\n<p>1）三大抽象</p>\n<p>存储，交互，计算</p>\n<p>2）实现分布式系统的一些基础知识</p>\n<p>RPC，线程，并发控制</p>\n<p>3）分布式系统的性能</p>\n<p><strong>理想：可扩展的吞吐量</strong></p>\n<p>可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现</p>\n<p>所以可以通过购买更多的服务器来处理更多的负载</p>\n<p><strong>现实：扩展变得越来越困难</strong></p>\n<p>负载均衡，(stragglers)性能落后的机器</p>\n<p>很小的，不可以并行化的部分</p>\n<p>隐藏共享资源，比如网络</p>\n<p>分布式系统的容错性(fault tolerance)</p>\n<p>1000个服务器，复杂的网络连接，总是会出现一些问题<br>我们想通过应用程序来隐藏(容忍)这些失败</p>\n<p>可用性：尽管失败，我仍然可以继续使用我的文件</p>\n<p>耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复</p>\n<p>一个好主意：使用副本服务器(replicated servers)</p>\n<p>如果一个服务宕机了，客户端可以选择使用其他的服务器</p>\n<p><strong>分布式系统的一致性</strong></p>\n<p>通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的</p>\n<p>1.客户端提交并行的操作<br>2.服务器在尴尬的时候崩溃<br>3.网络问题可能是服务器看起来像是死机了<br>4.脑裂的风险(split brain)</p>\n<p><strong>一致性和性能是相对的</strong></p>\n<p>1.一致性需要交互<br>2.具有令人满意(“严格”)语以的系统通常很慢<br>3.快速的系统通常可以使应用程序面对复杂的行为</p>\n<p>案例学习: MapReduce</p>\n<p><strong>MapReduce概述</strong></p>\n<p>1.Context: 对多个TB的数据集进行多个小时的计算</p>\n<p>例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的</p>\n<p>2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理</p>\n<p>3.程序员定义Map和Reduce函数的顺序代码，通常很简单</p>\n<p>4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节</p>\n<p><strong>MapReduce的抽象视图</strong></p>\n<p>输入(input)被分为M个文件</p>\n<p>[maps 生成多行 K-V对，reduces合并列]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduce.png\" alt=\"MapReduce\"></p>\n<p>MR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。</p>\n<p>MR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 &lt;k2, v3&gt; 对，结果存储在R输出文件中</p>\n<p>[MapReduce API]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduceApi.png\" alt=\"MapReduceApi\"></p>\n<p><strong>MapReduce隐藏了一些细节痛点</strong></p>\n<p>1.在服务器上启动 s/w</p>\n<p>2.跟踪哪些任务已经完成了</p>\n<p>3.数据移动</p>\n<p>4.任务失败后恢复</p>\n<p><strong>Mapreduce 具有很好的扩展性</strong></p>\n<p>1.用N台服务器可以获得Nx的吞吐量</p>\n<p>假设 M和R &gt;= N （即：很多的输入文件和map输出的key）</p>\n<p>Maps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的</p>\n<p>唯一的交互是maps和reduces之间的 “shuffle”</p>\n<p>2.因此，你可以通过购买更多的服务器来获得更多的吞吐量</p>\n<p>而不是对每个应用程序做特殊，高效的并行化</p>\n<p><strong>限制性能的因素是什么？</strong></p>\n<p>1.我们关心这个因为这正是系统性能的优化点<br>CPU? 内存? 磁盘? 网络？</p>\n<p>2.网络带宽的限制</p>\n<p>网络的内部总容量，通常远小于主机之间网络链路的速度总和</p>\n<p>难以建立一个比单台计算机运行速度快1000倍的网络</p>\n<p>所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动</p>\n<p><strong>容灾处理</strong></p>\n<p>如果有服务器在MR job过程中宕机怎么处理</p>\n<p>隐藏失败是实现模型简易编程一个大的部分</p>\n<p>为什么不从一开始就重启整个job</p>\n<p>MR过程只会重新运行失败的Map()和Reduce()</p>\n<p>它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果</p>\n<p>MR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要</p>\n<p><strong>更多的细节</strong></p>\n<p>1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片</p>\n<p>输入数据存在GFS中，每个分片存了3个副本</p>\n<p>2.所有的计算机同时运行GFS和MR workers</p>\n<p>3.输入分片数比workers数要多</p>\n<p>4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务</p>\n<p>5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘</p>\n<p>直到所有Maps操作结束后才会进行Reduce计算</p>\n<p>6.Master告诉Reducers从Map操作的workers那里获取中间数据分块</p>\n<p>7.Reduce操作的workers将最终输出结果写到GFS中</p>\n<p><strong>如何通过细节处的设计来提高网络性能</strong></p>\n<p>1.Map的输入从本地磁盘读取，不是通过网络</p>\n<p>2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS</p>\n<p>3.生成的中间数据分块保存很多的key，并存储在文件中</p>\n<p>4.大块的网络传输效率更高</p>\n<p><strong>如果更均衡的分配负载</strong></p>\n<p>1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益</p>\n<p>2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件</p>\n<p>3.解决方案：split的数多于workes数</p>\n<p>Master将新的splits分发给已经完成先前任务的workers</p>\n<p>所以更快的服务器比慢速的服务器做更多的工作，并同时完成。</p>\n<p><strong>MR如何应对worker崩溃呢</strong></p>\n<p>1.Map worker 崩溃</p>\n<p>master重新运行，通过其他GFS的副本作为输入</p>\n<p>即使worker已经完成，因为我们仍需要磁盘上的中间数据</p>\n<p>一些Reduce workers可能已经督过workers的中间数据</p>\n<p>2.Master怎么知道worker崩溃了(通过 pings)</p>\n<p>如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行</p>\n<p>3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker</p>\n<p>4.Reduce worker在写输出的过程中崩溃</p>\n<p>GFS具有 atomic rename ,可以防止输出在完成之前可见</p>\n<p>5.所以master在其他的地方重新运行Reduce 任务是安全的</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>不敢确认的翻译给出了原文，避免误解</strong></p>\n<p><strong>什么是分布式系统</strong>？</p>\n<p>1.多台主机合作</p>\n<p>2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的</p>\n<p><strong>为什么需要分布式</strong>？</p>\n<p>1.连接物理上分离的实体</p>\n<p>2.通过隔离实现安全</p>\n<p>3.通过副本来实现容错</p>\n<p>4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量</p>\n<p>5.但是：</p>\n<p>1) 分布式系统具有复杂性，包括很多并发的部分</p>\n<p>2) 必须应对系统中部分部分失败</p>\n<p>3) 很难实现性能潜力</p>\n<p><strong>实验的目标</strong>：</p>\n<p>1.更加深入的了解一些重要技术</p>\n<p>2.积累分布式系统的编程经验</p>\n<p><strong>主话题</strong></p>\n<p>1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用</p>\n<p>2.用来应用程序分布的复杂性</p>\n<p>1）三大抽象</p>\n<p>存储，交互，计算</p>\n<p>2）实现分布式系统的一些基础知识</p>\n<p>RPC，线程，并发控制</p>\n<p>3）分布式系统的性能</p>\n<p><strong>理想：可扩展的吞吐量</strong></p>\n<p>可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现</p>\n<p>所以可以通过购买更多的服务器来处理更多的负载</p>\n<p><strong>现实：扩展变得越来越困难</strong></p>\n<p>负载均衡，(stragglers)性能落后的机器</p>\n<p>很小的，不可以并行化的部分</p>\n<p>隐藏共享资源，比如网络</p>\n<p>分布式系统的容错性(fault tolerance)</p>\n<p>1000个服务器，复杂的网络连接，总是会出现一些问题<br>我们想通过应用程序来隐藏(容忍)这些失败</p>\n<p>可用性：尽管失败，我仍然可以继续使用我的文件</p>\n<p>耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复</p>\n<p>一个好主意：使用副本服务器(replicated servers)</p>\n<p>如果一个服务宕机了，客户端可以选择使用其他的服务器</p>\n<p><strong>分布式系统的一致性</strong></p>\n<p>通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的</p>\n<p>1.客户端提交并行的操作<br>2.服务器在尴尬的时候崩溃<br>3.网络问题可能是服务器看起来像是死机了<br>4.脑裂的风险(split brain)</p>\n<p><strong>一致性和性能是相对的</strong></p>\n<p>1.一致性需要交互<br>2.具有令人满意(“严格”)语以的系统通常很慢<br>3.快速的系统通常可以使应用程序面对复杂的行为</p>\n<p>案例学习: MapReduce</p>\n<p><strong>MapReduce概述</strong></p>\n<p>1.Context: 对多个TB的数据集进行多个小时的计算</p>\n<p>例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的</p>\n<p>2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理</p>\n<p>3.程序员定义Map和Reduce函数的顺序代码，通常很简单</p>\n<p>4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节</p>\n<p><strong>MapReduce的抽象视图</strong></p>\n<p>输入(input)被分为M个文件</p>\n<p>[maps 生成多行 K-V对，reduces合并列]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduce.png\" alt=\"MapReduce\"></p>\n<p>MR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。</p>\n<p>MR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 &lt;k2, v3&gt; 对，结果存储在R输出文件中</p>\n<p>[MapReduce API]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduceApi.png\" alt=\"MapReduceApi\"></p>\n<p><strong>MapReduce隐藏了一些细节痛点</strong></p>\n<p>1.在服务器上启动 s/w</p>\n<p>2.跟踪哪些任务已经完成了</p>\n<p>3.数据移动</p>\n<p>4.任务失败后恢复</p>\n<p><strong>Mapreduce 具有很好的扩展性</strong></p>\n<p>1.用N台服务器可以获得Nx的吞吐量</p>\n<p>假设 M和R &gt;= N （即：很多的输入文件和map输出的key）</p>\n<p>Maps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的</p>\n<p>唯一的交互是maps和reduces之间的 “shuffle”</p>\n<p>2.因此，你可以通过购买更多的服务器来获得更多的吞吐量</p>\n<p>而不是对每个应用程序做特殊，高效的并行化</p>\n<p><strong>限制性能的因素是什么？</strong></p>\n<p>1.我们关心这个因为这正是系统性能的优化点<br>CPU? 内存? 磁盘? 网络？</p>\n<p>2.网络带宽的限制</p>\n<p>网络的内部总容量，通常远小于主机之间网络链路的速度总和</p>\n<p>难以建立一个比单台计算机运行速度快1000倍的网络</p>\n<p>所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动</p>\n<p><strong>容灾处理</strong></p>\n<p>如果有服务器在MR job过程中宕机怎么处理</p>\n<p>隐藏失败是实现模型简易编程一个大的部分</p>\n<p>为什么不从一开始就重启整个job</p>\n<p>MR过程只会重新运行失败的Map()和Reduce()</p>\n<p>它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果</p>\n<p>MR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要</p>\n<p><strong>更多的细节</strong></p>\n<p>1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片</p>\n<p>输入数据存在GFS中，每个分片存了3个副本</p>\n<p>2.所有的计算机同时运行GFS和MR workers</p>\n<p>3.输入分片数比workers数要多</p>\n<p>4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务</p>\n<p>5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘</p>\n<p>直到所有Maps操作结束后才会进行Reduce计算</p>\n<p>6.Master告诉Reducers从Map操作的workers那里获取中间数据分块</p>\n<p>7.Reduce操作的workers将最终输出结果写到GFS中</p>\n<p><strong>如何通过细节处的设计来提高网络性能</strong></p>\n<p>1.Map的输入从本地磁盘读取，不是通过网络</p>\n<p>2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS</p>\n<p>3.生成的中间数据分块保存很多的key，并存储在文件中</p>\n<p>4.大块的网络传输效率更高</p>\n<p><strong>如果更均衡的分配负载</strong></p>\n<p>1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益</p>\n<p>2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件</p>\n<p>3.解决方案：split的数多于workes数</p>\n<p>Master将新的splits分发给已经完成先前任务的workers</p>\n<p>所以更快的服务器比慢速的服务器做更多的工作，并同时完成。</p>\n<p><strong>MR如何应对worker崩溃呢</strong></p>\n<p>1.Map worker 崩溃</p>\n<p>master重新运行，通过其他GFS的副本作为输入</p>\n<p>即使worker已经完成，因为我们仍需要磁盘上的中间数据</p>\n<p>一些Reduce workers可能已经督过workers的中间数据</p>\n<p>2.Master怎么知道worker崩溃了(通过 pings)</p>\n<p>如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行</p>\n<p>3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker</p>\n<p>4.Reduce worker在写输出的过程中崩溃</p>\n<p>GFS具有 atomic rename ,可以防止输出在完成之前可见</p>\n<p>5.所以master在其他的地方重新运行Reduce 任务是安全的</p>\n"},{"title":"LEC10-vedio","date":"2019-01-17T01:36:41.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC10-vedio.md","raw":"---\ntitle: LEC10-vedio\ndate: 2019-01-17 09:36:41\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC10-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2niiv00072yw3tcjrngft","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC15-vedio","date":"2019-01-17T01:37:08.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC15-vedio.md","raw":"---\ntitle: LEC15-vedio\ndate: 2019-01-17 09:37:08\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC15-vedio","published":1,"updated":"2019-01-17T04:50:19.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2niix00082yw3db75783l","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC13-vedio","date":"2019-01-17T01:36:59.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC13-vedio.md","raw":"---\ntitle: LEC13-vedio\ndate: 2019-01-17 09:36:59\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC13-vedio","published":1,"updated":"2019-01-17T04:50:19.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2niiy00092yw3ag56vygz","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC12-vedio","date":"2019-01-17T01:36:53.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC12-vedio.md","raw":"---\ntitle: LEC12-vedio\ndate: 2019-01-17 09:36:53\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC12-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nij2000c2yw30ep0gmic","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC16-vedio","date":"2019-01-17T04:36:30.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n","source":"_posts/LEC16-vedio.md","raw":"---\ntitle: LEC16-vedio\ndate: 2019-01-17 12:36:30\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n","slug":"LEC16-vedio","published":1,"updated":"2019-01-17T04:50:19.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nij4000e2yw3sg5x2133","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n"},{"title":"LEC17-vedio","date":"2019-01-17T04:36:35.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC17-vedio.md","raw":"---\ntitle: LEC17-vedio\ndate: 2019-01-17 12:36:35\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC17-vedio","published":1,"updated":"2019-01-17T04:55:01.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nij7000h2yw3gtgegihb","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC2-vedio","date":"2019-01-17T01:35:51.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC2-vedio.md","raw":"---\ntitle: LEC2-vedio\ndate: 2019-01-17 09:35:51\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC2-vedio","published":1,"updated":"2019-01-17T04:53:21.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nij8000j2yw3wzpnwg4y","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC20-vedio","date":"2019-01-17T04:36:52.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC20-vedio.md","raw":"---\ntitle: LEC20-vedio\ndate: 2019-01-17 12:36:52\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC20-vedio","published":1,"updated":"2019-01-17T04:43:23.603Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nij9000l2yw31jtwyepl","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC2","date":"2019-01-17T04:50:09.000Z","_content":"\n#### 基础设施: RPC 和 线程\n\n**一个最常被问到的问题:为什么使用Go**\n\n***6.824这门课原先是使用C++的***\n\n学生花了很多时间去修与构建分布式系统无关的bug\n\n例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象\n\n***Go 语言可以让你更专注的处理分布式系统的问题***\n\n1.Go语言是类型安全的\n\n2.它有垃圾收集器（不会存在对象没有free导致的程序bug）\n\n3.对并发编程的支持很友好\n\n4.对RPC的支持很友好\n\n***我们喜欢用Go编程***\n\n1.Go很容易学习\n\n2.Go语言推荐资料 https://golang.org/doc/effective_go.html#generality\n\n**远程过程调用 (RPC)**\n\n1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写\n\n2.隐藏了客户端/服务器通信的大部分细节\n\n3.通过RPC客户端的远程调用就像普通的过程调用\n\n4.服务器的处理程序和普通的程序类似\n\n5.RPC被广泛使用\n\n**理想情况下，RPC使得网络通信看起来就像函数的调用**\n\n客户端：\n\n```\nz = fn(x, y)\n```\n\n服务器：\n\n```\nfn(x, y) {\n    compute\n    return z\n}\n```\n\nRPC旨在实现这种透明度的调用\n\nGo语言RPC的库 https://golang.org/pkg/net/rpc/\n\n**RPC 消息图**\n\nClient\t\t\t\tServer\n\nrequest --->\n\n​\t\t\t<--- response\n\n**软件架构**\n\n客户端应用存根\t\t\t处理调用\n\nRPC 库\t\t\t\t\tRPC库\n\nNet   ——————————   Net\n\n**更多的细节**\n\n1.要调用服务器的那个处理函数\n\n2.Marshalling（编组）：将数据格式化为数据包\n\n​\t1）处理数组、指针和对象是很棘手的\n\n​\t2）Go的RPC库是相当强大的\n\n​\t3）有一些东西你不能传送：例如，channels（通道）,functions（函数）\n\n3.Binding（绑定）:客户端如何知道与谁交互?\n\n​       1）客户端被提供了服务器的主机名\n\n​       2）也许名称服务将服务映射到最佳的服务器主机\n\n4.线程：\n\n​\t1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应\n\n​\t2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序\n\n**RPC问题：如何处理失败**\n\n​\t例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃\n\n**客户端RPC库中的故障是什么样的?**\n\n1.客户端从未收到服务器的响应\n\n2.客户端不知道服务器是否能看到请求\n\n3.可能服务器或者网络在发送回复之前失败了\n\n**最简单的方案：“至少一次”行为**\n\n1.RPC库等待响应一段时间\n\n2.如果没有响应到达，重新发送请求\n\n3.多次尝试\n\n4.仍然没有响应的话，向应用程序返回一个错误\n\n5.问题：应用程序容易处理至少一次的操作吗？\n\n​\t至少一次：客户端发送“从银行账户中扣除5美元”\n\n6.问题：这个客户端程序有什么问题？\n\n​\tput(\"k\", 10) 通过RPC在数据库服务器中设置key的值\t\n\n​\tput(\"k\", 20) 然后客户端执行第二次put操作到同一个key\n\n7.问题：至少一次总是OK的吗？\n\n​\t1）重复操作是可以的，例如只读操作\n\n​\t2）如果应用程序有自己对于写副本的执行计划\n\n**更好的PRC行为：“至多一次”**\n\n1.想法：服务器RPC代码检测重复请求\n\n2.返回上一个reply，而不是重新运行处理程序\n\n**如何检测重复的请求**\n\n1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送\t\n\n```\nserver:\nif seen[xid]:\n\tr = old[xid]\nelse\n\tr = handler()\n\told[xid] = r\n\tseen[xid] = true\n```\n\n**至多一次请求的复杂之处**\n\n1.这将在实验2和以后的实验中出现\n\n2.如何确保XID是唯一的？\n\n​\t大的随机数？\n\n​\t合并唯一客户端ID（IP地址？）有序列？\n\n​\t服务器必须最终放弃优化旧的RPC的信息\n\n​\t1）什么时候丢弃是安全的\n\n​\t想法：\n\n​\t唯一的客户端ID\n\n​\t上一次客户端RPC请求的序列号\n\n​\t客户端的每一个RPCC包含\"seen all replies <= X\"\n\n​\t像TCP的sequence号一样\n\n​\t或者一次只允许一个客户端PRC\n\n​\t当seq + 1到达允许服务器放弃所有的 <= seq 的请求\n\n​\t或者客户端同意小于5分钟的重试，5分钟后服务器放弃\n\n如何处理相同的请求当原来的请求仍然在执行？\n\n​\t服务器不知道要回复，不想重复运行\n\n​\t想法：给每个正在执行的RPC设置一个\"pending\" flag；等待或者忽略相同的请求\n\n**当一个 at-most-once 服务器宕机和重启怎么办？**\n\n1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求\n\n2.也许它应该吧重复的信息写到磁盘？\n\n3.也许副本服务器也应该复制重复的信息？\n\n**\"一次就好\"怎么样？**\n\n最多一次加上无限制的重试加上容错服务\n\n**Go的RPC是 “at-most-once”**\n\n1.打开TCP连接\n\n2.向TCP连接中写入请求\n\n3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求\n\n4.Go的代码里面没有重试\n\n5.Go RPC代码在没有得到回复的时候会返回一个error\n\n1）可能在一个TCP超时之后\n\n2）可能服务器没有看到请求\n\n3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败\n\n**Go RPC的 at-most-once 不足以应对Lab1**\n\n1.它只适用于单个RPC调用\n\n2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败\n\n3.Go的RPC不能检测出这种重复\n\n1）在lab1中没问题，它在应用层处理了\n\n2）Lab2需要明确的检测重复提交\n\n**线程**\n\n1.线程是一个基本的服务结构工具\n\n2.你将会在lab中广泛的使用它\n\n3.它们可能很棘手\n\n4.但是对PRC非常有用\n\n5.Go称它们为Goroutines，也有很多人称它们为线程\n\n**Thread = \"Thread of control\"**\n\n1.多线程允许程序逻辑上在同一时刻同时做很多事情\n\n2.线程共享内存\n\n3.线程之间共享程序计数器，寄存器，栈空间\n\n**多线程的一些挑战**\n\n1.共享数据\n\n1）两个线程如果同时修改了相同的变量会怎么样？\n\n2）一个线程正在读数据，另一个线程改变数据呢？\n\n3）需要保护共享数据上的不变量\n\n4）使用Go sync.Mutex锁\n\n2.线程之间的通过\n\n例如：等待所有的Map线程完成\n\n使用Go channels\n\n3.死锁\n\n1）线程1等待线程2\n\n2）线程2等待线程1\n\n4.锁粒度\n\n1）粗粒度->实现简单，但是并发性能不好\n\n2）细粒度->更好的并发性能，更多的锁竞争(races)和死锁\n\n5.让我们来看labrpc 包里如何解决这些问题\n\n1）它类似于Go的RPC系统，但是网络是一个模拟网络\n\n- 网络延迟请求和响应\n- 网络丢包请求和响应\n- 网络的重发请求和响应\n\n2）说明 threads，mutexes，channels的用法\n\n3）使用Go实现了一个完整的RPC包\n\n**网络的结构**\n\n1.网络的描述\n\n1）服务器\n\n2）客户端\n\n2.每个网络都是互斥的\n\n**RPC概述**\n\n1.在test_test.go文件里面有很多例子\n\n2.应用调用RPC\n\n```\nreply := end.Call(\"Raft.AppendEntries\", args, &reply) //发出一个RPC请求，等待回复\n```\n\n3.服务端\n\n```\nsrv := MakeServer()\nsrv.AddService(svc) -- 一个服务器可以有多种服务\n```\n\n4.k/v\n\n将srv传递给 net.AddServer()\n\n```\nsvc := MakeService(recevierPbject) -- obj's 方法会处理RPC请求\n```\n\n非常像Go的rpcs.Register()\n\n传递svc给 srv.AddService()\n\n5.服务器的数据结构\n\n1）AddService()\n\n添加一个服务名\n\n问题：为什么使用锁？\n\n问题：什么事defer()？\n\n2）Dispatch()\n\n分发一个请求到正确的服务\n\n问题：为什么持有锁？\n\n问题：为什么持有锁的范围互道函数的末尾？\n\n3）Call()\n\n使用反射查找参数的类型\n\n使用gob编码参数\n\ne.ch 是网络发送请求的通道\n\n使用一个通道来接收网络的回复（<- req.replyCh）\n\n4）MakeEnd()\n\n有一个模拟网络的线程/goroutine\n\n从e.ch中读取并处理请求\n\n每个请求都在一个单独的goroutine中处理\n\nQ：一个endpoint 可以有很多未完成的请求吗\n\nQ：为什么使用rn.mu.Lock()？\n\nQ：锁保护了什么？\n\n5）ProcessReq()\n\n查找一个服务endpoint\n\n如果网络不可靠，可能会延迟或者丢失请求\n\n分发请求到一个新的线程\n\n通过读取ech中的数据等待服务端回复直到100ms过去\n\n100ms只是用来验证服务器是不是宕机了\n\n然后回复\n\nQ：谁将会读取回复？\n\nQ：如果ProcessReq不持有rn的锁可以吗？\n\n6）Service.dispatch()\n\n给请求找到一个处理的方法\n\n解码参数\n\n调用函数\n\n编码回复\n\n返回回复信息\n\nGo的内存模型需要显示同步才能进行通信\n\n下面代码是不正确的\n\n```\nvar x int\ndone := false\ngo func() { x = f(...); done = true }\nwhile done == false { }\n```\n\n这是一个非常诱人的写法，但是Go会说这是为定义的\n\n使用通道或者sync.WaitGroup代替\n\n**学习Go的goroutines和channels**\n\nhttps://golang.org/doc/articles/race_detector.html","source":"_posts/LEC2.md","raw":"---\ntitle: LEC2\ndate: 2019-01-17 12:50:09\ntags: 分布式系统6.824笔记\n---\n\n#### 基础设施: RPC 和 线程\n\n**一个最常被问到的问题:为什么使用Go**\n\n***6.824这门课原先是使用C++的***\n\n学生花了很多时间去修与构建分布式系统无关的bug\n\n例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象\n\n***Go 语言可以让你更专注的处理分布式系统的问题***\n\n1.Go语言是类型安全的\n\n2.它有垃圾收集器（不会存在对象没有free导致的程序bug）\n\n3.对并发编程的支持很友好\n\n4.对RPC的支持很友好\n\n***我们喜欢用Go编程***\n\n1.Go很容易学习\n\n2.Go语言推荐资料 https://golang.org/doc/effective_go.html#generality\n\n**远程过程调用 (RPC)**\n\n1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写\n\n2.隐藏了客户端/服务器通信的大部分细节\n\n3.通过RPC客户端的远程调用就像普通的过程调用\n\n4.服务器的处理程序和普通的程序类似\n\n5.RPC被广泛使用\n\n**理想情况下，RPC使得网络通信看起来就像函数的调用**\n\n客户端：\n\n```\nz = fn(x, y)\n```\n\n服务器：\n\n```\nfn(x, y) {\n    compute\n    return z\n}\n```\n\nRPC旨在实现这种透明度的调用\n\nGo语言RPC的库 https://golang.org/pkg/net/rpc/\n\n**RPC 消息图**\n\nClient\t\t\t\tServer\n\nrequest --->\n\n​\t\t\t<--- response\n\n**软件架构**\n\n客户端应用存根\t\t\t处理调用\n\nRPC 库\t\t\t\t\tRPC库\n\nNet   ——————————   Net\n\n**更多的细节**\n\n1.要调用服务器的那个处理函数\n\n2.Marshalling（编组）：将数据格式化为数据包\n\n​\t1）处理数组、指针和对象是很棘手的\n\n​\t2）Go的RPC库是相当强大的\n\n​\t3）有一些东西你不能传送：例如，channels（通道）,functions（函数）\n\n3.Binding（绑定）:客户端如何知道与谁交互?\n\n​       1）客户端被提供了服务器的主机名\n\n​       2）也许名称服务将服务映射到最佳的服务器主机\n\n4.线程：\n\n​\t1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应\n\n​\t2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序\n\n**RPC问题：如何处理失败**\n\n​\t例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃\n\n**客户端RPC库中的故障是什么样的?**\n\n1.客户端从未收到服务器的响应\n\n2.客户端不知道服务器是否能看到请求\n\n3.可能服务器或者网络在发送回复之前失败了\n\n**最简单的方案：“至少一次”行为**\n\n1.RPC库等待响应一段时间\n\n2.如果没有响应到达，重新发送请求\n\n3.多次尝试\n\n4.仍然没有响应的话，向应用程序返回一个错误\n\n5.问题：应用程序容易处理至少一次的操作吗？\n\n​\t至少一次：客户端发送“从银行账户中扣除5美元”\n\n6.问题：这个客户端程序有什么问题？\n\n​\tput(\"k\", 10) 通过RPC在数据库服务器中设置key的值\t\n\n​\tput(\"k\", 20) 然后客户端执行第二次put操作到同一个key\n\n7.问题：至少一次总是OK的吗？\n\n​\t1）重复操作是可以的，例如只读操作\n\n​\t2）如果应用程序有自己对于写副本的执行计划\n\n**更好的PRC行为：“至多一次”**\n\n1.想法：服务器RPC代码检测重复请求\n\n2.返回上一个reply，而不是重新运行处理程序\n\n**如何检测重复的请求**\n\n1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送\t\n\n```\nserver:\nif seen[xid]:\n\tr = old[xid]\nelse\n\tr = handler()\n\told[xid] = r\n\tseen[xid] = true\n```\n\n**至多一次请求的复杂之处**\n\n1.这将在实验2和以后的实验中出现\n\n2.如何确保XID是唯一的？\n\n​\t大的随机数？\n\n​\t合并唯一客户端ID（IP地址？）有序列？\n\n​\t服务器必须最终放弃优化旧的RPC的信息\n\n​\t1）什么时候丢弃是安全的\n\n​\t想法：\n\n​\t唯一的客户端ID\n\n​\t上一次客户端RPC请求的序列号\n\n​\t客户端的每一个RPCC包含\"seen all replies <= X\"\n\n​\t像TCP的sequence号一样\n\n​\t或者一次只允许一个客户端PRC\n\n​\t当seq + 1到达允许服务器放弃所有的 <= seq 的请求\n\n​\t或者客户端同意小于5分钟的重试，5分钟后服务器放弃\n\n如何处理相同的请求当原来的请求仍然在执行？\n\n​\t服务器不知道要回复，不想重复运行\n\n​\t想法：给每个正在执行的RPC设置一个\"pending\" flag；等待或者忽略相同的请求\n\n**当一个 at-most-once 服务器宕机和重启怎么办？**\n\n1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求\n\n2.也许它应该吧重复的信息写到磁盘？\n\n3.也许副本服务器也应该复制重复的信息？\n\n**\"一次就好\"怎么样？**\n\n最多一次加上无限制的重试加上容错服务\n\n**Go的RPC是 “at-most-once”**\n\n1.打开TCP连接\n\n2.向TCP连接中写入请求\n\n3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求\n\n4.Go的代码里面没有重试\n\n5.Go RPC代码在没有得到回复的时候会返回一个error\n\n1）可能在一个TCP超时之后\n\n2）可能服务器没有看到请求\n\n3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败\n\n**Go RPC的 at-most-once 不足以应对Lab1**\n\n1.它只适用于单个RPC调用\n\n2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败\n\n3.Go的RPC不能检测出这种重复\n\n1）在lab1中没问题，它在应用层处理了\n\n2）Lab2需要明确的检测重复提交\n\n**线程**\n\n1.线程是一个基本的服务结构工具\n\n2.你将会在lab中广泛的使用它\n\n3.它们可能很棘手\n\n4.但是对PRC非常有用\n\n5.Go称它们为Goroutines，也有很多人称它们为线程\n\n**Thread = \"Thread of control\"**\n\n1.多线程允许程序逻辑上在同一时刻同时做很多事情\n\n2.线程共享内存\n\n3.线程之间共享程序计数器，寄存器，栈空间\n\n**多线程的一些挑战**\n\n1.共享数据\n\n1）两个线程如果同时修改了相同的变量会怎么样？\n\n2）一个线程正在读数据，另一个线程改变数据呢？\n\n3）需要保护共享数据上的不变量\n\n4）使用Go sync.Mutex锁\n\n2.线程之间的通过\n\n例如：等待所有的Map线程完成\n\n使用Go channels\n\n3.死锁\n\n1）线程1等待线程2\n\n2）线程2等待线程1\n\n4.锁粒度\n\n1）粗粒度->实现简单，但是并发性能不好\n\n2）细粒度->更好的并发性能，更多的锁竞争(races)和死锁\n\n5.让我们来看labrpc 包里如何解决这些问题\n\n1）它类似于Go的RPC系统，但是网络是一个模拟网络\n\n- 网络延迟请求和响应\n- 网络丢包请求和响应\n- 网络的重发请求和响应\n\n2）说明 threads，mutexes，channels的用法\n\n3）使用Go实现了一个完整的RPC包\n\n**网络的结构**\n\n1.网络的描述\n\n1）服务器\n\n2）客户端\n\n2.每个网络都是互斥的\n\n**RPC概述**\n\n1.在test_test.go文件里面有很多例子\n\n2.应用调用RPC\n\n```\nreply := end.Call(\"Raft.AppendEntries\", args, &reply) //发出一个RPC请求，等待回复\n```\n\n3.服务端\n\n```\nsrv := MakeServer()\nsrv.AddService(svc) -- 一个服务器可以有多种服务\n```\n\n4.k/v\n\n将srv传递给 net.AddServer()\n\n```\nsvc := MakeService(recevierPbject) -- obj's 方法会处理RPC请求\n```\n\n非常像Go的rpcs.Register()\n\n传递svc给 srv.AddService()\n\n5.服务器的数据结构\n\n1）AddService()\n\n添加一个服务名\n\n问题：为什么使用锁？\n\n问题：什么事defer()？\n\n2）Dispatch()\n\n分发一个请求到正确的服务\n\n问题：为什么持有锁？\n\n问题：为什么持有锁的范围互道函数的末尾？\n\n3）Call()\n\n使用反射查找参数的类型\n\n使用gob编码参数\n\ne.ch 是网络发送请求的通道\n\n使用一个通道来接收网络的回复（<- req.replyCh）\n\n4）MakeEnd()\n\n有一个模拟网络的线程/goroutine\n\n从e.ch中读取并处理请求\n\n每个请求都在一个单独的goroutine中处理\n\nQ：一个endpoint 可以有很多未完成的请求吗\n\nQ：为什么使用rn.mu.Lock()？\n\nQ：锁保护了什么？\n\n5）ProcessReq()\n\n查找一个服务endpoint\n\n如果网络不可靠，可能会延迟或者丢失请求\n\n分发请求到一个新的线程\n\n通过读取ech中的数据等待服务端回复直到100ms过去\n\n100ms只是用来验证服务器是不是宕机了\n\n然后回复\n\nQ：谁将会读取回复？\n\nQ：如果ProcessReq不持有rn的锁可以吗？\n\n6）Service.dispatch()\n\n给请求找到一个处理的方法\n\n解码参数\n\n调用函数\n\n编码回复\n\n返回回复信息\n\nGo的内存模型需要显示同步才能进行通信\n\n下面代码是不正确的\n\n```\nvar x int\ndone := false\ngo func() { x = f(...); done = true }\nwhile done == false { }\n```\n\n这是一个非常诱人的写法，但是Go会说这是为定义的\n\n使用通道或者sync.WaitGroup代替\n\n**学习Go的goroutines和channels**\n\nhttps://golang.org/doc/articles/race_detector.html","slug":"LEC2","published":1,"updated":"2019-01-24T15:32:30.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nija000n2yw3fskfc6ck","content":"<h4 id=\"基础设施-RPC-和-线程\"><a href=\"#基础设施-RPC-和-线程\" class=\"headerlink\" title=\"基础设施: RPC 和 线程\"></a>基础设施: RPC 和 线程</h4><p><strong>一个最常被问到的问题:为什么使用Go</strong></p>\n<p><strong><em>6.824这门课原先是使用C++的</em></strong></p>\n<p>学生花了很多时间去修与构建分布式系统无关的bug</p>\n<p>例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象</p>\n<p><strong><em>Go 语言可以让你更专注的处理分布式系统的问题</em></strong></p>\n<p>1.Go语言是类型安全的</p>\n<p>2.它有垃圾收集器（不会存在对象没有free导致的程序bug）</p>\n<p>3.对并发编程的支持很友好</p>\n<p>4.对RPC的支持很友好</p>\n<p><strong><em>我们喜欢用Go编程</em></strong></p>\n<p>1.Go很容易学习</p>\n<p>2.Go语言推荐资料 <a href=\"https://golang.org/doc/effective_go.html#generality\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/effective_go.html#generality</a></p>\n<p><strong>远程过程调用 (RPC)</strong></p>\n<p>1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写</p>\n<p>2.隐藏了客户端/服务器通信的大部分细节</p>\n<p>3.通过RPC客户端的远程调用就像普通的过程调用</p>\n<p>4.服务器的处理程序和普通的程序类似</p>\n<p>5.RPC被广泛使用</p>\n<p><strong>理想情况下，RPC使得网络通信看起来就像函数的调用</strong></p>\n<p>客户端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = fn(x, y)</span><br></pre></td></tr></table></figure>\n<p>服务器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn(x, y) &#123;</span><br><span class=\"line\">    compute</span><br><span class=\"line\">    return z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RPC旨在实现这种透明度的调用</p>\n<p>Go语言RPC的库 <a href=\"https://golang.org/pkg/net/rpc/\" target=\"_blank\" rel=\"noopener\">https://golang.org/pkg/net/rpc/</a></p>\n<p><strong>RPC 消息图</strong></p>\n<p>Client                Server</p>\n<p>request —&gt;</p>\n<p>​            &lt;— response</p>\n<p><strong>软件架构</strong></p>\n<p>客户端应用存根            处理调用</p>\n<p>RPC 库                    RPC库</p>\n<p>Net   ——————————   Net</p>\n<p><strong>更多的细节</strong></p>\n<p>1.要调用服务器的那个处理函数</p>\n<p>2.Marshalling（编组）：将数据格式化为数据包</p>\n<p>​    1）处理数组、指针和对象是很棘手的</p>\n<p>​    2）Go的RPC库是相当强大的</p>\n<p>​    3）有一些东西你不能传送：例如，channels（通道）,functions（函数）</p>\n<p>3.Binding（绑定）:客户端如何知道与谁交互?</p>\n<p>​       1）客户端被提供了服务器的主机名</p>\n<p>​       2）也许名称服务将服务映射到最佳的服务器主机</p>\n<p>4.线程：</p>\n<p>​    1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应</p>\n<p>​    2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序</p>\n<p><strong>RPC问题：如何处理失败</strong></p>\n<p>​    例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃</p>\n<p><strong>客户端RPC库中的故障是什么样的?</strong></p>\n<p>1.客户端从未收到服务器的响应</p>\n<p>2.客户端不知道服务器是否能看到请求</p>\n<p>3.可能服务器或者网络在发送回复之前失败了</p>\n<p><strong>最简单的方案：“至少一次”行为</strong></p>\n<p>1.RPC库等待响应一段时间</p>\n<p>2.如果没有响应到达，重新发送请求</p>\n<p>3.多次尝试</p>\n<p>4.仍然没有响应的话，向应用程序返回一个错误</p>\n<p>5.问题：应用程序容易处理至少一次的操作吗？</p>\n<p>​    至少一次：客户端发送“从银行账户中扣除5美元”</p>\n<p>6.问题：这个客户端程序有什么问题？</p>\n<p>​    put(“k”, 10) 通过RPC在数据库服务器中设置key的值    </p>\n<p>​    put(“k”, 20) 然后客户端执行第二次put操作到同一个key</p>\n<p>7.问题：至少一次总是OK的吗？</p>\n<p>​    1）重复操作是可以的，例如只读操作</p>\n<p>​    2）如果应用程序有自己对于写副本的执行计划</p>\n<p><strong>更好的PRC行为：“至多一次”</strong></p>\n<p>1.想法：服务器RPC代码检测重复请求</p>\n<p>2.返回上一个reply，而不是重新运行处理程序</p>\n<p><strong>如何检测重复的请求</strong></p>\n<p>1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">if seen[xid]:</span><br><span class=\"line\">\tr = old[xid]</span><br><span class=\"line\">else</span><br><span class=\"line\">\tr = handler()</span><br><span class=\"line\">\told[xid] = r</span><br><span class=\"line\">\tseen[xid] = true</span><br></pre></td></tr></table></figure>\n<p><strong>至多一次请求的复杂之处</strong></p>\n<p>1.这将在实验2和以后的实验中出现</p>\n<p>2.如何确保XID是唯一的？</p>\n<p>​    大的随机数？</p>\n<p>​    合并唯一客户端ID（IP地址？）有序列？</p>\n<p>​    服务器必须最终放弃优化旧的RPC的信息</p>\n<p>​    1）什么时候丢弃是安全的</p>\n<p>​    想法：</p>\n<p>​    唯一的客户端ID</p>\n<p>​    上一次客户端RPC请求的序列号</p>\n<p>​    客户端的每一个RPCC包含”seen all replies &lt;= X”</p>\n<p>​    像TCP的sequence号一样</p>\n<p>​    或者一次只允许一个客户端PRC</p>\n<p>​    当seq + 1到达允许服务器放弃所有的 &lt;= seq 的请求</p>\n<p>​    或者客户端同意小于5分钟的重试，5分钟后服务器放弃</p>\n<p>如何处理相同的请求当原来的请求仍然在执行？</p>\n<p>​    服务器不知道要回复，不想重复运行</p>\n<p>​    想法：给每个正在执行的RPC设置一个”pending” flag；等待或者忽略相同的请求</p>\n<p><strong>当一个 at-most-once 服务器宕机和重启怎么办？</strong></p>\n<p>1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求</p>\n<p>2.也许它应该吧重复的信息写到磁盘？</p>\n<p>3.也许副本服务器也应该复制重复的信息？</p>\n<p><strong>“一次就好”怎么样？</strong></p>\n<p>最多一次加上无限制的重试加上容错服务</p>\n<p><strong>Go的RPC是 “at-most-once”</strong></p>\n<p>1.打开TCP连接</p>\n<p>2.向TCP连接中写入请求</p>\n<p>3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求</p>\n<p>4.Go的代码里面没有重试</p>\n<p>5.Go RPC代码在没有得到回复的时候会返回一个error</p>\n<p>1）可能在一个TCP超时之后</p>\n<p>2）可能服务器没有看到请求</p>\n<p>3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败</p>\n<p><strong>Go RPC的 at-most-once 不足以应对Lab1</strong></p>\n<p>1.它只适用于单个RPC调用</p>\n<p>2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败</p>\n<p>3.Go的RPC不能检测出这种重复</p>\n<p>1）在lab1中没问题，它在应用层处理了</p>\n<p>2）Lab2需要明确的检测重复提交</p>\n<p><strong>线程</strong></p>\n<p>1.线程是一个基本的服务结构工具</p>\n<p>2.你将会在lab中广泛的使用它</p>\n<p>3.它们可能很棘手</p>\n<p>4.但是对PRC非常有用</p>\n<p>5.Go称它们为Goroutines，也有很多人称它们为线程</p>\n<p><strong>Thread = “Thread of control”</strong></p>\n<p>1.多线程允许程序逻辑上在同一时刻同时做很多事情</p>\n<p>2.线程共享内存</p>\n<p>3.线程之间共享程序计数器，寄存器，栈空间</p>\n<p><strong>多线程的一些挑战</strong></p>\n<p>1.共享数据</p>\n<p>1）两个线程如果同时修改了相同的变量会怎么样？</p>\n<p>2）一个线程正在读数据，另一个线程改变数据呢？</p>\n<p>3）需要保护共享数据上的不变量</p>\n<p>4）使用Go sync.Mutex锁</p>\n<p>2.线程之间的通过</p>\n<p>例如：等待所有的Map线程完成</p>\n<p>使用Go channels</p>\n<p>3.死锁</p>\n<p>1）线程1等待线程2</p>\n<p>2）线程2等待线程1</p>\n<p>4.锁粒度</p>\n<p>1）粗粒度-&gt;实现简单，但是并发性能不好</p>\n<p>2）细粒度-&gt;更好的并发性能，更多的锁竞争(races)和死锁</p>\n<p>5.让我们来看labrpc 包里如何解决这些问题</p>\n<p>1）它类似于Go的RPC系统，但是网络是一个模拟网络</p>\n<ul>\n<li>网络延迟请求和响应</li>\n<li>网络丢包请求和响应</li>\n<li>网络的重发请求和响应</li>\n</ul>\n<p>2）说明 threads，mutexes，channels的用法</p>\n<p>3）使用Go实现了一个完整的RPC包</p>\n<p><strong>网络的结构</strong></p>\n<p>1.网络的描述</p>\n<p>1）服务器</p>\n<p>2）客户端</p>\n<p>2.每个网络都是互斥的</p>\n<p><strong>RPC概述</strong></p>\n<p>1.在test_test.go文件里面有很多例子</p>\n<p>2.应用调用RPC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reply := end.Call(&quot;Raft.AppendEntries&quot;, args, &amp;reply) //发出一个RPC请求，等待回复</span><br></pre></td></tr></table></figure>\n<p>3.服务端</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srv := MakeServer()</span><br><span class=\"line\">srv.AddService(svc) -- 一个服务器可以有多种服务</span><br></pre></td></tr></table></figure>\n<p>4.k/v</p>\n<p>将srv传递给 net.AddServer()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svc := MakeService(recevierPbject) -- obj&apos;s 方法会处理RPC请求</span><br></pre></td></tr></table></figure>\n<p>非常像Go的rpcs.Register()</p>\n<p>传递svc给 srv.AddService()</p>\n<p>5.服务器的数据结构</p>\n<p>1）AddService()</p>\n<p>添加一个服务名</p>\n<p>问题：为什么使用锁？</p>\n<p>问题：什么事defer()？</p>\n<p>2）Dispatch()</p>\n<p>分发一个请求到正确的服务</p>\n<p>问题：为什么持有锁？</p>\n<p>问题：为什么持有锁的范围互道函数的末尾？</p>\n<p>3）Call()</p>\n<p>使用反射查找参数的类型</p>\n<p>使用gob编码参数</p>\n<p>e.ch 是网络发送请求的通道</p>\n<p>使用一个通道来接收网络的回复（&lt;- req.replyCh）</p>\n<p>4）MakeEnd()</p>\n<p>有一个模拟网络的线程/goroutine</p>\n<p>从e.ch中读取并处理请求</p>\n<p>每个请求都在一个单独的goroutine中处理</p>\n<p>Q：一个endpoint 可以有很多未完成的请求吗</p>\n<p>Q：为什么使用rn.mu.Lock()？</p>\n<p>Q：锁保护了什么？</p>\n<p>5）ProcessReq()</p>\n<p>查找一个服务endpoint</p>\n<p>如果网络不可靠，可能会延迟或者丢失请求</p>\n<p>分发请求到一个新的线程</p>\n<p>通过读取ech中的数据等待服务端回复直到100ms过去</p>\n<p>100ms只是用来验证服务器是不是宕机了</p>\n<p>然后回复</p>\n<p>Q：谁将会读取回复？</p>\n<p>Q：如果ProcessReq不持有rn的锁可以吗？</p>\n<p>6）Service.dispatch()</p>\n<p>给请求找到一个处理的方法</p>\n<p>解码参数</p>\n<p>调用函数</p>\n<p>编码回复</p>\n<p>返回回复信息</p>\n<p>Go的内存模型需要显示同步才能进行通信</p>\n<p>下面代码是不正确的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x int</span><br><span class=\"line\">done := false</span><br><span class=\"line\">go func() &#123; x = f(...); done = true &#125;</span><br><span class=\"line\">while done == false &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个非常诱人的写法，但是Go会说这是为定义的</p>\n<p>使用通道或者sync.WaitGroup代替</p>\n<p><strong>学习Go的goroutines和channels</strong></p>\n<p><a href=\"https://golang.org/doc/articles/race_detector.html\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/articles/race_detector.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"基础设施-RPC-和-线程\"><a href=\"#基础设施-RPC-和-线程\" class=\"headerlink\" title=\"基础设施: RPC 和 线程\"></a>基础设施: RPC 和 线程</h4><p><strong>一个最常被问到的问题:为什么使用Go</strong></p>\n<p><strong><em>6.824这门课原先是使用C++的</em></strong></p>\n<p>学生花了很多时间去修与构建分布式系统无关的bug</p>\n<p>例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象</p>\n<p><strong><em>Go 语言可以让你更专注的处理分布式系统的问题</em></strong></p>\n<p>1.Go语言是类型安全的</p>\n<p>2.它有垃圾收集器（不会存在对象没有free导致的程序bug）</p>\n<p>3.对并发编程的支持很友好</p>\n<p>4.对RPC的支持很友好</p>\n<p><strong><em>我们喜欢用Go编程</em></strong></p>\n<p>1.Go很容易学习</p>\n<p>2.Go语言推荐资料 <a href=\"https://golang.org/doc/effective_go.html#generality\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/effective_go.html#generality</a></p>\n<p><strong>远程过程调用 (RPC)</strong></p>\n<p>1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写</p>\n<p>2.隐藏了客户端/服务器通信的大部分细节</p>\n<p>3.通过RPC客户端的远程调用就像普通的过程调用</p>\n<p>4.服务器的处理程序和普通的程序类似</p>\n<p>5.RPC被广泛使用</p>\n<p><strong>理想情况下，RPC使得网络通信看起来就像函数的调用</strong></p>\n<p>客户端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = fn(x, y)</span><br></pre></td></tr></table></figure>\n<p>服务器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn(x, y) &#123;</span><br><span class=\"line\">    compute</span><br><span class=\"line\">    return z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RPC旨在实现这种透明度的调用</p>\n<p>Go语言RPC的库 <a href=\"https://golang.org/pkg/net/rpc/\" target=\"_blank\" rel=\"noopener\">https://golang.org/pkg/net/rpc/</a></p>\n<p><strong>RPC 消息图</strong></p>\n<p>Client                Server</p>\n<p>request —&gt;</p>\n<p>​            &lt;— response</p>\n<p><strong>软件架构</strong></p>\n<p>客户端应用存根            处理调用</p>\n<p>RPC 库                    RPC库</p>\n<p>Net   ——————————   Net</p>\n<p><strong>更多的细节</strong></p>\n<p>1.要调用服务器的那个处理函数</p>\n<p>2.Marshalling（编组）：将数据格式化为数据包</p>\n<p>​    1）处理数组、指针和对象是很棘手的</p>\n<p>​    2）Go的RPC库是相当强大的</p>\n<p>​    3）有一些东西你不能传送：例如，channels（通道）,functions（函数）</p>\n<p>3.Binding（绑定）:客户端如何知道与谁交互?</p>\n<p>​       1）客户端被提供了服务器的主机名</p>\n<p>​       2）也许名称服务将服务映射到最佳的服务器主机</p>\n<p>4.线程：</p>\n<p>​    1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应</p>\n<p>​    2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序</p>\n<p><strong>RPC问题：如何处理失败</strong></p>\n<p>​    例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃</p>\n<p><strong>客户端RPC库中的故障是什么样的?</strong></p>\n<p>1.客户端从未收到服务器的响应</p>\n<p>2.客户端不知道服务器是否能看到请求</p>\n<p>3.可能服务器或者网络在发送回复之前失败了</p>\n<p><strong>最简单的方案：“至少一次”行为</strong></p>\n<p>1.RPC库等待响应一段时间</p>\n<p>2.如果没有响应到达，重新发送请求</p>\n<p>3.多次尝试</p>\n<p>4.仍然没有响应的话，向应用程序返回一个错误</p>\n<p>5.问题：应用程序容易处理至少一次的操作吗？</p>\n<p>​    至少一次：客户端发送“从银行账户中扣除5美元”</p>\n<p>6.问题：这个客户端程序有什么问题？</p>\n<p>​    put(“k”, 10) 通过RPC在数据库服务器中设置key的值    </p>\n<p>​    put(“k”, 20) 然后客户端执行第二次put操作到同一个key</p>\n<p>7.问题：至少一次总是OK的吗？</p>\n<p>​    1）重复操作是可以的，例如只读操作</p>\n<p>​    2）如果应用程序有自己对于写副本的执行计划</p>\n<p><strong>更好的PRC行为：“至多一次”</strong></p>\n<p>1.想法：服务器RPC代码检测重复请求</p>\n<p>2.返回上一个reply，而不是重新运行处理程序</p>\n<p><strong>如何检测重复的请求</strong></p>\n<p>1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">if seen[xid]:</span><br><span class=\"line\">\tr = old[xid]</span><br><span class=\"line\">else</span><br><span class=\"line\">\tr = handler()</span><br><span class=\"line\">\told[xid] = r</span><br><span class=\"line\">\tseen[xid] = true</span><br></pre></td></tr></table></figure>\n<p><strong>至多一次请求的复杂之处</strong></p>\n<p>1.这将在实验2和以后的实验中出现</p>\n<p>2.如何确保XID是唯一的？</p>\n<p>​    大的随机数？</p>\n<p>​    合并唯一客户端ID（IP地址？）有序列？</p>\n<p>​    服务器必须最终放弃优化旧的RPC的信息</p>\n<p>​    1）什么时候丢弃是安全的</p>\n<p>​    想法：</p>\n<p>​    唯一的客户端ID</p>\n<p>​    上一次客户端RPC请求的序列号</p>\n<p>​    客户端的每一个RPCC包含”seen all replies &lt;= X”</p>\n<p>​    像TCP的sequence号一样</p>\n<p>​    或者一次只允许一个客户端PRC</p>\n<p>​    当seq + 1到达允许服务器放弃所有的 &lt;= seq 的请求</p>\n<p>​    或者客户端同意小于5分钟的重试，5分钟后服务器放弃</p>\n<p>如何处理相同的请求当原来的请求仍然在执行？</p>\n<p>​    服务器不知道要回复，不想重复运行</p>\n<p>​    想法：给每个正在执行的RPC设置一个”pending” flag；等待或者忽略相同的请求</p>\n<p><strong>当一个 at-most-once 服务器宕机和重启怎么办？</strong></p>\n<p>1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求</p>\n<p>2.也许它应该吧重复的信息写到磁盘？</p>\n<p>3.也许副本服务器也应该复制重复的信息？</p>\n<p><strong>“一次就好”怎么样？</strong></p>\n<p>最多一次加上无限制的重试加上容错服务</p>\n<p><strong>Go的RPC是 “at-most-once”</strong></p>\n<p>1.打开TCP连接</p>\n<p>2.向TCP连接中写入请求</p>\n<p>3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求</p>\n<p>4.Go的代码里面没有重试</p>\n<p>5.Go RPC代码在没有得到回复的时候会返回一个error</p>\n<p>1）可能在一个TCP超时之后</p>\n<p>2）可能服务器没有看到请求</p>\n<p>3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败</p>\n<p><strong>Go RPC的 at-most-once 不足以应对Lab1</strong></p>\n<p>1.它只适用于单个RPC调用</p>\n<p>2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败</p>\n<p>3.Go的RPC不能检测出这种重复</p>\n<p>1）在lab1中没问题，它在应用层处理了</p>\n<p>2）Lab2需要明确的检测重复提交</p>\n<p><strong>线程</strong></p>\n<p>1.线程是一个基本的服务结构工具</p>\n<p>2.你将会在lab中广泛的使用它</p>\n<p>3.它们可能很棘手</p>\n<p>4.但是对PRC非常有用</p>\n<p>5.Go称它们为Goroutines，也有很多人称它们为线程</p>\n<p><strong>Thread = “Thread of control”</strong></p>\n<p>1.多线程允许程序逻辑上在同一时刻同时做很多事情</p>\n<p>2.线程共享内存</p>\n<p>3.线程之间共享程序计数器，寄存器，栈空间</p>\n<p><strong>多线程的一些挑战</strong></p>\n<p>1.共享数据</p>\n<p>1）两个线程如果同时修改了相同的变量会怎么样？</p>\n<p>2）一个线程正在读数据，另一个线程改变数据呢？</p>\n<p>3）需要保护共享数据上的不变量</p>\n<p>4）使用Go sync.Mutex锁</p>\n<p>2.线程之间的通过</p>\n<p>例如：等待所有的Map线程完成</p>\n<p>使用Go channels</p>\n<p>3.死锁</p>\n<p>1）线程1等待线程2</p>\n<p>2）线程2等待线程1</p>\n<p>4.锁粒度</p>\n<p>1）粗粒度-&gt;实现简单，但是并发性能不好</p>\n<p>2）细粒度-&gt;更好的并发性能，更多的锁竞争(races)和死锁</p>\n<p>5.让我们来看labrpc 包里如何解决这些问题</p>\n<p>1）它类似于Go的RPC系统，但是网络是一个模拟网络</p>\n<ul>\n<li>网络延迟请求和响应</li>\n<li>网络丢包请求和响应</li>\n<li>网络的重发请求和响应</li>\n</ul>\n<p>2）说明 threads，mutexes，channels的用法</p>\n<p>3）使用Go实现了一个完整的RPC包</p>\n<p><strong>网络的结构</strong></p>\n<p>1.网络的描述</p>\n<p>1）服务器</p>\n<p>2）客户端</p>\n<p>2.每个网络都是互斥的</p>\n<p><strong>RPC概述</strong></p>\n<p>1.在test_test.go文件里面有很多例子</p>\n<p>2.应用调用RPC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reply := end.Call(&quot;Raft.AppendEntries&quot;, args, &amp;reply) //发出一个RPC请求，等待回复</span><br></pre></td></tr></table></figure>\n<p>3.服务端</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srv := MakeServer()</span><br><span class=\"line\">srv.AddService(svc) -- 一个服务器可以有多种服务</span><br></pre></td></tr></table></figure>\n<p>4.k/v</p>\n<p>将srv传递给 net.AddServer()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svc := MakeService(recevierPbject) -- obj&apos;s 方法会处理RPC请求</span><br></pre></td></tr></table></figure>\n<p>非常像Go的rpcs.Register()</p>\n<p>传递svc给 srv.AddService()</p>\n<p>5.服务器的数据结构</p>\n<p>1）AddService()</p>\n<p>添加一个服务名</p>\n<p>问题：为什么使用锁？</p>\n<p>问题：什么事defer()？</p>\n<p>2）Dispatch()</p>\n<p>分发一个请求到正确的服务</p>\n<p>问题：为什么持有锁？</p>\n<p>问题：为什么持有锁的范围互道函数的末尾？</p>\n<p>3）Call()</p>\n<p>使用反射查找参数的类型</p>\n<p>使用gob编码参数</p>\n<p>e.ch 是网络发送请求的通道</p>\n<p>使用一个通道来接收网络的回复（&lt;- req.replyCh）</p>\n<p>4）MakeEnd()</p>\n<p>有一个模拟网络的线程/goroutine</p>\n<p>从e.ch中读取并处理请求</p>\n<p>每个请求都在一个单独的goroutine中处理</p>\n<p>Q：一个endpoint 可以有很多未完成的请求吗</p>\n<p>Q：为什么使用rn.mu.Lock()？</p>\n<p>Q：锁保护了什么？</p>\n<p>5）ProcessReq()</p>\n<p>查找一个服务endpoint</p>\n<p>如果网络不可靠，可能会延迟或者丢失请求</p>\n<p>分发请求到一个新的线程</p>\n<p>通过读取ech中的数据等待服务端回复直到100ms过去</p>\n<p>100ms只是用来验证服务器是不是宕机了</p>\n<p>然后回复</p>\n<p>Q：谁将会读取回复？</p>\n<p>Q：如果ProcessReq不持有rn的锁可以吗？</p>\n<p>6）Service.dispatch()</p>\n<p>给请求找到一个处理的方法</p>\n<p>解码参数</p>\n<p>调用函数</p>\n<p>编码回复</p>\n<p>返回回复信息</p>\n<p>Go的内存模型需要显示同步才能进行通信</p>\n<p>下面代码是不正确的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x int</span><br><span class=\"line\">done := false</span><br><span class=\"line\">go func() &#123; x = f(...); done = true &#125;</span><br><span class=\"line\">while done == false &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个非常诱人的写法，但是Go会说这是为定义的</p>\n<p>使用通道或者sync.WaitGroup代替</p>\n<p><strong>学习Go的goroutines和channels</strong></p>\n<p><a href=\"https://golang.org/doc/articles/race_detector.html\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/articles/race_detector.html</a></p>\n"},{"title":"LEC4-vedio","date":"2019-01-17T01:36:13.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC4-vedio.md","raw":"---\ntitle: LEC4-vedio\ndate: 2019-01-17 09:36:13\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC4-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nijc000p2yw3l43z674e","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC3","date":"2019-01-24T15:33:17.000Z","_content":"\n**谷歌文件系统(GFS)**\n\n**我们读这篇论文的目的**\n\n1.它是MapReduce操作的文件系统支持\n\n2.存储故障的案例研究\n\n- 交互一致性，实现简单性和性能\n- 后续设计的动机\n\n3.性能好--并行I/O性能好\n\n4.系统方面好的论文—从应用程序到网络的详细信息\n\n5.这篇论文展示了6.824这门课的所有主要主题\n\n- 性能、容错性、一致性\n\n**什么是一致性？**\n\n1.保证正确性的条件\n\n2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要\n\n- 如果应用程序执行写操作，那么后续的读操作会观察到什么？\n- 如果读取操作是来自一个不同的应用程序呢？\n\n3.弱一致性\n\nread（）操作可能返回过时的数据 --- 不是最近写入的结果\n\n4.强一致性\n\nread（）操作总是返回最新写入的数据\n\n5.权衡\n\n- 强一致对应用写入者是有好的\n- 强一致性对性能不友好\n\n6.许多正确性的条件（通常称为一致性模型）\n\n**一致性模型的历史**\n\n1.在体系结构，系统，数据库交互中被广泛使用。\n\n- 具有访问共享内存的专用缓存的并发处理器\n- 访问分布式文件系统的并发客户端\n- 分布式数据库上的并发事务\n\n2.许多不同的模型都有不同的权衡\n\n- 可串行化\n- 顺序一致性\n- 线性化\n- entry的一致性\n- 发布一致性\n\n3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中\n\n**理想的一致性模型**\n\n1.复制文件的行为类似于非复制的文件系统\n\n场景：同一台机器上有许多客户端访问单个磁盘上的文件\n\n2.如果一个应用程序写入，以后的读取会看到写入结果\n\n3.如果两个应用程序并发的写入一个文件会怎么样\n\n在文件系统值通常未定义—文件可能会写入混合乱序的内容\n\n4.如果两个应用程序并发的写入同一个文件夹\n\n```\nOne goes first, the other goes second\n```\n\n**导致不一致的来源**\n\n1.并发操作\n\n2.机器宕机\n\n3.网络分区\n\n**为什么这些想法在一个分布式文件中很难实现**\n\n1.协议会变得很复杂---很难正确的实现系统\n\n2.协议需要客户端和服务器之前的交互，会带来性能开销\n\n**GFS的设计者放弃了同时获得更好性能和简单设计的想法**\n\n1.会使得应用程序的开发者实现更加困难\n\n2.今天的论文主要讨论下面几个特性之间的权衡\n\n- 一致性\n- 容错性\n- 性能\n- 更简单的设计\n\n**GFS的目标**\n\n1.实现一个共享的文件系统\n\n2.成百上千的物理机（以Linux为基础）\n\n3.存储海量数据集\n\n**GFS存了什么？**\n\n1.作者没有实际的说明\n\n2.2003年的猜测\n\n- 搜索索引 & 数据库\n- web上所有的HTML文件\n- web上所有的图片\n\n**文件的属性**\n\n1.多兆字节的数据集\n\n2.很多文件是特别大的\n\n3.作者建议 1M文件 * 100MB = 100TB\n\n但是这是2003年的数据\n\n4.文件都是只追加存储的\n\n**主要挑战**\n\n1.很多机器故障是常见的\n\n假设一台机器每年宕机一次\n\n1000台机器，平均每天就有3台机器宕机\n\n2.高性能：很多并发的写者和读者\n\n- Map/Reduce 任务在GFS中读取和存储最终的结果\n- 注意：不是临时，中间的文件\n\n3.高效的利用网络\n\n**高层面的设计**\n\n1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的\n\n2.100多台带磁盘的块存储(chunk servers)服务器 \n\n- 存储64MB大小的文件块（每个块都是普通的linux文件）\n\n- 每个块存储三个副本在三台服务器上\n\n- 问题：为什么是3x的副本\n\n- 问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡\n\n- 问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？\n\n  是要对整个机器进行容错，而不仅仅是存储设备\n\n- 问题：为什么一个块那么大\n\n3.GFS的Master服务器知道目录的层次结构\n\n- 对于目录，里面存储了什么文件？\n\n- 对于文件，知道每一个64MB块所在的区块服务器\n\n- master将状态保存在内存中\n\n  每个块存储64B 的元数据信息\n\n- master上有元数据的专用可恢复数据库\n\n  master针对断电状况可以迅速的恢复\n\n- Shadow master会比master落后很多，但是可以被变成master\n\n**基本操作**\n\n1.客户端读取：\n\n- 发送文件名以及偏移量给master服务器\n- master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间\n- 请求最近的拥有改文件区块的服务器\n\n2.客户端写入：\n\n- 询问master在哪里存储这个数据\n- 当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储\n- 一个区块服务器是主\n- 它选择更新顺序并转发到两个备份\n\n**两种不同的容错方案**\n\n1.一种是针对master的\n\n2.一种是针对区块服务器的\n\n**针对Master的容错方案**\n\n1.单master\n\n- 客户端总是发请求给master\n- master掌控所有的操作\n\n2.持续存储限制的信息(Stores limited information persistently)\n\n- 名称空间（文件目录）\n- file到chunk的映射\n\n3.在日志中记录对这两项的更改\n\n- 在多个备份机器上复制日志\n- 客户端对状态的在记录写到log中才返回\n- 在后续要读到的很多系统中，log扮演者一个中心角色\n- logs扮演这中心角色在后续的实验中\n\n4.限制log文件的大小\n\n- 给master的状态打一个checkpoint（快照）\n- 移除在checkpoint之前的所有操作日志\n- 将checkpoint复制到备份中\n\n5.恢复\n\n- 从最后一个checkpoint恢复日志\n- 通过询问区块服务器来重新创建区块的位置信息\n\n6.Master是有单点故障风险的\n\n- 恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用\n\n- Shadow master\n\n  落后于master，它们从复制的日志中重播来恢复\n\n  服务器进行只读操作，但是可能返回过时的数据\n\n- 如果master无法恢复，从别处启动master一定要非常小心来避免两个master\n\n- 我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到\n\n**区块的容错性**\n\n1.Master向其中一个副本授予一个租约，这个租约是主区块服务器\n\n2.主决定所有操作\n\n3.客户端将数据推送至副本\n\n- 副本形成一个链\n- 这个链考虑的网络拓扑\n- 允许快速的复制\n\n4.客户端发送写请求到主服务器\n\n- 主分配序列号\n- 主在本地应用更改\n- 主转发请求到副本服务器\n- 主在收到所有副本服务器的请求响应后返回响应客户端\n\n5.如果一个副本没有响应，客户端将重试\n\n6.如果副本数量降到某个数字以下后，则主会重新复制区块\n\n7.主重新平衡副本\n\n**区块的一致性**\n\n1.一些区块可能会过时，它们错过的系统变化的操作\n\n2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器\n\n3.master和区块服务器持久化存储这个版本信息\n\n4.区块的版本信息也会发送给客户端\n\n5.版本号允许master和客户端检测过时数据\n\n**并发写/追加**\n\n1.客户端将并发的写文件的同一Region\n\n2.写入的结果是混合这些写入的--没有保证顺序\n\n- 很少有应用这样做，所以是没问题的\n- UNIX上的并发写入也会导致奇怪的结果\n\n3.许多客户端可能想要并发的追加一个日志文件\n\n- GFS支持原子操作\n- 主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器\n- 如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。\n- 客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）\n- 文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界\n\n**一致性模型**\n\n1.对于文件目录的操作是强一致的\n\n- master对元数据的操作是原子性的\n- 目录的操作遵循下面的想法\n  - 当master伟offline状态时，只有shadow master\n  - 只允许读操作，将有可能返回过期的数据\n\n2.区块的操作是弱一致性的\n\n- 一个失败的操作会导致区块的不一致\n\n  主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的\n\n- 客户端读到的可能不是最新的区块数据\n\n- 当客户端刷新租凭(lease)时，它将了解到新的版本号\n\n3.作者声称弱一致性对于应用来说不是大问题\n\n- 大部分的文件更新操作都是追加的\n- 应用程序可以再附加记录中使用UID来检查重复项\n- 应用程序可能只是读取较少的数据（但不是陈旧的数据）\n- 应用程序可以使用临时文件，或者原子的执行重命名操作\n\n**性能**\n\n1.读取有巨大的吞吐量（3副本）\n\n- 总计125MB/秒\n- 网络链路饱和\n\n2.写入不同文件的次数可能低于最大值\n\n- 作者吐槽了他们的网络栈\n- 网络失效导致了从一个副本传播到下一个副本中间有延迟\n\n3.并发的追加单个文件\n\n受限于存储最后一个区块的服务器\n\n**总结**\n\n1.GFS使用的重要FT技术\n\n- 日志&还原点(checkpoint)\n- 区块的主备复制，但保持一致性\n\n2.GFS优势\n\n- 大量顺序的读和写，追加\n- 大的吞吐量\n- 数据的容灾\n\n3.GFS缺点\n\n- master的容灾\n- 小文件的读写\n- 多个客户端并发的更新同一个文件","source":"_posts/LEC3.md","raw":"---\ntitle: LEC3\ndate: 2019-01-24 23:33:17\ntags: 分布式系统6.824笔记\n---\n\n**谷歌文件系统(GFS)**\n\n**我们读这篇论文的目的**\n\n1.它是MapReduce操作的文件系统支持\n\n2.存储故障的案例研究\n\n- 交互一致性，实现简单性和性能\n- 后续设计的动机\n\n3.性能好--并行I/O性能好\n\n4.系统方面好的论文—从应用程序到网络的详细信息\n\n5.这篇论文展示了6.824这门课的所有主要主题\n\n- 性能、容错性、一致性\n\n**什么是一致性？**\n\n1.保证正确性的条件\n\n2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要\n\n- 如果应用程序执行写操作，那么后续的读操作会观察到什么？\n- 如果读取操作是来自一个不同的应用程序呢？\n\n3.弱一致性\n\nread（）操作可能返回过时的数据 --- 不是最近写入的结果\n\n4.强一致性\n\nread（）操作总是返回最新写入的数据\n\n5.权衡\n\n- 强一致对应用写入者是有好的\n- 强一致性对性能不友好\n\n6.许多正确性的条件（通常称为一致性模型）\n\n**一致性模型的历史**\n\n1.在体系结构，系统，数据库交互中被广泛使用。\n\n- 具有访问共享内存的专用缓存的并发处理器\n- 访问分布式文件系统的并发客户端\n- 分布式数据库上的并发事务\n\n2.许多不同的模型都有不同的权衡\n\n- 可串行化\n- 顺序一致性\n- 线性化\n- entry的一致性\n- 发布一致性\n\n3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中\n\n**理想的一致性模型**\n\n1.复制文件的行为类似于非复制的文件系统\n\n场景：同一台机器上有许多客户端访问单个磁盘上的文件\n\n2.如果一个应用程序写入，以后的读取会看到写入结果\n\n3.如果两个应用程序并发的写入一个文件会怎么样\n\n在文件系统值通常未定义—文件可能会写入混合乱序的内容\n\n4.如果两个应用程序并发的写入同一个文件夹\n\n```\nOne goes first, the other goes second\n```\n\n**导致不一致的来源**\n\n1.并发操作\n\n2.机器宕机\n\n3.网络分区\n\n**为什么这些想法在一个分布式文件中很难实现**\n\n1.协议会变得很复杂---很难正确的实现系统\n\n2.协议需要客户端和服务器之前的交互，会带来性能开销\n\n**GFS的设计者放弃了同时获得更好性能和简单设计的想法**\n\n1.会使得应用程序的开发者实现更加困难\n\n2.今天的论文主要讨论下面几个特性之间的权衡\n\n- 一致性\n- 容错性\n- 性能\n- 更简单的设计\n\n**GFS的目标**\n\n1.实现一个共享的文件系统\n\n2.成百上千的物理机（以Linux为基础）\n\n3.存储海量数据集\n\n**GFS存了什么？**\n\n1.作者没有实际的说明\n\n2.2003年的猜测\n\n- 搜索索引 & 数据库\n- web上所有的HTML文件\n- web上所有的图片\n\n**文件的属性**\n\n1.多兆字节的数据集\n\n2.很多文件是特别大的\n\n3.作者建议 1M文件 * 100MB = 100TB\n\n但是这是2003年的数据\n\n4.文件都是只追加存储的\n\n**主要挑战**\n\n1.很多机器故障是常见的\n\n假设一台机器每年宕机一次\n\n1000台机器，平均每天就有3台机器宕机\n\n2.高性能：很多并发的写者和读者\n\n- Map/Reduce 任务在GFS中读取和存储最终的结果\n- 注意：不是临时，中间的文件\n\n3.高效的利用网络\n\n**高层面的设计**\n\n1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的\n\n2.100多台带磁盘的块存储(chunk servers)服务器 \n\n- 存储64MB大小的文件块（每个块都是普通的linux文件）\n\n- 每个块存储三个副本在三台服务器上\n\n- 问题：为什么是3x的副本\n\n- 问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡\n\n- 问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？\n\n  是要对整个机器进行容错，而不仅仅是存储设备\n\n- 问题：为什么一个块那么大\n\n3.GFS的Master服务器知道目录的层次结构\n\n- 对于目录，里面存储了什么文件？\n\n- 对于文件，知道每一个64MB块所在的区块服务器\n\n- master将状态保存在内存中\n\n  每个块存储64B 的元数据信息\n\n- master上有元数据的专用可恢复数据库\n\n  master针对断电状况可以迅速的恢复\n\n- Shadow master会比master落后很多，但是可以被变成master\n\n**基本操作**\n\n1.客户端读取：\n\n- 发送文件名以及偏移量给master服务器\n- master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间\n- 请求最近的拥有改文件区块的服务器\n\n2.客户端写入：\n\n- 询问master在哪里存储这个数据\n- 当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储\n- 一个区块服务器是主\n- 它选择更新顺序并转发到两个备份\n\n**两种不同的容错方案**\n\n1.一种是针对master的\n\n2.一种是针对区块服务器的\n\n**针对Master的容错方案**\n\n1.单master\n\n- 客户端总是发请求给master\n- master掌控所有的操作\n\n2.持续存储限制的信息(Stores limited information persistently)\n\n- 名称空间（文件目录）\n- file到chunk的映射\n\n3.在日志中记录对这两项的更改\n\n- 在多个备份机器上复制日志\n- 客户端对状态的在记录写到log中才返回\n- 在后续要读到的很多系统中，log扮演者一个中心角色\n- logs扮演这中心角色在后续的实验中\n\n4.限制log文件的大小\n\n- 给master的状态打一个checkpoint（快照）\n- 移除在checkpoint之前的所有操作日志\n- 将checkpoint复制到备份中\n\n5.恢复\n\n- 从最后一个checkpoint恢复日志\n- 通过询问区块服务器来重新创建区块的位置信息\n\n6.Master是有单点故障风险的\n\n- 恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用\n\n- Shadow master\n\n  落后于master，它们从复制的日志中重播来恢复\n\n  服务器进行只读操作，但是可能返回过时的数据\n\n- 如果master无法恢复，从别处启动master一定要非常小心来避免两个master\n\n- 我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到\n\n**区块的容错性**\n\n1.Master向其中一个副本授予一个租约，这个租约是主区块服务器\n\n2.主决定所有操作\n\n3.客户端将数据推送至副本\n\n- 副本形成一个链\n- 这个链考虑的网络拓扑\n- 允许快速的复制\n\n4.客户端发送写请求到主服务器\n\n- 主分配序列号\n- 主在本地应用更改\n- 主转发请求到副本服务器\n- 主在收到所有副本服务器的请求响应后返回响应客户端\n\n5.如果一个副本没有响应，客户端将重试\n\n6.如果副本数量降到某个数字以下后，则主会重新复制区块\n\n7.主重新平衡副本\n\n**区块的一致性**\n\n1.一些区块可能会过时，它们错过的系统变化的操作\n\n2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器\n\n3.master和区块服务器持久化存储这个版本信息\n\n4.区块的版本信息也会发送给客户端\n\n5.版本号允许master和客户端检测过时数据\n\n**并发写/追加**\n\n1.客户端将并发的写文件的同一Region\n\n2.写入的结果是混合这些写入的--没有保证顺序\n\n- 很少有应用这样做，所以是没问题的\n- UNIX上的并发写入也会导致奇怪的结果\n\n3.许多客户端可能想要并发的追加一个日志文件\n\n- GFS支持原子操作\n- 主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器\n- 如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。\n- 客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）\n- 文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界\n\n**一致性模型**\n\n1.对于文件目录的操作是强一致的\n\n- master对元数据的操作是原子性的\n- 目录的操作遵循下面的想法\n  - 当master伟offline状态时，只有shadow master\n  - 只允许读操作，将有可能返回过期的数据\n\n2.区块的操作是弱一致性的\n\n- 一个失败的操作会导致区块的不一致\n\n  主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的\n\n- 客户端读到的可能不是最新的区块数据\n\n- 当客户端刷新租凭(lease)时，它将了解到新的版本号\n\n3.作者声称弱一致性对于应用来说不是大问题\n\n- 大部分的文件更新操作都是追加的\n- 应用程序可以再附加记录中使用UID来检查重复项\n- 应用程序可能只是读取较少的数据（但不是陈旧的数据）\n- 应用程序可以使用临时文件，或者原子的执行重命名操作\n\n**性能**\n\n1.读取有巨大的吞吐量（3副本）\n\n- 总计125MB/秒\n- 网络链路饱和\n\n2.写入不同文件的次数可能低于最大值\n\n- 作者吐槽了他们的网络栈\n- 网络失效导致了从一个副本传播到下一个副本中间有延迟\n\n3.并发的追加单个文件\n\n受限于存储最后一个区块的服务器\n\n**总结**\n\n1.GFS使用的重要FT技术\n\n- 日志&还原点(checkpoint)\n- 区块的主备复制，但保持一致性\n\n2.GFS优势\n\n- 大量顺序的读和写，追加\n- 大的吞吐量\n- 数据的容灾\n\n3.GFS缺点\n\n- master的容灾\n- 小文件的读写\n- 多个客户端并发的更新同一个文件","slug":"LEC3","published":1,"updated":"2019-01-28T05:18:03.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nijd000r2yw3mr51cd6x","content":"<p><strong>谷歌文件系统(GFS)</strong></p>\n<p><strong>我们读这篇论文的目的</strong></p>\n<p>1.它是MapReduce操作的文件系统支持</p>\n<p>2.存储故障的案例研究</p>\n<ul>\n<li>交互一致性，实现简单性和性能</li>\n<li>后续设计的动机</li>\n</ul>\n<p>3.性能好–并行I/O性能好</p>\n<p>4.系统方面好的论文—从应用程序到网络的详细信息</p>\n<p>5.这篇论文展示了6.824这门课的所有主要主题</p>\n<ul>\n<li>性能、容错性、一致性</li>\n</ul>\n<p><strong>什么是一致性？</strong></p>\n<p>1.保证正确性的条件</p>\n<p>2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要</p>\n<ul>\n<li>如果应用程序执行写操作，那么后续的读操作会观察到什么？</li>\n<li>如果读取操作是来自一个不同的应用程序呢？</li>\n</ul>\n<p>3.弱一致性</p>\n<p>read（）操作可能返回过时的数据 — 不是最近写入的结果</p>\n<p>4.强一致性</p>\n<p>read（）操作总是返回最新写入的数据</p>\n<p>5.权衡</p>\n<ul>\n<li>强一致对应用写入者是有好的</li>\n<li>强一致性对性能不友好</li>\n</ul>\n<p>6.许多正确性的条件（通常称为一致性模型）</p>\n<p><strong>一致性模型的历史</strong></p>\n<p>1.在体系结构，系统，数据库交互中被广泛使用。</p>\n<ul>\n<li>具有访问共享内存的专用缓存的并发处理器</li>\n<li>访问分布式文件系统的并发客户端</li>\n<li>分布式数据库上的并发事务</li>\n</ul>\n<p>2.许多不同的模型都有不同的权衡</p>\n<ul>\n<li>可串行化</li>\n<li>顺序一致性</li>\n<li>线性化</li>\n<li>entry的一致性</li>\n<li>发布一致性</li>\n</ul>\n<p>3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中</p>\n<p><strong>理想的一致性模型</strong></p>\n<p>1.复制文件的行为类似于非复制的文件系统</p>\n<p>场景：同一台机器上有许多客户端访问单个磁盘上的文件</p>\n<p>2.如果一个应用程序写入，以后的读取会看到写入结果</p>\n<p>3.如果两个应用程序并发的写入一个文件会怎么样</p>\n<p>在文件系统值通常未定义—文件可能会写入混合乱序的内容</p>\n<p>4.如果两个应用程序并发的写入同一个文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">One goes first, the other goes second</span><br></pre></td></tr></table></figure>\n<p><strong>导致不一致的来源</strong></p>\n<p>1.并发操作</p>\n<p>2.机器宕机</p>\n<p>3.网络分区</p>\n<p><strong>为什么这些想法在一个分布式文件中很难实现</strong></p>\n<p>1.协议会变得很复杂—很难正确的实现系统</p>\n<p>2.协议需要客户端和服务器之前的交互，会带来性能开销</p>\n<p><strong>GFS的设计者放弃了同时获得更好性能和简单设计的想法</strong></p>\n<p>1.会使得应用程序的开发者实现更加困难</p>\n<p>2.今天的论文主要讨论下面几个特性之间的权衡</p>\n<ul>\n<li>一致性</li>\n<li>容错性</li>\n<li>性能</li>\n<li>更简单的设计</li>\n</ul>\n<p><strong>GFS的目标</strong></p>\n<p>1.实现一个共享的文件系统</p>\n<p>2.成百上千的物理机（以Linux为基础）</p>\n<p>3.存储海量数据集</p>\n<p><strong>GFS存了什么？</strong></p>\n<p>1.作者没有实际的说明</p>\n<p>2.2003年的猜测</p>\n<ul>\n<li>搜索索引 &amp; 数据库</li>\n<li>web上所有的HTML文件</li>\n<li>web上所有的图片</li>\n</ul>\n<p><strong>文件的属性</strong></p>\n<p>1.多兆字节的数据集</p>\n<p>2.很多文件是特别大的</p>\n<p>3.作者建议 1M文件 * 100MB = 100TB</p>\n<p>但是这是2003年的数据</p>\n<p>4.文件都是只追加存储的</p>\n<p><strong>主要挑战</strong></p>\n<p>1.很多机器故障是常见的</p>\n<p>假设一台机器每年宕机一次</p>\n<p>1000台机器，平均每天就有3台机器宕机</p>\n<p>2.高性能：很多并发的写者和读者</p>\n<ul>\n<li>Map/Reduce 任务在GFS中读取和存储最终的结果</li>\n<li>注意：不是临时，中间的文件</li>\n</ul>\n<p>3.高效的利用网络</p>\n<p><strong>高层面的设计</strong></p>\n<p>1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的</p>\n<p>2.100多台带磁盘的块存储(chunk servers)服务器 </p>\n<ul>\n<li><p>存储64MB大小的文件块（每个块都是普通的linux文件）</p>\n</li>\n<li><p>每个块存储三个副本在三台服务器上</p>\n</li>\n<li><p>问题：为什么是3x的副本</p>\n</li>\n<li><p>问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡</p>\n</li>\n<li><p>问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？</p>\n<p>是要对整个机器进行容错，而不仅仅是存储设备</p>\n</li>\n<li><p>问题：为什么一个块那么大</p>\n</li>\n</ul>\n<p>3.GFS的Master服务器知道目录的层次结构</p>\n<ul>\n<li><p>对于目录，里面存储了什么文件？</p>\n</li>\n<li><p>对于文件，知道每一个64MB块所在的区块服务器</p>\n</li>\n<li><p>master将状态保存在内存中</p>\n<p>每个块存储64B 的元数据信息</p>\n</li>\n<li><p>master上有元数据的专用可恢复数据库</p>\n<p>master针对断电状况可以迅速的恢复</p>\n</li>\n<li><p>Shadow master会比master落后很多，但是可以被变成master</p>\n</li>\n</ul>\n<p><strong>基本操作</strong></p>\n<p>1.客户端读取：</p>\n<ul>\n<li>发送文件名以及偏移量给master服务器</li>\n<li>master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间</li>\n<li>请求最近的拥有改文件区块的服务器</li>\n</ul>\n<p>2.客户端写入：</p>\n<ul>\n<li>询问master在哪里存储这个数据</li>\n<li>当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储</li>\n<li>一个区块服务器是主</li>\n<li>它选择更新顺序并转发到两个备份</li>\n</ul>\n<p><strong>两种不同的容错方案</strong></p>\n<p>1.一种是针对master的</p>\n<p>2.一种是针对区块服务器的</p>\n<p><strong>针对Master的容错方案</strong></p>\n<p>1.单master</p>\n<ul>\n<li>客户端总是发请求给master</li>\n<li>master掌控所有的操作</li>\n</ul>\n<p>2.持续存储限制的信息(Stores limited information persistently)</p>\n<ul>\n<li>名称空间（文件目录）</li>\n<li>file到chunk的映射</li>\n</ul>\n<p>3.在日志中记录对这两项的更改</p>\n<ul>\n<li>在多个备份机器上复制日志</li>\n<li>客户端对状态的在记录写到log中才返回</li>\n<li>在后续要读到的很多系统中，log扮演者一个中心角色</li>\n<li>logs扮演这中心角色在后续的实验中</li>\n</ul>\n<p>4.限制log文件的大小</p>\n<ul>\n<li>给master的状态打一个checkpoint（快照）</li>\n<li>移除在checkpoint之前的所有操作日志</li>\n<li>将checkpoint复制到备份中</li>\n</ul>\n<p>5.恢复</p>\n<ul>\n<li>从最后一个checkpoint恢复日志</li>\n<li>通过询问区块服务器来重新创建区块的位置信息</li>\n</ul>\n<p>6.Master是有单点故障风险的</p>\n<ul>\n<li><p>恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用</p>\n</li>\n<li><p>Shadow master</p>\n<p>落后于master，它们从复制的日志中重播来恢复</p>\n<p>服务器进行只读操作，但是可能返回过时的数据</p>\n</li>\n<li><p>如果master无法恢复，从别处启动master一定要非常小心来避免两个master</p>\n</li>\n<li><p>我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到</p>\n</li>\n</ul>\n<p><strong>区块的容错性</strong></p>\n<p>1.Master向其中一个副本授予一个租约，这个租约是主区块服务器</p>\n<p>2.主决定所有操作</p>\n<p>3.客户端将数据推送至副本</p>\n<ul>\n<li>副本形成一个链</li>\n<li>这个链考虑的网络拓扑</li>\n<li>允许快速的复制</li>\n</ul>\n<p>4.客户端发送写请求到主服务器</p>\n<ul>\n<li>主分配序列号</li>\n<li>主在本地应用更改</li>\n<li>主转发请求到副本服务器</li>\n<li>主在收到所有副本服务器的请求响应后返回响应客户端</li>\n</ul>\n<p>5.如果一个副本没有响应，客户端将重试</p>\n<p>6.如果副本数量降到某个数字以下后，则主会重新复制区块</p>\n<p>7.主重新平衡副本</p>\n<p><strong>区块的一致性</strong></p>\n<p>1.一些区块可能会过时，它们错过的系统变化的操作</p>\n<p>2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器</p>\n<p>3.master和区块服务器持久化存储这个版本信息</p>\n<p>4.区块的版本信息也会发送给客户端</p>\n<p>5.版本号允许master和客户端检测过时数据</p>\n<p><strong>并发写/追加</strong></p>\n<p>1.客户端将并发的写文件的同一Region</p>\n<p>2.写入的结果是混合这些写入的–没有保证顺序</p>\n<ul>\n<li>很少有应用这样做，所以是没问题的</li>\n<li>UNIX上的并发写入也会导致奇怪的结果</li>\n</ul>\n<p>3.许多客户端可能想要并发的追加一个日志文件</p>\n<ul>\n<li>GFS支持原子操作</li>\n<li>主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器</li>\n<li>如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。</li>\n<li>客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）</li>\n<li>文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界</li>\n</ul>\n<p><strong>一致性模型</strong></p>\n<p>1.对于文件目录的操作是强一致的</p>\n<ul>\n<li>master对元数据的操作是原子性的</li>\n<li>目录的操作遵循下面的想法<ul>\n<li>当master伟offline状态时，只有shadow master</li>\n<li>只允许读操作，将有可能返回过期的数据</li>\n</ul>\n</li>\n</ul>\n<p>2.区块的操作是弱一致性的</p>\n<ul>\n<li><p>一个失败的操作会导致区块的不一致</p>\n<p>主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的</p>\n</li>\n<li><p>客户端读到的可能不是最新的区块数据</p>\n</li>\n<li><p>当客户端刷新租凭(lease)时，它将了解到新的版本号</p>\n</li>\n</ul>\n<p>3.作者声称弱一致性对于应用来说不是大问题</p>\n<ul>\n<li>大部分的文件更新操作都是追加的</li>\n<li>应用程序可以再附加记录中使用UID来检查重复项</li>\n<li>应用程序可能只是读取较少的数据（但不是陈旧的数据）</li>\n<li>应用程序可以使用临时文件，或者原子的执行重命名操作</li>\n</ul>\n<p><strong>性能</strong></p>\n<p>1.读取有巨大的吞吐量（3副本）</p>\n<ul>\n<li>总计125MB/秒</li>\n<li>网络链路饱和</li>\n</ul>\n<p>2.写入不同文件的次数可能低于最大值</p>\n<ul>\n<li>作者吐槽了他们的网络栈</li>\n<li>网络失效导致了从一个副本传播到下一个副本中间有延迟</li>\n</ul>\n<p>3.并发的追加单个文件</p>\n<p>受限于存储最后一个区块的服务器</p>\n<p><strong>总结</strong></p>\n<p>1.GFS使用的重要FT技术</p>\n<ul>\n<li>日志&amp;还原点(checkpoint)</li>\n<li>区块的主备复制，但保持一致性</li>\n</ul>\n<p>2.GFS优势</p>\n<ul>\n<li>大量顺序的读和写，追加</li>\n<li>大的吞吐量</li>\n<li>数据的容灾</li>\n</ul>\n<p>3.GFS缺点</p>\n<ul>\n<li>master的容灾</li>\n<li>小文件的读写</li>\n<li>多个客户端并发的更新同一个文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>谷歌文件系统(GFS)</strong></p>\n<p><strong>我们读这篇论文的目的</strong></p>\n<p>1.它是MapReduce操作的文件系统支持</p>\n<p>2.存储故障的案例研究</p>\n<ul>\n<li>交互一致性，实现简单性和性能</li>\n<li>后续设计的动机</li>\n</ul>\n<p>3.性能好–并行I/O性能好</p>\n<p>4.系统方面好的论文—从应用程序到网络的详细信息</p>\n<p>5.这篇论文展示了6.824这门课的所有主要主题</p>\n<ul>\n<li>性能、容错性、一致性</li>\n</ul>\n<p><strong>什么是一致性？</strong></p>\n<p>1.保证正确性的条件</p>\n<p>2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要</p>\n<ul>\n<li>如果应用程序执行写操作，那么后续的读操作会观察到什么？</li>\n<li>如果读取操作是来自一个不同的应用程序呢？</li>\n</ul>\n<p>3.弱一致性</p>\n<p>read（）操作可能返回过时的数据 — 不是最近写入的结果</p>\n<p>4.强一致性</p>\n<p>read（）操作总是返回最新写入的数据</p>\n<p>5.权衡</p>\n<ul>\n<li>强一致对应用写入者是有好的</li>\n<li>强一致性对性能不友好</li>\n</ul>\n<p>6.许多正确性的条件（通常称为一致性模型）</p>\n<p><strong>一致性模型的历史</strong></p>\n<p>1.在体系结构，系统，数据库交互中被广泛使用。</p>\n<ul>\n<li>具有访问共享内存的专用缓存的并发处理器</li>\n<li>访问分布式文件系统的并发客户端</li>\n<li>分布式数据库上的并发事务</li>\n</ul>\n<p>2.许多不同的模型都有不同的权衡</p>\n<ul>\n<li>可串行化</li>\n<li>顺序一致性</li>\n<li>线性化</li>\n<li>entry的一致性</li>\n<li>发布一致性</li>\n</ul>\n<p>3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中</p>\n<p><strong>理想的一致性模型</strong></p>\n<p>1.复制文件的行为类似于非复制的文件系统</p>\n<p>场景：同一台机器上有许多客户端访问单个磁盘上的文件</p>\n<p>2.如果一个应用程序写入，以后的读取会看到写入结果</p>\n<p>3.如果两个应用程序并发的写入一个文件会怎么样</p>\n<p>在文件系统值通常未定义—文件可能会写入混合乱序的内容</p>\n<p>4.如果两个应用程序并发的写入同一个文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">One goes first, the other goes second</span><br></pre></td></tr></table></figure>\n<p><strong>导致不一致的来源</strong></p>\n<p>1.并发操作</p>\n<p>2.机器宕机</p>\n<p>3.网络分区</p>\n<p><strong>为什么这些想法在一个分布式文件中很难实现</strong></p>\n<p>1.协议会变得很复杂—很难正确的实现系统</p>\n<p>2.协议需要客户端和服务器之前的交互，会带来性能开销</p>\n<p><strong>GFS的设计者放弃了同时获得更好性能和简单设计的想法</strong></p>\n<p>1.会使得应用程序的开发者实现更加困难</p>\n<p>2.今天的论文主要讨论下面几个特性之间的权衡</p>\n<ul>\n<li>一致性</li>\n<li>容错性</li>\n<li>性能</li>\n<li>更简单的设计</li>\n</ul>\n<p><strong>GFS的目标</strong></p>\n<p>1.实现一个共享的文件系统</p>\n<p>2.成百上千的物理机（以Linux为基础）</p>\n<p>3.存储海量数据集</p>\n<p><strong>GFS存了什么？</strong></p>\n<p>1.作者没有实际的说明</p>\n<p>2.2003年的猜测</p>\n<ul>\n<li>搜索索引 &amp; 数据库</li>\n<li>web上所有的HTML文件</li>\n<li>web上所有的图片</li>\n</ul>\n<p><strong>文件的属性</strong></p>\n<p>1.多兆字节的数据集</p>\n<p>2.很多文件是特别大的</p>\n<p>3.作者建议 1M文件 * 100MB = 100TB</p>\n<p>但是这是2003年的数据</p>\n<p>4.文件都是只追加存储的</p>\n<p><strong>主要挑战</strong></p>\n<p>1.很多机器故障是常见的</p>\n<p>假设一台机器每年宕机一次</p>\n<p>1000台机器，平均每天就有3台机器宕机</p>\n<p>2.高性能：很多并发的写者和读者</p>\n<ul>\n<li>Map/Reduce 任务在GFS中读取和存储最终的结果</li>\n<li>注意：不是临时，中间的文件</li>\n</ul>\n<p>3.高效的利用网络</p>\n<p><strong>高层面的设计</strong></p>\n<p>1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的</p>\n<p>2.100多台带磁盘的块存储(chunk servers)服务器 </p>\n<ul>\n<li><p>存储64MB大小的文件块（每个块都是普通的linux文件）</p>\n</li>\n<li><p>每个块存储三个副本在三台服务器上</p>\n</li>\n<li><p>问题：为什么是3x的副本</p>\n</li>\n<li><p>问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡</p>\n</li>\n<li><p>问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？</p>\n<p>是要对整个机器进行容错，而不仅仅是存储设备</p>\n</li>\n<li><p>问题：为什么一个块那么大</p>\n</li>\n</ul>\n<p>3.GFS的Master服务器知道目录的层次结构</p>\n<ul>\n<li><p>对于目录，里面存储了什么文件？</p>\n</li>\n<li><p>对于文件，知道每一个64MB块所在的区块服务器</p>\n</li>\n<li><p>master将状态保存在内存中</p>\n<p>每个块存储64B 的元数据信息</p>\n</li>\n<li><p>master上有元数据的专用可恢复数据库</p>\n<p>master针对断电状况可以迅速的恢复</p>\n</li>\n<li><p>Shadow master会比master落后很多，但是可以被变成master</p>\n</li>\n</ul>\n<p><strong>基本操作</strong></p>\n<p>1.客户端读取：</p>\n<ul>\n<li>发送文件名以及偏移量给master服务器</li>\n<li>master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间</li>\n<li>请求最近的拥有改文件区块的服务器</li>\n</ul>\n<p>2.客户端写入：</p>\n<ul>\n<li>询问master在哪里存储这个数据</li>\n<li>当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储</li>\n<li>一个区块服务器是主</li>\n<li>它选择更新顺序并转发到两个备份</li>\n</ul>\n<p><strong>两种不同的容错方案</strong></p>\n<p>1.一种是针对master的</p>\n<p>2.一种是针对区块服务器的</p>\n<p><strong>针对Master的容错方案</strong></p>\n<p>1.单master</p>\n<ul>\n<li>客户端总是发请求给master</li>\n<li>master掌控所有的操作</li>\n</ul>\n<p>2.持续存储限制的信息(Stores limited information persistently)</p>\n<ul>\n<li>名称空间（文件目录）</li>\n<li>file到chunk的映射</li>\n</ul>\n<p>3.在日志中记录对这两项的更改</p>\n<ul>\n<li>在多个备份机器上复制日志</li>\n<li>客户端对状态的在记录写到log中才返回</li>\n<li>在后续要读到的很多系统中，log扮演者一个中心角色</li>\n<li>logs扮演这中心角色在后续的实验中</li>\n</ul>\n<p>4.限制log文件的大小</p>\n<ul>\n<li>给master的状态打一个checkpoint（快照）</li>\n<li>移除在checkpoint之前的所有操作日志</li>\n<li>将checkpoint复制到备份中</li>\n</ul>\n<p>5.恢复</p>\n<ul>\n<li>从最后一个checkpoint恢复日志</li>\n<li>通过询问区块服务器来重新创建区块的位置信息</li>\n</ul>\n<p>6.Master是有单点故障风险的</p>\n<ul>\n<li><p>恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用</p>\n</li>\n<li><p>Shadow master</p>\n<p>落后于master，它们从复制的日志中重播来恢复</p>\n<p>服务器进行只读操作，但是可能返回过时的数据</p>\n</li>\n<li><p>如果master无法恢复，从别处启动master一定要非常小心来避免两个master</p>\n</li>\n<li><p>我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到</p>\n</li>\n</ul>\n<p><strong>区块的容错性</strong></p>\n<p>1.Master向其中一个副本授予一个租约，这个租约是主区块服务器</p>\n<p>2.主决定所有操作</p>\n<p>3.客户端将数据推送至副本</p>\n<ul>\n<li>副本形成一个链</li>\n<li>这个链考虑的网络拓扑</li>\n<li>允许快速的复制</li>\n</ul>\n<p>4.客户端发送写请求到主服务器</p>\n<ul>\n<li>主分配序列号</li>\n<li>主在本地应用更改</li>\n<li>主转发请求到副本服务器</li>\n<li>主在收到所有副本服务器的请求响应后返回响应客户端</li>\n</ul>\n<p>5.如果一个副本没有响应，客户端将重试</p>\n<p>6.如果副本数量降到某个数字以下后，则主会重新复制区块</p>\n<p>7.主重新平衡副本</p>\n<p><strong>区块的一致性</strong></p>\n<p>1.一些区块可能会过时，它们错过的系统变化的操作</p>\n<p>2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器</p>\n<p>3.master和区块服务器持久化存储这个版本信息</p>\n<p>4.区块的版本信息也会发送给客户端</p>\n<p>5.版本号允许master和客户端检测过时数据</p>\n<p><strong>并发写/追加</strong></p>\n<p>1.客户端将并发的写文件的同一Region</p>\n<p>2.写入的结果是混合这些写入的–没有保证顺序</p>\n<ul>\n<li>很少有应用这样做，所以是没问题的</li>\n<li>UNIX上的并发写入也会导致奇怪的结果</li>\n</ul>\n<p>3.许多客户端可能想要并发的追加一个日志文件</p>\n<ul>\n<li>GFS支持原子操作</li>\n<li>主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器</li>\n<li>如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。</li>\n<li>客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）</li>\n<li>文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界</li>\n</ul>\n<p><strong>一致性模型</strong></p>\n<p>1.对于文件目录的操作是强一致的</p>\n<ul>\n<li>master对元数据的操作是原子性的</li>\n<li>目录的操作遵循下面的想法<ul>\n<li>当master伟offline状态时，只有shadow master</li>\n<li>只允许读操作，将有可能返回过期的数据</li>\n</ul>\n</li>\n</ul>\n<p>2.区块的操作是弱一致性的</p>\n<ul>\n<li><p>一个失败的操作会导致区块的不一致</p>\n<p>主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的</p>\n</li>\n<li><p>客户端读到的可能不是最新的区块数据</p>\n</li>\n<li><p>当客户端刷新租凭(lease)时，它将了解到新的版本号</p>\n</li>\n</ul>\n<p>3.作者声称弱一致性对于应用来说不是大问题</p>\n<ul>\n<li>大部分的文件更新操作都是追加的</li>\n<li>应用程序可以再附加记录中使用UID来检查重复项</li>\n<li>应用程序可能只是读取较少的数据（但不是陈旧的数据）</li>\n<li>应用程序可以使用临时文件，或者原子的执行重命名操作</li>\n</ul>\n<p><strong>性能</strong></p>\n<p>1.读取有巨大的吞吐量（3副本）</p>\n<ul>\n<li>总计125MB/秒</li>\n<li>网络链路饱和</li>\n</ul>\n<p>2.写入不同文件的次数可能低于最大值</p>\n<ul>\n<li>作者吐槽了他们的网络栈</li>\n<li>网络失效导致了从一个副本传播到下一个副本中间有延迟</li>\n</ul>\n<p>3.并发的追加单个文件</p>\n<p>受限于存储最后一个区块的服务器</p>\n<p><strong>总结</strong></p>\n<p>1.GFS使用的重要FT技术</p>\n<ul>\n<li>日志&amp;还原点(checkpoint)</li>\n<li>区块的主备复制，但保持一致性</li>\n</ul>\n<p>2.GFS优势</p>\n<ul>\n<li>大量顺序的读和写，追加</li>\n<li>大的吞吐量</li>\n<li>数据的容灾</li>\n</ul>\n<p>3.GFS缺点</p>\n<ul>\n<li>master的容灾</li>\n<li>小文件的读写</li>\n<li>多个客户端并发的更新同一个文件</li>\n</ul>\n"},{"title":"LEC5-vedio","date":"2019-01-17T01:36:18.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC5-vedio.md","raw":"---\ntitle: LEC5-vedio\ndate: 2019-01-17 09:36:18\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC5-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nijf000t2yw32uywbnsd","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC4","date":"2019-02-07T00:52:12.000Z","_content":"\n**今天的主题**\n\n1.主/从复制\n\n- 广泛使用，例如GFS的区块服务器\n- 但是今天被广泛应用于强一致\n- 特别重要，我们需要深入探索它\n\n2.VM-FT案例的学习\n\n**容错性**\n\n1.我们需要构建一个即使失败也能继续的服务\n\n2.高可用：在一些失败后仍然可用\n\n3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。\n\n4.非常困难！\n\n5.非常有用！\n\n**需要一个服务失败模型：我们将尝试处理什么？**\n\n1.独立的故障，停止计算机的故障\n\n- VM-FT假设一次只出现一个故障\n\n2.停电（最终重启）\n\n3.网络分区\n\n4.没有bugs，没有恶意攻击\n\n**核心的想法：复制**\n\n1.两台服务器\n\n2.每个副本保持着服务所需要的状态\n\n3.如果一个副本失效了，其他的可以继续提供服务\n\n**例子：MapReduce里面的matser模型**\n\n1.lab1里面的worker是高可用的，但是没有master\n\n- master是单点故障的\n\n2.我们可以有两个master吗，在一个失败的情况下？\n\n[架构图：M1, M2, workers]\n\n状态：\n\n- worker列表\n- 那些job做完了\n- 那些worker空闲\n- TCP连接的状态\n- 程序计数器\n\n**大的问题**\n\n1.要复制的状态是什么？\n\n2.副本如何获得状态？\n\n3.何时切换到副本服务器？\n\n4.切换的时候是否会表现出异常状态？\n\n5.如何修复，重新集成？\n\n**两个主要的方法**\n\n1.状态转换\n\n- 主服务器执行服务\n- 主服务器项备服务器发送新的状态\n\n2.副本的状态机\n\n- 所有的副本执行所有的操作\n- 如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态\n\n**状态转换更简单**\n\n1.但是状态空间可能比较大，转换起来很慢\n\n2.VM-FT使用复制状态机\n\n","source":"_posts/LEC4.md","raw":"---\ntitle: LEC4\ndate: 2019-02-07 08:52:12\ntags:\n---\n\n**今天的主题**\n\n1.主/从复制\n\n- 广泛使用，例如GFS的区块服务器\n- 但是今天被广泛应用于强一致\n- 特别重要，我们需要深入探索它\n\n2.VM-FT案例的学习\n\n**容错性**\n\n1.我们需要构建一个即使失败也能继续的服务\n\n2.高可用：在一些失败后仍然可用\n\n3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。\n\n4.非常困难！\n\n5.非常有用！\n\n**需要一个服务失败模型：我们将尝试处理什么？**\n\n1.独立的故障，停止计算机的故障\n\n- VM-FT假设一次只出现一个故障\n\n2.停电（最终重启）\n\n3.网络分区\n\n4.没有bugs，没有恶意攻击\n\n**核心的想法：复制**\n\n1.两台服务器\n\n2.每个副本保持着服务所需要的状态\n\n3.如果一个副本失效了，其他的可以继续提供服务\n\n**例子：MapReduce里面的matser模型**\n\n1.lab1里面的worker是高可用的，但是没有master\n\n- master是单点故障的\n\n2.我们可以有两个master吗，在一个失败的情况下？\n\n[架构图：M1, M2, workers]\n\n状态：\n\n- worker列表\n- 那些job做完了\n- 那些worker空闲\n- TCP连接的状态\n- 程序计数器\n\n**大的问题**\n\n1.要复制的状态是什么？\n\n2.副本如何获得状态？\n\n3.何时切换到副本服务器？\n\n4.切换的时候是否会表现出异常状态？\n\n5.如何修复，重新集成？\n\n**两个主要的方法**\n\n1.状态转换\n\n- 主服务器执行服务\n- 主服务器项备服务器发送新的状态\n\n2.副本的状态机\n\n- 所有的副本执行所有的操作\n- 如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态\n\n**状态转换更简单**\n\n1.但是状态空间可能比较大，转换起来很慢\n\n2.VM-FT使用复制状态机\n\n","slug":"LEC4","published":1,"updated":"2019-02-28T07:09:16.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nijg000v2yw3lp6d5wlj","content":"<p><strong>今天的主题</strong></p>\n<p>1.主/从复制</p>\n<ul>\n<li>广泛使用，例如GFS的区块服务器</li>\n<li>但是今天被广泛应用于强一致</li>\n<li>特别重要，我们需要深入探索它</li>\n</ul>\n<p>2.VM-FT案例的学习</p>\n<p><strong>容错性</strong></p>\n<p>1.我们需要构建一个即使失败也能继续的服务</p>\n<p>2.高可用：在一些失败后仍然可用</p>\n<p>3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。</p>\n<p>4.非常困难！</p>\n<p>5.非常有用！</p>\n<p><strong>需要一个服务失败模型：我们将尝试处理什么？</strong></p>\n<p>1.独立的故障，停止计算机的故障</p>\n<ul>\n<li>VM-FT假设一次只出现一个故障</li>\n</ul>\n<p>2.停电（最终重启）</p>\n<p>3.网络分区</p>\n<p>4.没有bugs，没有恶意攻击</p>\n<p><strong>核心的想法：复制</strong></p>\n<p>1.两台服务器</p>\n<p>2.每个副本保持着服务所需要的状态</p>\n<p>3.如果一个副本失效了，其他的可以继续提供服务</p>\n<p><strong>例子：MapReduce里面的matser模型</strong></p>\n<p>1.lab1里面的worker是高可用的，但是没有master</p>\n<ul>\n<li>master是单点故障的</li>\n</ul>\n<p>2.我们可以有两个master吗，在一个失败的情况下？</p>\n<p>[架构图：M1, M2, workers]</p>\n<p>状态：</p>\n<ul>\n<li>worker列表</li>\n<li>那些job做完了</li>\n<li>那些worker空闲</li>\n<li>TCP连接的状态</li>\n<li>程序计数器</li>\n</ul>\n<p><strong>大的问题</strong></p>\n<p>1.要复制的状态是什么？</p>\n<p>2.副本如何获得状态？</p>\n<p>3.何时切换到副本服务器？</p>\n<p>4.切换的时候是否会表现出异常状态？</p>\n<p>5.如何修复，重新集成？</p>\n<p><strong>两个主要的方法</strong></p>\n<p>1.状态转换</p>\n<ul>\n<li>主服务器执行服务</li>\n<li>主服务器项备服务器发送新的状态</li>\n</ul>\n<p>2.副本的状态机</p>\n<ul>\n<li>所有的副本执行所有的操作</li>\n<li>如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态</li>\n</ul>\n<p><strong>状态转换更简单</strong></p>\n<p>1.但是状态空间可能比较大，转换起来很慢</p>\n<p>2.VM-FT使用复制状态机</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>今天的主题</strong></p>\n<p>1.主/从复制</p>\n<ul>\n<li>广泛使用，例如GFS的区块服务器</li>\n<li>但是今天被广泛应用于强一致</li>\n<li>特别重要，我们需要深入探索它</li>\n</ul>\n<p>2.VM-FT案例的学习</p>\n<p><strong>容错性</strong></p>\n<p>1.我们需要构建一个即使失败也能继续的服务</p>\n<p>2.高可用：在一些失败后仍然可用</p>\n<p>3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。</p>\n<p>4.非常困难！</p>\n<p>5.非常有用！</p>\n<p><strong>需要一个服务失败模型：我们将尝试处理什么？</strong></p>\n<p>1.独立的故障，停止计算机的故障</p>\n<ul>\n<li>VM-FT假设一次只出现一个故障</li>\n</ul>\n<p>2.停电（最终重启）</p>\n<p>3.网络分区</p>\n<p>4.没有bugs，没有恶意攻击</p>\n<p><strong>核心的想法：复制</strong></p>\n<p>1.两台服务器</p>\n<p>2.每个副本保持着服务所需要的状态</p>\n<p>3.如果一个副本失效了，其他的可以继续提供服务</p>\n<p><strong>例子：MapReduce里面的matser模型</strong></p>\n<p>1.lab1里面的worker是高可用的，但是没有master</p>\n<ul>\n<li>master是单点故障的</li>\n</ul>\n<p>2.我们可以有两个master吗，在一个失败的情况下？</p>\n<p>[架构图：M1, M2, workers]</p>\n<p>状态：</p>\n<ul>\n<li>worker列表</li>\n<li>那些job做完了</li>\n<li>那些worker空闲</li>\n<li>TCP连接的状态</li>\n<li>程序计数器</li>\n</ul>\n<p><strong>大的问题</strong></p>\n<p>1.要复制的状态是什么？</p>\n<p>2.副本如何获得状态？</p>\n<p>3.何时切换到副本服务器？</p>\n<p>4.切换的时候是否会表现出异常状态？</p>\n<p>5.如何修复，重新集成？</p>\n<p><strong>两个主要的方法</strong></p>\n<p>1.状态转换</p>\n<ul>\n<li>主服务器执行服务</li>\n<li>主服务器项备服务器发送新的状态</li>\n</ul>\n<p>2.副本的状态机</p>\n<ul>\n<li>所有的副本执行所有的操作</li>\n<li>如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态</li>\n</ul>\n<p><strong>状态转换更简单</strong></p>\n<p>1.但是状态空间可能比较大，转换起来很慢</p>\n<p>2.VM-FT使用复制状态机</p>\n"},{"title":"LEC6-vedio","date":"2019-01-17T01:36:22.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC6-vedio.md","raw":"---\ntitle: LEC6-vedio\ndate: 2019-01-17 09:36:22\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC6-vedio","published":1,"updated":"2019-01-17T04:50:19.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nijh000x2yw3l5oe5rxk","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC7-vedio","date":"2019-01-17T01:36:27.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC7-vedio.md","raw":"---\ntitle: LEC7-vedio\ndate: 2019-01-17 09:36:27\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC7-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2niji000z2yw3vr2awg9k","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC8-vedio","date":"2019-01-17T01:36:32.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC8-vedio.md","raw":"---\ntitle: LEC8-vedio\ndate: 2019-01-17 09:36:32\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC8-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nijj00112yw31kcixlfb","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC9-vedio","date":"2019-01-17T01:36:36.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC9-vedio.md","raw":"---\ntitle: LEC9-vedio\ndate: 2019-01-17 09:36:36\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC9-vedio","published":1,"updated":"2019-01-17T04:50:19.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nijl00132yw3hyrzvb2r","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC3-vedio","date":"2019-01-17T01:35:58.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC3-vedio.md","raw":"---\ntitle: LEC3-vedio\ndate: 2019-01-17 09:35:58\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC3-vedio","published":1,"updated":"2019-01-17T04:50:19.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsu2nijm00152yw38b5xz6de","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"}],"PostAsset":[{"_id":"source/_posts/2018总结/2018.jpeg","slug":"2018.jpeg","post":"cjsu2niii00012yw3hugf8jtz","modified":0,"renderable":0},{"_id":"source/_posts/LEC1/MapReduce.png","slug":"MapReduce.png","post":"cjsu2niir00052yw39rktw9iq","modified":0,"renderable":0},{"_id":"source/_posts/LEC1/MapReduceApi.png","slug":"MapReduceApi.png","post":"cjsu2niir00052yw39rktw9iq","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjsu2niix00082yw3db75783l","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nij1000b2yw3yn2pb8ht"},{"post_id":"cjsu2niio00032yw3z5slbvc7","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nij4000d2yw38hebheyu"},{"post_id":"cjsu2niiy00092yw3ag56vygz","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nij7000g2yw30yobjtas"},{"post_id":"cjsu2nij2000c2yw30ep0gmic","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nij8000i2yw3wqmhbwkt"},{"post_id":"cjsu2niir00052yw39rktw9iq","tag_id":"cjsu2nij0000a2yw3vjy40zvq","_id":"cjsu2nij9000k2yw3kl02wz6g"},{"post_id":"cjsu2nij4000e2yw3sg5x2133","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nija000m2yw3e2cz0grd"},{"post_id":"cjsu2nij7000h2yw3gtgegihb","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nijc000o2yw319dbxgcr"},{"post_id":"cjsu2niiv00072yw3tcjrngft","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nijd000q2yw3cmnkvbvm"},{"post_id":"cjsu2nij8000j2yw3wzpnwg4y","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nije000s2yw3ly617bec"},{"post_id":"cjsu2nij9000l2yw31jtwyepl","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nijg000u2yw367bgpj42"},{"post_id":"cjsu2nija000n2yw3fskfc6ck","tag_id":"cjsu2nij0000a2yw3vjy40zvq","_id":"cjsu2nijh000w2yw32xhgslnj"},{"post_id":"cjsu2nijc000p2yw3l43z674e","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2niji000y2yw32r32e4f5"},{"post_id":"cjsu2nijd000r2yw3mr51cd6x","tag_id":"cjsu2nij0000a2yw3vjy40zvq","_id":"cjsu2nijj00102yw3bmm9ujp7"},{"post_id":"cjsu2nijf000t2yw32uywbnsd","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nijk00122yw3futr1vkn"},{"post_id":"cjsu2nijh000x2yw3l5oe5rxk","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nijm00142yw3edqo5www"},{"post_id":"cjsu2niji000z2yw3vr2awg9k","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nijo00162yw3sphl8gcr"},{"post_id":"cjsu2nijj00112yw31kcixlfb","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nijo00172yw3hg8wk7bj"},{"post_id":"cjsu2nijl00132yw3hyrzvb2r","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nijo00182yw3h2fppm5b"},{"post_id":"cjsu2nijm00152yw38b5xz6de","tag_id":"cjsu2niit00062yw3vec9mk3s","_id":"cjsu2nijo00192yw3jj645g2i"}],"Tag":[{"name":"6.824视频","_id":"cjsu2niit00062yw3vec9mk3s"},{"name":"分布式系统6.824笔记","_id":"cjsu2nij0000a2yw3vjy40zvq"}]}}
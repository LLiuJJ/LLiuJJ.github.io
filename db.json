{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"source/MOVIES/index/迦百农.jpg","path":"MOVIES/index/迦百农.jpg","modified":1,"renderable":0},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"3dfdb13f5c87fbc05e139def419d9c6cf3134d59","modified":1546841984251},{"_id":"source/.DS_Store","hash":"b48c4f7d61a5928be717d4bd654481ff1eab36ee","modified":1553007657360},{"_id":"source/favicon.ico","hash":"da48f1f7091f64d77ff8f79694381fb880f753d4","modified":1546927738866},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1546873650407},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1546873650407},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1546873650406},{"_id":"themes/maupassant/README.md","hash":"a3dcfa9b646980ee5811ec03b4c5786618b85ff9","modified":1546873650407},{"_id":"themes/maupassant/_config.yml","hash":"8ef2d760d9b2eca449b5e4a39a803faa4ea52c38","modified":1552187261264},{"_id":"themes/maupassant/package.json","hash":"33ed7d93880cdf98bd84b366aef22f089202527f","modified":1546875101656},{"_id":"source/_posts/.DS_Store","hash":"5129b14165dbbe40af0d9b3fe319df874e218472","modified":1552196404398},{"_id":"source/_posts/2018总结.md","hash":"0c7c3ad5febbdabcfd84d8a6fbc65ca7dce83a0a","modified":1547554715226},{"_id":"source/_posts/C-编程思想笔记.md","hash":"68bd25ce6e15d690731b3ba3142cc9aa2720034d","modified":1553324176504},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-02-notes.md","hash":"239771b3a326f42fb8733950f83f8e6d6501e753","modified":1553502453128},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes.md","hash":"97ec33e05dece5e23862c972f08603cede7ec35b","modified":1553761189907},{"_id":"source/_posts/LEC1-vedio.md","hash":"5b988aefc99504ae1bf2853e46dcc60eeb0bb819","modified":1547700798179},{"_id":"source/_posts/LEC1.md","hash":"8c282e5022d93f47bee1b49c62611c8134d0573b","modified":1547700036131},{"_id":"source/_posts/LEC10-vedio.md","hash":"5e940c9365c11cbcbd91919b5a54e95788b55ff6","modified":1547700619729},{"_id":"source/_posts/LEC12-vedio.md","hash":"b32068cd5bf06fd74b70d5426912be2801a82840","modified":1547700619729},{"_id":"source/_posts/LEC13-vedio.md","hash":"a60aeeba5ee4926cb2a0cbe7a1194946a583bdd4","modified":1547700619728},{"_id":"source/_posts/LEC15-vedio.md","hash":"9707bfaa85b1942eb4b252c733f7c55a69583176","modified":1547700619738},{"_id":"source/_posts/LEC16-vedio.md","hash":"de95a6d1dbd15815282f5acbda63bbf18d0dab98","modified":1547700619738},{"_id":"source/_posts/LEC17-vedio.md","hash":"e25d097a9245e12dce038b46dc42097a69ab23a5","modified":1547700901617},{"_id":"source/_posts/LEC2-vedio.md","hash":"b8aec07f91e03a3750290f75fe59383f46727c04","modified":1547700801730},{"_id":"source/_posts/LEC2.md","hash":"576e1fac0e2a6dbad9b30f293c369e92142727a7","modified":1548343950148},{"_id":"source/_posts/LEC20-vedio.md","hash":"9ce857803f18068fcb42b9d026c3e6ffe74071eb","modified":1547700203603},{"_id":"source/_posts/LEC3-vedio.md","hash":"666a51921fce83637e1131ef6e3a12f6e7618e21","modified":1547700619728},{"_id":"source/_posts/LEC3.md","hash":"8bd66310ee72d819aec75c88d48c8d58a10381d1","modified":1548652683684},{"_id":"source/_posts/LEC4-vedio.md","hash":"08b8550af4981b0a07a97d1918964c4f91fde50c","modified":1547700619729},{"_id":"source/_posts/LEC4.md","hash":"033ff1cb3d6fc576af7f8f0fccc60993d9b6eb94","modified":1553329127447},{"_id":"source/_posts/LEC5-vedio.md","hash":"f2de840e5bb5d921f4a2b8465720b55483e410cf","modified":1547700619729},{"_id":"source/_posts/LEC6-vedio.md","hash":"bc2cc920fedf6f2ecd121ff82855c3644afe1d8e","modified":1547700619730},{"_id":"source/_posts/LEC7-vedio.md","hash":"99cdac660d77588c2b5fa3e1bd37dbb1a8177faa","modified":1547700619729},{"_id":"source/_posts/LEC8-vedio.md","hash":"45d9e4ef1e510ffaad3c57ab69c2021862cbda68","modified":1547700619729},{"_id":"source/_posts/LEC9-vedio.md","hash":"7dc5ce2ddd6a6a106996bb156a0b8e17b17affac","modified":1547700619730},{"_id":"source/_posts/迦百农.md","hash":"42ebb29dce874601a94d31058943e9a9520da459","modified":1552198574829},{"_id":"source/about/index.md","hash":"4eaf089e0626c3657ace852cb535dcac4527bb37","modified":1547532871641},{"_id":"source/MIT-6-824/index.md","hash":"773b2c248a27a84a7ac053fdc89c2f9bd8bc2e6e","modified":1551338451469},{"_id":"source/LINUX/index.md","hash":"f2fff3675b5b022bf6816950eb947276d5331b88","modified":1551687737803},{"_id":"source/MOVIES/index.md","hash":"5927222c32d3d42c40f27ff9fe7d4bc2d38cf6e8","modified":1552196559714},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1546873650384},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1546873650390},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1546873600651},{"_id":"themes/maupassant/.git/index","hash":"ea4dd78bcda3744c083c6fff7b59f64808cf01ef","modified":1546878941216},{"_id":"themes/maupassant/.git/packed-refs","hash":"3d1060ac070341c07c117aace6e93ee59887ec2b","modified":1546873650376},{"_id":"themes/maupassant/layout/archive.pug","hash":"665582bb4092fcd81bfaf4d08fc1689abee1e6c4","modified":1546873650425},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1546873650426},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1546873650425},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1546873650426},{"_id":"themes/maupassant/layout/post.pug","hash":"bfe10ecfb515d241bb9a07e7d08be5779f2ef119","modified":1546873650427},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1546873650427},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1546873650427},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1546873650427},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1546873650411},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1546873650411},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1546873650412},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1546873650412},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1546873650412},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1546873650412},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1546873650413},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1546873650413},{"_id":"source/_posts/2018总结/2018.jpeg","hash":"4b5535ac167a1817a0ead3a0e9b84804f8ed3552","modified":1546877871543},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/PageLinkList.png","hash":"d8663b6b9c840867f6fc168c36ed34f202ec0643","modified":1553700672721},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/DirPages.png","hash":"1058d97b01ac0b38a2112f60adeb1ec85615f258","modified":1553701111348},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction1.png","hash":"ca3385d3e273e2da6b3144ea845f5354e91a66c8","modified":1553759203478},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction2.png","hash":"30c601bd6c188816185e5b1a3f24642a4fbbc5ef","modified":1553759219220},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction3.png","hash":"d317379bcfe0191d8e230c3bdd49ec2560d54caa","modified":1553759238243},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction4.png","hash":"69066e890fafa752a202e33629d59a02ed5bd89f","modified":1553759280962},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction6.png","hash":"590ccd291c42cf8d48e0506d4fcdc065e42572b8","modified":1553759350580},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction5.png","hash":"0d331d9bb908fe2c94ce2da6ada9cbf3c612de93","modified":1553759297422},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/denormalized1.png","hash":"fbdb8c180c8688301fba50ef7ef20470dd000e0b","modified":1553760912244},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/denormalized2.png","hash":"56c063eef0e80da90d958355bb9a3abe05399d97","modified":1553760936124},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/log1.png","hash":"740d0ad9f81c8bfb854c63744e0235c2691ebae3","modified":1553757788122},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/denormalized3.png","hash":"0693c991f8cf4e273420074625247ee045abacf2","modified":1553760951563},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/log2.png","hash":"8d63a07a141cf3e37ee697f66b30cff79d907709","modified":1553758403923},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/log3.png","hash":"e4b102922b6f8c30d24dfba20d7b0b6bf8338a6b","modified":1553758618017},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/mmap1.png","hash":"5d58799183e16e00d8b9a18a282453f034b48a5e","modified":1553528020399},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/record-ids.png","hash":"86e86429eb2aa6602b9d24664f7b48e37b7cf440","modified":1553761171752},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/page_header.png","hash":"d8ad45b7ff6a58cf6f21e8d1e6f953f4ad31ca0a","modified":1553755814543},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/slot-page1.png","hash":"9081b4fd9b735e25b0834c53d53a741ac29f8339","modified":1553757495673},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple-header.png","hash":"7c93bb8a2cedd047e3ea43445293d5ffd684d4b0","modified":1553759962435},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/slot-page2.png","hash":"17b8b7ab0fb2e087b6acca7cceb235b63ea44c1e","modified":1553757511553},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple-data.png","hash":"28bb1490d69be6b3778798034a95369175dd9f13","modified":1553760420939},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple3.png","hash":"3c4a71ab7aa884a8f62cba59e0c7760052e7e024","modified":1553756768040},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple2.png","hash":"7ae4de0c593f4354b08f5e93d14c52c3232127a3","modified":1553756750158},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple1.png","hash":"21a4bbdb6df922be5b3b2c173e5247965adedd06","modified":1553756725160},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple4.png","hash":"fb5b6a7c1858f3fdebb840bbfe355e709e688226","modified":1553756786121},{"_id":"source/_posts/LEC1/MapReduceApi.png","hash":"94de3afa77383512abd1791e90dfed0ef7dce162","modified":1547615637530},{"_id":"source/_posts/LEC1/MapReduce.png","hash":"4a0fbb1ac7fe41d83b669f5b465d104a5ad253d6","modified":1547615007681},{"_id":"source/_posts/迦百农/002.jpg","hash":"61ec03a4abb8fb8d0b655278ffa59409844b173f","modified":1552196062468},{"_id":"source/_posts/迦百农/004.jpg","hash":"83d88c7b9d191b98417c56ccb9379798122dfcec","modified":1552196087855},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1546873600655},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1546873600652},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1546873600658},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1546873600659},{"_id":"themes/maupassant/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1546873600656},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1546873600655},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1546873600659},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1546873600653},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1546873600657},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1546873600658},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1546873600661},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1546873600648},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"5cd7abcc6dfa2d7a81f6eecea61b9ca55e22bc4d","modified":1546873650388},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"06969aefa52218aa2320b7d735f751df4a7b5e1d","modified":1546873650414},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"ff14baa25f6db34dedfb5e029c25687a335ad430","modified":1546873650417},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"025c34e4e89d99b866fd5af2924e60e9f63e386b","modified":1546873650419},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1546873650418},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1546873650419},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"0ca48cbf73f5a5bbf5e2f615ce6c6366fe5662e7","modified":1546873650420},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1546873650420},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"10fb2af46002c57b6a38e2c530eaa8c3e0a77c67","modified":1546873650420},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1546873650421},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1546873650421},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1546873650421},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1546873650422},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1546873650422},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1546873650423},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1546873650424},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1546873650424},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1546873650425},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1546873650424},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1546873650428},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1546873650428},{"_id":"themes/maupassant/source/donate/index.html","hash":"04fb043ed312f6eaf8435440739febac2d465de0","modified":1546873650429},{"_id":"themes/maupassant/source/css/style.scss","hash":"b44da192f0875e144bf7990a99b42e31e986e099","modified":1546873650429},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1546873650431},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1546873650430},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1546873650430},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1546873650431},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1546873650432},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1546873650435},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1546873650432},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1546873650435},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1546873650433},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1546873650436},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1546873650436},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1546873650435},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1546873650438},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1546873650437},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1546873650438},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1546873650439},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/ACCESSTIMES.png","hash":"0566c55b3d13aba2a05590e44e43d49e526c1724","modified":1553504961533},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction7.png","hash":"a53bec2de34f72e3e3fa5d941b2a00cf31a6af7c","modified":1553759365807},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/mmap2.png","hash":"cd3c5006557df4359b7b94028bfe1ed53d957d0e","modified":1553528095546},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/mmap3.png","hash":"97e25ba072acf086c67282d512019c240264e348","modified":1553567206313},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/mmap4.png","hash":"4870d768c4955e37784b0c76080a744b2919a2b1","modified":1553567227261},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/mmap5.png","hash":"4cda996d9630f9aa98cebcc7efe337904d73e599","modified":1553567317151},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/pages.png","hash":"da6d4dfc55c1f083bae4190855c7318f3cf02d61","modified":1553678998222},{"_id":"source/_posts/迦百农/003.jpg","hash":"af60db4df8226a29b38e9b826644ce8b89971343","modified":1552196080618},{"_id":"source/_posts/迦百农/001.jpg","hash":"af60db4df8226a29b38e9b826644ce8b89971343","modified":1552191434381},{"_id":"source/_posts/迦百农/迦百农.jpg","hash":"87549e1673b52ae94216199895f552f2fd4046c4","modified":1552188432692},{"_id":"source/MOVIES/index/迦百农.jpg","hash":"87549e1673b52ae94216199895f552f2fd4046c4","modified":1552188432692},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"8d6c2028163017f65bb54fb912c65c6455ce7583","modified":1546873650388},{"_id":"themes/maupassant/.git/objects/pack/pack-c9f899d4b09b3e87558ae12626842798eb209708.idx","hash":"5823786eecf1806bb11faf62fa89fbbb363b31f4","modified":1546873650349},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1546873650437},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/StorageHierarchy.png","hash":"f73dc9949198eb39616f96e92b7765423ff6bbb8","modified":1553502557445},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"5cd7abcc6dfa2d7a81f6eecea61b9ca55e22bc4d","modified":1546873650388},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1546873650383},{"_id":"source/_posts/LEC1/QQ20190309-231854@2x.png","hash":"cc14b689322c8a56c9e4074c2c33da4dfdaddf96","modified":1552144736641},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"5cd7abcc6dfa2d7a81f6eecea61b9ca55e22bc4d","modified":1546873650383},{"_id":"source/_posts/LEC1/QQ20190309-233752@2x.png","hash":"8702c20da4bd0bbbff64945349688ade47c49935","modified":1552145875041},{"_id":"source/_posts/LEC1/QQ20190309-234523@2x.png","hash":"349fff79783985994b3d81a408955cd187f08d61","modified":1552146325117},{"_id":"source/_posts/LEC1/QQ20190309-234415@2x.png","hash":"12ce993145315aca31dc5b53923f442e97015570","modified":1552146257808},{"_id":"source/_posts/LEC1/QQ20190310-105207.png","hash":"d56f9c214936e50402ff30909bfcf1041ac90098","modified":1552186329286},{"_id":"source/_posts/LEC1/QQ20190309-230116@2x.png","hash":"db9e814de79bc8296dbb7e14a5b9bebea5f551a5","modified":1552143680205},{"_id":"source/_posts/LEC1/QQ20190309-230220@2x.png","hash":"840eca36ff3c145693a1fe895ffa33e6fed4df6b","modified":1552143742743},{"_id":"source/_posts/LEC1/QQ20190309-234749@2x.png","hash":"381b5842a3be03aac68248a4b511eb503affadcc","modified":1552146471726},{"_id":"source/_posts/LEC1/QQ20190310-104242.png","hash":"c46888197248cee0a3904acbfbce0542658876a9","modified":1552185765447},{"_id":"themes/maupassant/db.json","hash":"a6ebfe09d5ed47bb797c9816b0d79d78d00a0cb8","modified":1546875136590},{"_id":"source/_posts/LEC1/QQ20190309-231221@2x.png","hash":"8ec2b5c51dc5afd51b1d74be1aa0f09d1c2658a7","modified":1552144344600},{"_id":"source/_posts/LEC1/QQ20190310-104738.png","hash":"0af3d3caeede2c812efb40218fa4ccf9527b1c34","modified":1552186060911},{"_id":"source/_posts/LEC1/QQ20190310-103536.png","hash":"4819c3d59df9748af866f6af6db74a87d4e6557e","modified":1552185338490},{"_id":"themes/maupassant/.git/objects/pack/pack-c9f899d4b09b3e87558ae12626842798eb209708.pack","hash":"1de01345e0b6f0e93c2a9f5c6b78b261ef76d051","modified":1546873650345},{"_id":"source/_posts/LEC1/002.png","hash":"e57d5da6e2f5ce2ed05c81d76b11f2ca6ed0343c","modified":1552143336252},{"_id":"source/_posts/LEC1/QQ20190309-230801@2x.png","hash":"b59bce45fb5e012bd6010b98408a8451de642e84","modified":1552144083200},{"_id":"source/_posts/LEC1/QQ20190309-231930@2x.png","hash":"e54462e302404b005c1b010a2172f4a879f63d3c","modified":1552144772154},{"_id":"source/_posts/LEC1/QQ20190309-235308@2x.png","hash":"3cde76f72dba04e8f5de830fbc7154c518d4acb4","modified":1552146790631},{"_id":"source/_posts/LEC1/QQ20190310-102424.png","hash":"f5eb919878698ca3cb87b01cf79919d37f8c81fd","modified":1552184666921},{"_id":"source/_posts/LEC1/QQ20190310-103037.png","hash":"f70c97ca033b0799ac23b30747f854c01954b5b8","modified":1552185040076},{"_id":"source/_posts/LEC1/QQ20190310-104800.png","hash":"b7ed86c82edf92a6bf0016e41ea9bf07e5725a15","modified":1552186085111},{"_id":"source/_posts/LEC1/001.png","hash":"f46f449aa28c7f5ff5cd6db727e3605c931cedbf","modified":1552141937821},{"_id":"source/_posts/LEC1/QQ20190310-103722.png","hash":"13f23c2ee7ce929e9725cd399913ab67ca1f4fdf","modified":1552185444362},{"_id":"source/_posts/LEC1/QQ20190310-101849.png","hash":"c342dd8a5d887eff0f73ccedb2cd9719d33dcba2","modified":1552184332126},{"_id":"public/about/index.html","hash":"f34d063dec4cfd5182596e7025ccfdedb3bf8519","modified":1553761204718},{"_id":"public/MIT-6-824/index.html","hash":"2739aebe656377ef68beaa5c3a40f43d9fc88b61","modified":1553761204718},{"_id":"public/MOVIES/index.html","hash":"f8b178fbebd9f72bd619ab1e4341b4316a56441d","modified":1553761204718},{"_id":"public/LINUX/index.html","hash":"4df33aa8ad52953ae351d57a34a4496358c9e7b6","modified":1553761204718},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-02-notes/index.html","hash":"bed18533905cfc3c1bebbc18f43a86a03d1bbe11","modified":1553761204719},{"_id":"public/2019/03/10/迦百农/index.html","hash":"b7e54f255dc73a78e9918ed94730894efccccf53","modified":1553761204719},{"_id":"public/2019/02/07/LEC4/index.html","hash":"7b88528257b2abc0e8cc47f96f7d3b8e63a68f91","modified":1553761204719},{"_id":"public/2019/01/17/LEC20-vedio/index.html","hash":"4fd157edd81509f7c11d0422508b001d45d6117e","modified":1553761204719},{"_id":"public/2019/01/17/LEC17-vedio/index.html","hash":"038630d33a0ea4436961e02167229fb2faabb972","modified":1553761204719},{"_id":"public/2019/01/17/LEC16-vedio/index.html","hash":"cff7dbb2a857f0d0afd67ff433113c1672a69d07","modified":1553761204719},{"_id":"public/2019/01/17/LEC12-vedio/index.html","hash":"a1fff194cb307746711efd70f5e0e1054addcc83","modified":1553761204719},{"_id":"public/2019/01/17/LEC13-vedio/index.html","hash":"88e4bb4cc4cdd5c5b6e31ba4976d5cc06b4bdeae","modified":1553761204720},{"_id":"public/2019/01/17/LEC10-vedio/index.html","hash":"cee14705943d5fa70e0cbeaeb9c79ecf15dda03f","modified":1553761204720},{"_id":"public/2019/01/17/LEC9-vedio/index.html","hash":"bf9f4649b543772113311e5c1f98f53ce6792b20","modified":1553761204720},{"_id":"public/2019/01/17/LEC8-vedio/index.html","hash":"317e192c2060feaf4f61a01bdc90ff94d49839e4","modified":1553761204720},{"_id":"public/2019/01/17/LEC7-vedio/index.html","hash":"9ff26698544c26c41121b10e06cd2e398ab69b47","modified":1553761204721},{"_id":"public/2019/01/17/LEC15-vedio/index.html","hash":"92d3e052ba0d4404073cb33584c7a6fa123e4b6a","modified":1553761204721},{"_id":"public/2019/01/17/LEC6-vedio/index.html","hash":"4ee9acc5a8a70fd38b05b4ef9f543af069bdb959","modified":1553761204721},{"_id":"public/2019/01/17/LEC5-vedio/index.html","hash":"8be4103637e74895c3c480f591b3ccff643168d9","modified":1553761204721},{"_id":"public/2019/01/17/LEC4-vedio/index.html","hash":"ede5c759d302625e2b7f3f162327e19f2e4379e6","modified":1553761204721},{"_id":"public/2019/01/17/LEC3-vedio/index.html","hash":"0631460038a2a2c48310da98079faa9aaf9c8e01","modified":1553761204721},{"_id":"public/2019/01/16/LEC1-vedio/index.html","hash":"a6739e067c407e73b03298f1280405d9fe49bc49","modified":1553761204721},{"_id":"public/2019/01/17/LEC2-vedio/index.html","hash":"68bd8485e7ca086d9d6a6a96b2087c14e1d597ac","modified":1553761204721},{"_id":"public/2019/01/15/LEC1/index.html","hash":"8fb462e5bbd4964dbfe52f2024db34b6d224f7eb","modified":1553761204722},{"_id":"public/2019/01/08/2018总结/index.html","hash":"1a740ab67db6324a09997e17c8204c4d40a61070","modified":1553761204722},{"_id":"public/archives/index.html","hash":"d7f7c3dfc4e9dbfe74086f77e378c300c2f07e05","modified":1553761204722},{"_id":"public/archives/page/2/index.html","hash":"fcc36119446bad2951c595daf92dd328fb982e14","modified":1553761204722},{"_id":"public/archives/page/3/index.html","hash":"93593aa6c7577df3929845eee55f1cf2a712f97b","modified":1553761204722},{"_id":"public/archives/2019/index.html","hash":"ead70d7c192c0e206b337d39f3c21802d3057c8e","modified":1553761204722},{"_id":"public/archives/2019/page/2/index.html","hash":"faf8a30023850c136583380e4fc869d9ba6c18c2","modified":1553761204722},{"_id":"public/archives/2019/page/3/index.html","hash":"25c1dc167e83e8fc2bc7ffb175fb84ff9def3a7b","modified":1553761204722},{"_id":"public/archives/2019/01/index.html","hash":"d3930df84d0f681c122bee0783672d836164b21c","modified":1553761204722},{"_id":"public/archives/2019/01/page/2/index.html","hash":"6d00243128915082b876e5fd0f1b523b2132e7d5","modified":1553761204722},{"_id":"public/archives/2019/02/index.html","hash":"c4c49fcfc3af5f6f872f5533e73d91c461a571da","modified":1553761204722},{"_id":"public/archives/2019/03/index.html","hash":"c5db0e3109e12a9a3e733bdaf575ba39a8b79075","modified":1553761204722},{"_id":"public/index.html","hash":"5006f0995578a1916e8708792232e1b3268691b5","modified":1553761204723},{"_id":"public/page/2/index.html","hash":"24fac1962ce1c24fba5544ac1652dcf625bc81a4","modified":1553761204723},{"_id":"public/page/3/index.html","hash":"07fdaa71aceeb784c9a2c6a255644ea034cd0b63","modified":1553761204723},{"_id":"public/tags/6-824视频/index.html","hash":"75ca0f54397011cd7f0722d4ccb0592ce45b07f0","modified":1553761204723},{"_id":"public/tags/6-824视频/page/2/index.html","hash":"a046056df96bb1f1e97c09c84abd56a7b16d64ea","modified":1553761204723},{"_id":"public/tags/分布式系统6-824笔记/index.html","hash":"ea920089072431e412122ef29113ca8fa5acee6c","modified":1553761204723},{"_id":"public/tags/movies/index.html","hash":"8b4f98925e466871199eff7facdb37935ec0a13c","modified":1553761204723},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/index.html","hash":"12993ac016695049d9e530f0fc4e86eb26a5ce38","modified":1553761204723},{"_id":"public/2019/03/15/C-编程思想笔记/index.html","hash":"cedc9f376cf52b119ec6ff93e85b638f18bece13","modified":1553761204723},{"_id":"public/2019/01/17/LEC2/index.html","hash":"ad704a2011e67df05ef989a2ee0e9be76947cae0","modified":1553761204723},{"_id":"public/2019/01/24/LEC3/index.html","hash":"5a03808b8ef34597922f8e3d720d22fd3eadda2b","modified":1553761204724},{"_id":"public/CNAME","hash":"3dfdb13f5c87fbc05e139def419d9c6cf3134d59","modified":1553761204755},{"_id":"public/favicon.ico","hash":"da48f1f7091f64d77ff8f79694381fb880f753d4","modified":1553761204756},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1553761204756},{"_id":"public/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1553761204756},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1553761204756},{"_id":"public/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1553761204756},{"_id":"public/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1553761204756},{"_id":"public/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1553761204756},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1553761204756},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1553761204756},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1553761204756},{"_id":"public/2019/01/08/2018总结/2018.jpeg","hash":"4b5535ac167a1817a0ead3a0e9b84804f8ed3552","modified":1553761204757},{"_id":"public/2019/03/10/迦百农/004.jpg","hash":"83d88c7b9d191b98417c56ccb9379798122dfcec","modified":1553761204757},{"_id":"public/2019/03/10/迦百农/002.jpg","hash":"61ec03a4abb8fb8d0b655278ffa59409844b173f","modified":1553761204758},{"_id":"public/2019/01/15/LEC1/MapReduceApi.png","hash":"94de3afa77383512abd1791e90dfed0ef7dce162","modified":1553761204758},{"_id":"public/2019/01/15/LEC1/MapReduce.png","hash":"4a0fbb1ac7fe41d83b669f5b465d104a5ad253d6","modified":1553761204758},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/DirPages.png","hash":"1058d97b01ac0b38a2112f60adeb1ec85615f258","modified":1553761204758},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap1.png","hash":"5d58799183e16e00d8b9a18a282453f034b48a5e","modified":1553761204758},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/PageLinkList.png","hash":"d8663b6b9c840867f6fc168c36ed34f202ec0643","modified":1553761204758},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction1.png","hash":"ca3385d3e273e2da6b3144ea845f5354e91a66c8","modified":1553761204758},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction2.png","hash":"30c601bd6c188816185e5b1a3f24642a4fbbc5ef","modified":1553761204758},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction3.png","hash":"d317379bcfe0191d8e230c3bdd49ec2560d54caa","modified":1553761204758},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction4.png","hash":"69066e890fafa752a202e33629d59a02ed5bd89f","modified":1553761204759},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction5.png","hash":"0d331d9bb908fe2c94ce2da6ada9cbf3c612de93","modified":1553761204759},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction6.png","hash":"590ccd291c42cf8d48e0506d4fcdc065e42572b8","modified":1553761204759},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/denormalized1.png","hash":"fbdb8c180c8688301fba50ef7ef20470dd000e0b","modified":1553761204759},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/denormalized2.png","hash":"56c063eef0e80da90d958355bb9a3abe05399d97","modified":1553761204759},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/log1.png","hash":"740d0ad9f81c8bfb854c63744e0235c2691ebae3","modified":1553761204759},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/denormalized3.png","hash":"0693c991f8cf4e273420074625247ee045abacf2","modified":1553761204759},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/log3.png","hash":"e4b102922b6f8c30d24dfba20d7b0b6bf8338a6b","modified":1553761204759},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/page_header.png","hash":"d8ad45b7ff6a58cf6f21e8d1e6f953f4ad31ca0a","modified":1553761204759},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/log2.png","hash":"8d63a07a141cf3e37ee697f66b30cff79d907709","modified":1553761204760},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/record-ids.png","hash":"86e86429eb2aa6602b9d24664f7b48e37b7cf440","modified":1553761204760},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/slot-page2.png","hash":"17b8b7ab0fb2e087b6acca7cceb235b63ea44c1e","modified":1553761204760},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple-data.png","hash":"28bb1490d69be6b3778798034a95369175dd9f13","modified":1553761204760},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple-header.png","hash":"7c93bb8a2cedd047e3ea43445293d5ffd684d4b0","modified":1553761204760},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple1.png","hash":"21a4bbdb6df922be5b3b2c173e5247965adedd06","modified":1553761204760},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple2.png","hash":"7ae4de0c593f4354b08f5e93d14c52c3232127a3","modified":1553761204760},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple3.png","hash":"3c4a71ab7aa884a8f62cba59e0c7760052e7e024","modified":1553761204760},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple4.png","hash":"fb5b6a7c1858f3fdebb840bbfe355e709e688226","modified":1553761204760},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/slot-page1.png","hash":"9081b4fd9b735e25b0834c53d53a741ac29f8339","modified":1553761204760},{"_id":"public/2019/03/10/迦百农/001.jpg","hash":"af60db4df8226a29b38e9b826644ce8b89971343","modified":1553761204817},{"_id":"public/2019/03/10/迦百农/003.jpg","hash":"af60db4df8226a29b38e9b826644ce8b89971343","modified":1553761204820},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/ACCESSTIMES.png","hash":"0566c55b3d13aba2a05590e44e43d49e526c1724","modified":1553761204820},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap2.png","hash":"cd3c5006557df4359b7b94028bfe1ed53d957d0e","modified":1553761204820},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap3.png","hash":"97e25ba072acf086c67282d512019c240264e348","modified":1553761204820},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap4.png","hash":"4870d768c4955e37784b0c76080a744b2919a2b1","modified":1553761204821},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap5.png","hash":"4cda996d9630f9aa98cebcc7efe337904d73e599","modified":1553761204821},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/pages.png","hash":"da6d4dfc55c1f083bae4190855c7318f3cf02d61","modified":1553761204821},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction7.png","hash":"a53bec2de34f72e3e3fa5d941b2a00cf31a6af7c","modified":1553761204821},{"_id":"public/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1553761204831},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1553761204831},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1553761204831},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1553761204832},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1553761204832},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1553761204832},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1553761204832},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1553761204832},{"_id":"public/donate/index.html","hash":"dc7d6decf7ee412556f77344135480b9c5ab8345","modified":1553761204832},{"_id":"public/css/style.css","hash":"773ad46efbd957c22bbbc2900521908f81c04d7a","modified":1553761204832},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1553761204832},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1553761204832},{"_id":"public/2019/03/10/迦百农/迦百农.jpg","hash":"87549e1673b52ae94216199895f552f2fd4046c4","modified":1553761204833},{"_id":"public/MOVIES/index/迦百农.jpg","hash":"87549e1673b52ae94216199895f552f2fd4046c4","modified":1553761204833},{"_id":"public/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/StorageHierarchy.png","hash":"f73dc9949198eb39616f96e92b7765423ff6bbb8","modified":1553761204847},{"_id":"public/2019/01/15/LEC1/QQ20190309-231854@2x.png","hash":"cc14b689322c8a56c9e4074c2c33da4dfdaddf96","modified":1553761204870},{"_id":"public/2019/01/15/LEC1/QQ20190309-233752@2x.png","hash":"8702c20da4bd0bbbff64945349688ade47c49935","modified":1553761204887},{"_id":"public/2019/01/15/LEC1/QQ20190309-234523@2x.png","hash":"349fff79783985994b3d81a408955cd187f08d61","modified":1553761204893},{"_id":"public/2019/01/15/LEC1/QQ20190310-105207.png","hash":"d56f9c214936e50402ff30909bfcf1041ac90098","modified":1553761204893},{"_id":"public/2019/01/15/LEC1/QQ20190309-234415@2x.png","hash":"12ce993145315aca31dc5b53923f442e97015570","modified":1553761204894},{"_id":"public/2019/01/15/LEC1/QQ20190309-230116@2x.png","hash":"db9e814de79bc8296dbb7e14a5b9bebea5f551a5","modified":1553761204900},{"_id":"public/2019/01/15/LEC1/QQ20190309-230220@2x.png","hash":"840eca36ff3c145693a1fe895ffa33e6fed4df6b","modified":1553761204901},{"_id":"public/2019/01/15/LEC1/QQ20190309-234749@2x.png","hash":"381b5842a3be03aac68248a4b511eb503affadcc","modified":1553761204901},{"_id":"public/2019/01/15/LEC1/QQ20190310-104242.png","hash":"c46888197248cee0a3904acbfbce0542658876a9","modified":1553761204907},{"_id":"public/2019/01/15/LEC1/QQ20190309-231221@2x.png","hash":"8ec2b5c51dc5afd51b1d74be1aa0f09d1c2658a7","modified":1553761204991},{"_id":"public/2019/01/15/LEC1/QQ20190310-104738.png","hash":"0af3d3caeede2c812efb40218fa4ccf9527b1c34","modified":1553761204991},{"_id":"public/2019/01/15/LEC1/QQ20190310-103536.png","hash":"4819c3d59df9748af866f6af6db74a87d4e6557e","modified":1553761204999},{"_id":"public/2019/01/15/LEC1/QQ20190309-231930@2x.png","hash":"e54462e302404b005c1b010a2172f4a879f63d3c","modified":1553761205013},{"_id":"public/2019/01/15/LEC1/QQ20190309-235308@2x.png","hash":"3cde76f72dba04e8f5de830fbc7154c518d4acb4","modified":1553761205013},{"_id":"public/2019/01/15/LEC1/QQ20190309-230801@2x.png","hash":"b59bce45fb5e012bd6010b98408a8451de642e84","modified":1553761205014},{"_id":"public/2019/01/15/LEC1/QQ20190310-102424.png","hash":"f5eb919878698ca3cb87b01cf79919d37f8c81fd","modified":1553761205015},{"_id":"public/2019/01/15/LEC1/QQ20190310-103037.png","hash":"f70c97ca033b0799ac23b30747f854c01954b5b8","modified":1553761205017},{"_id":"public/2019/01/15/LEC1/002.png","hash":"e57d5da6e2f5ce2ed05c81d76b11f2ca6ed0343c","modified":1553761205018},{"_id":"public/2019/01/15/LEC1/QQ20190310-104800.png","hash":"b7ed86c82edf92a6bf0016e41ea9bf07e5725a15","modified":1553761205020},{"_id":"public/2019/01/15/LEC1/001.png","hash":"f46f449aa28c7f5ff5cd6db727e3605c931cedbf","modified":1553761205026},{"_id":"public/2019/01/15/LEC1/QQ20190310-103722.png","hash":"13f23c2ee7ce929e9725cd399913ab67ca1f4fdf","modified":1553761205026},{"_id":"public/2019/01/15/LEC1/QQ20190310-101849.png","hash":"c342dd8a5d887eff0f73ccedb2cd9719d33dcba2","modified":1553761205031}],"Category":[],"Data":[],"Page":[{"title":"关于我","date":"2019-01-07T15:37:55.000Z","_content":"\n一个喜欢看各种书籍的书呆子！\n\n一个追求极致计算能力的疯子！\n\n一个追寻自由自在生活的浪子！\n\nemail: jay_jieliu@outlook.com\n\n知乎: [JAYL](https://www.zhihu.com/people/liu-jie-84-52/activities)\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2019-01-07 23:37:55\n---\n\n一个喜欢看各种书籍的书呆子！\n\n一个追求极致计算能力的疯子！\n\n一个追寻自由自在生活的浪子！\n\nemail: jay_jieliu@outlook.com\n\n知乎: [JAYL](https://www.zhihu.com/people/liu-jie-84-52/activities)\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n","updated":"2019-01-15T06:14:31.641Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjtsdaw100001no3y2sq1keqk","content":"<p>一个喜欢看各种书籍的书呆子！</p>\n<p>一个追求极致计算能力的疯子！</p>\n<p>一个追寻自由自在生活的浪子！</p>\n<p>email: <a href=\"mailto:jay_jieliu@outlook.com\" target=\"_blank\" rel=\"noopener\">jay_jieliu@outlook.com</a></p>\n<p>知乎: <a href=\"https://www.zhihu.com/people/liu-jie-84-52/activities\" target=\"_blank\" rel=\"noopener\">JAYL</a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<p>一个喜欢看各种书籍的书呆子！</p>\n<p>一个追求极致计算能力的疯子！</p>\n<p>一个追寻自由自在生活的浪子！</p>\n<p>email: <a href=\"mailto:jay_jieliu@outlook.com\" target=\"_blank\" rel=\"noopener\">jay_jieliu@outlook.com</a></p>\n<p>知乎: <a href=\"https://www.zhihu.com/people/liu-jie-84-52/activities\" target=\"_blank\" rel=\"noopener\">JAYL</a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n"},{"title":"MIT-6.824","date":"2019-01-15T12:12:41.000Z","_content":"\n#### 翻译MIT Distributed-Systems 系列课程的资料\n| 课程视频                                                     | 课程笔记                                         | Paper阅读笔记                                   | Lab            |\n| ------------------------------------------------------------ | ------------------------------------------------ | ----------------------------------------------- | -------------- |\n| 1.[课程介绍](https://turingturing.cn/2019/01/16/LEC1-vedio/) | [LEC1](https://turingturing.cn/2019/01/15/LEC1/) | MapReduce                                       | MapReduceLab   |\n| 2.[RPC和多线程编程](https://turingturing.cn/2019/01/17/LEC2-vedio/) | [LEC2](https://turingturing.cn/2019/01/17/LEC2/) |                                                 | RpcLab         |\n| 3.GFS                                                        | [LEC3](https://turingturing.cn/2019/01/24/LEC3/) | GFS                                             |                |\n| 4.(Primary/Backup Replication)主/备 复制                     |                                                  | Fault Tolerance Virtual Machines - 容错的虚拟机 |                |\n| 5.Raft1                                                      |                                                  | Raft-extended                                   | RaftLab        |\n| 6.Raft2                                                      |                                                  | Raft-extended                                   | KVRaft Lab     |\n| 7.Go语言讲解-Guest lecturer                                  |                                                  | Go的内存模型                                    |                |\n| 8.Zookeeper                                                  |                                                  | ZooKeeper                                       |                |\n| 9.Distributed Transactions (分布式事务)                      |                                                  |                                                 |                |\n| 10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口) |                                                  |                                                 |                |\n| 11.FaRM                                                      |                                                  |                                                 |                |\n| 12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性) |                                                  | ThreadMarks                                     | Sharded KV Lab |\n| 13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性) |                                                  | Bayou                                           |                |\n| 14.Case Studies: Relaxed Consistency (案例研究：弱一致性)    |                                                  | PNUTS                                           |                |\n| 15.Case Studies:Dynamo (案例研究：Dynamo)                    |                                                  | Dynamo                                          |                |\n| 16.Wide-Area Publish/Subscribe (广域的发布和订阅)            |                                                  | Wormhole                                        |                |\n| 17.Measuring Consisitency (衡量一致性)                       |                                                  | Existential Consistency                         |                |\n| 18.Case Studies: Spark (案例学习：Spark)                     |                                                  | Spark                                           |                |\n| 19.Cluster Management (集群管理)                             |                                                  | Borg                                            |                |\n| 20.Peer-to-peer: Trackerless Bittrrent and DHTs              |                                                  | Trackerless Bittrrent                           |                |\n| 21.Peer-to-peer: Bitcoin （点对点 比特币）                   |                                                  | Bitcoin summary                                 |                |\n| 22: Guest lecturer: Frank Dabek of Google                    |                                                  | The Tail at Scale                               |                |\n| 23: Project Demos                                            |                                                  | Analogicfs                                      |                |\n\n**一些有用的链接**\n\n- 动画理解Raft http://thesecretlivesofdata.com/raft/\n\n","source":"MIT-6-824/index.md","raw":"---\ntitle: MIT-6.824\ndate: 2019-01-15 20:12:41\n---\n\n#### 翻译MIT Distributed-Systems 系列课程的资料\n| 课程视频                                                     | 课程笔记                                         | Paper阅读笔记                                   | Lab            |\n| ------------------------------------------------------------ | ------------------------------------------------ | ----------------------------------------------- | -------------- |\n| 1.[课程介绍](https://turingturing.cn/2019/01/16/LEC1-vedio/) | [LEC1](https://turingturing.cn/2019/01/15/LEC1/) | MapReduce                                       | MapReduceLab   |\n| 2.[RPC和多线程编程](https://turingturing.cn/2019/01/17/LEC2-vedio/) | [LEC2](https://turingturing.cn/2019/01/17/LEC2/) |                                                 | RpcLab         |\n| 3.GFS                                                        | [LEC3](https://turingturing.cn/2019/01/24/LEC3/) | GFS                                             |                |\n| 4.(Primary/Backup Replication)主/备 复制                     |                                                  | Fault Tolerance Virtual Machines - 容错的虚拟机 |                |\n| 5.Raft1                                                      |                                                  | Raft-extended                                   | RaftLab        |\n| 6.Raft2                                                      |                                                  | Raft-extended                                   | KVRaft Lab     |\n| 7.Go语言讲解-Guest lecturer                                  |                                                  | Go的内存模型                                    |                |\n| 8.Zookeeper                                                  |                                                  | ZooKeeper                                       |                |\n| 9.Distributed Transactions (分布式事务)                      |                                                  |                                                 |                |\n| 10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口) |                                                  |                                                 |                |\n| 11.FaRM                                                      |                                                  |                                                 |                |\n| 12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性) |                                                  | ThreadMarks                                     | Sharded KV Lab |\n| 13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性) |                                                  | Bayou                                           |                |\n| 14.Case Studies: Relaxed Consistency (案例研究：弱一致性)    |                                                  | PNUTS                                           |                |\n| 15.Case Studies:Dynamo (案例研究：Dynamo)                    |                                                  | Dynamo                                          |                |\n| 16.Wide-Area Publish/Subscribe (广域的发布和订阅)            |                                                  | Wormhole                                        |                |\n| 17.Measuring Consisitency (衡量一致性)                       |                                                  | Existential Consistency                         |                |\n| 18.Case Studies: Spark (案例学习：Spark)                     |                                                  | Spark                                           |                |\n| 19.Cluster Management (集群管理)                             |                                                  | Borg                                            |                |\n| 20.Peer-to-peer: Trackerless Bittrrent and DHTs              |                                                  | Trackerless Bittrrent                           |                |\n| 21.Peer-to-peer: Bitcoin （点对点 比特币）                   |                                                  | Bitcoin summary                                 |                |\n| 22: Guest lecturer: Frank Dabek of Google                    |                                                  | The Tail at Scale                               |                |\n| 23: Project Demos                                            |                                                  | Analogicfs                                      |                |\n\n**一些有用的链接**\n\n- 动画理解Raft http://thesecretlivesofdata.com/raft/\n\n","updated":"2019-02-28T07:20:51.469Z","path":"MIT-6-824/index.html","comments":1,"layout":"page","_id":"cjtsdaw140003no3yyyn9524w","content":"<h4 id=\"翻译MIT-Distributed-Systems-系列课程的资料\"><a href=\"#翻译MIT-Distributed-Systems-系列课程的资料\" class=\"headerlink\" title=\"翻译MIT Distributed-Systems 系列课程的资料\"></a>翻译MIT Distributed-Systems 系列课程的资料</h4><table>\n<thead>\n<tr>\n<th>课程视频</th>\n<th>课程笔记</th>\n<th>Paper阅读笔记</th>\n<th>Lab</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.<a href=\"https://turingturing.cn/2019/01/16/LEC1-vedio/\">课程介绍</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/15/LEC1/\">LEC1</a></td>\n<td>MapReduce</td>\n<td>MapReduceLab</td>\n</tr>\n<tr>\n<td>2.<a href=\"https://turingturing.cn/2019/01/17/LEC2-vedio/\">RPC和多线程编程</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/17/LEC2/\">LEC2</a></td>\n<td></td>\n<td>RpcLab</td>\n</tr>\n<tr>\n<td>3.GFS</td>\n<td><a href=\"https://turingturing.cn/2019/01/24/LEC3/\">LEC3</a></td>\n<td>GFS</td>\n<td></td>\n</tr>\n<tr>\n<td>4.(Primary/Backup Replication)主/备 复制</td>\n<td></td>\n<td>Fault Tolerance Virtual Machines - 容错的虚拟机</td>\n<td></td>\n</tr>\n<tr>\n<td>5.Raft1</td>\n<td></td>\n<td>Raft-extended</td>\n<td>RaftLab</td>\n</tr>\n<tr>\n<td>6.Raft2</td>\n<td></td>\n<td>Raft-extended</td>\n<td>KVRaft Lab</td>\n</tr>\n<tr>\n<td>7.Go语言讲解-Guest lecturer</td>\n<td></td>\n<td>Go的内存模型</td>\n<td></td>\n</tr>\n<tr>\n<td>8.Zookeeper</td>\n<td></td>\n<td>ZooKeeper</td>\n<td></td>\n</tr>\n<tr>\n<td>9.Distributed Transactions (分布式事务)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11.FaRM</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性)</td>\n<td></td>\n<td>ThreadMarks</td>\n<td>Sharded KV Lab</td>\n</tr>\n<tr>\n<td>13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性)</td>\n<td></td>\n<td>Bayou</td>\n<td></td>\n</tr>\n<tr>\n<td>14.Case Studies: Relaxed Consistency (案例研究：弱一致性)</td>\n<td></td>\n<td>PNUTS</td>\n<td></td>\n</tr>\n<tr>\n<td>15.Case Studies:Dynamo (案例研究：Dynamo)</td>\n<td></td>\n<td>Dynamo</td>\n<td></td>\n</tr>\n<tr>\n<td>16.Wide-Area Publish/Subscribe (广域的发布和订阅)</td>\n<td></td>\n<td>Wormhole</td>\n<td></td>\n</tr>\n<tr>\n<td>17.Measuring Consisitency (衡量一致性)</td>\n<td></td>\n<td>Existential Consistency</td>\n<td></td>\n</tr>\n<tr>\n<td>18.Case Studies: Spark (案例学习：Spark)</td>\n<td></td>\n<td>Spark</td>\n<td></td>\n</tr>\n<tr>\n<td>19.Cluster Management (集群管理)</td>\n<td></td>\n<td>Borg</td>\n<td></td>\n</tr>\n<tr>\n<td>20.Peer-to-peer: Trackerless Bittrrent and DHTs</td>\n<td></td>\n<td>Trackerless Bittrrent</td>\n<td></td>\n</tr>\n<tr>\n<td>21.Peer-to-peer: Bitcoin （点对点 比特币）</td>\n<td></td>\n<td>Bitcoin summary</td>\n<td></td>\n</tr>\n<tr>\n<td>22: Guest lecturer: Frank Dabek of Google</td>\n<td></td>\n<td>The Tail at Scale</td>\n<td></td>\n</tr>\n<tr>\n<td>23: Project Demos</td>\n<td></td>\n<td>Analogicfs</td>\n</tr>\n</tbody>\n</table>\n<p><strong>一些有用的链接</strong></p>\n<ul>\n<li>动画理解Raft <a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"noopener\">http://thesecretlivesofdata.com/raft/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"翻译MIT-Distributed-Systems-系列课程的资料\"><a href=\"#翻译MIT-Distributed-Systems-系列课程的资料\" class=\"headerlink\" title=\"翻译MIT Distributed-Systems 系列课程的资料\"></a>翻译MIT Distributed-Systems 系列课程的资料</h4><table>\n<thead>\n<tr>\n<th>课程视频</th>\n<th>课程笔记</th>\n<th>Paper阅读笔记</th>\n<th>Lab</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.<a href=\"https://turingturing.cn/2019/01/16/LEC1-vedio/\">课程介绍</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/15/LEC1/\">LEC1</a></td>\n<td>MapReduce</td>\n<td>MapReduceLab</td>\n</tr>\n<tr>\n<td>2.<a href=\"https://turingturing.cn/2019/01/17/LEC2-vedio/\">RPC和多线程编程</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/17/LEC2/\">LEC2</a></td>\n<td></td>\n<td>RpcLab</td>\n</tr>\n<tr>\n<td>3.GFS</td>\n<td><a href=\"https://turingturing.cn/2019/01/24/LEC3/\">LEC3</a></td>\n<td>GFS</td>\n<td></td>\n</tr>\n<tr>\n<td>4.(Primary/Backup Replication)主/备 复制</td>\n<td></td>\n<td>Fault Tolerance Virtual Machines - 容错的虚拟机</td>\n<td></td>\n</tr>\n<tr>\n<td>5.Raft1</td>\n<td></td>\n<td>Raft-extended</td>\n<td>RaftLab</td>\n</tr>\n<tr>\n<td>6.Raft2</td>\n<td></td>\n<td>Raft-extended</td>\n<td>KVRaft Lab</td>\n</tr>\n<tr>\n<td>7.Go语言讲解-Guest lecturer</td>\n<td></td>\n<td>Go的内存模型</td>\n<td></td>\n</tr>\n<tr>\n<td>8.Zookeeper</td>\n<td></td>\n<td>ZooKeeper</td>\n<td></td>\n</tr>\n<tr>\n<td>9.Distributed Transactions (分布式事务)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11.FaRM</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性)</td>\n<td></td>\n<td>ThreadMarks</td>\n<td>Sharded KV Lab</td>\n</tr>\n<tr>\n<td>13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性)</td>\n<td></td>\n<td>Bayou</td>\n<td></td>\n</tr>\n<tr>\n<td>14.Case Studies: Relaxed Consistency (案例研究：弱一致性)</td>\n<td></td>\n<td>PNUTS</td>\n<td></td>\n</tr>\n<tr>\n<td>15.Case Studies:Dynamo (案例研究：Dynamo)</td>\n<td></td>\n<td>Dynamo</td>\n<td></td>\n</tr>\n<tr>\n<td>16.Wide-Area Publish/Subscribe (广域的发布和订阅)</td>\n<td></td>\n<td>Wormhole</td>\n<td></td>\n</tr>\n<tr>\n<td>17.Measuring Consisitency (衡量一致性)</td>\n<td></td>\n<td>Existential Consistency</td>\n<td></td>\n</tr>\n<tr>\n<td>18.Case Studies: Spark (案例学习：Spark)</td>\n<td></td>\n<td>Spark</td>\n<td></td>\n</tr>\n<tr>\n<td>19.Cluster Management (集群管理)</td>\n<td></td>\n<td>Borg</td>\n<td></td>\n</tr>\n<tr>\n<td>20.Peer-to-peer: Trackerless Bittrrent and DHTs</td>\n<td></td>\n<td>Trackerless Bittrrent</td>\n<td></td>\n</tr>\n<tr>\n<td>21.Peer-to-peer: Bitcoin （点对点 比特币）</td>\n<td></td>\n<td>Bitcoin summary</td>\n<td></td>\n</tr>\n<tr>\n<td>22: Guest lecturer: Frank Dabek of Google</td>\n<td></td>\n<td>The Tail at Scale</td>\n<td></td>\n</tr>\n<tr>\n<td>23: Project Demos</td>\n<td></td>\n<td>Analogicfs</td>\n</tr>\n</tbody>\n</table>\n<p><strong>一些有用的链接</strong></p>\n<ul>\n<li>动画理解Raft <a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"noopener\">http://thesecretlivesofdata.com/raft/</a></li>\n</ul>\n"},{"title":"MOVIES","date":"2019-03-10T03:06:37.000Z","_content":"\n**《[迦百农](https://turingturing.cn/2019/03/10/迦百农/)》**\n\n![迦百农](index/迦百农.jpg)\n\n","source":"MOVIES/index.md","raw":"---\ntitle: MOVIES\ndate: 2019-03-10 11:06:37\n---\n\n**《[迦百农](https://turingturing.cn/2019/03/10/迦百农/)》**\n\n![迦百农](index/迦百农.jpg)\n\n","updated":"2019-03-10T05:42:39.714Z","path":"MOVIES/index.html","comments":1,"layout":"page","_id":"cjtsdaw180005no3yk4ue7ur6","content":"<p><strong>《<a href=\"https://turingturing.cn/2019/03/10/迦百农/\">迦百农</a>》</strong></p>\n<p><img src=\"/MOVIES/index/迦百农.jpg\" alt=\"迦百农\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>《<a href=\"https://turingturing.cn/2019/03/10/迦百农/\">迦百农</a>》</strong></p>\n<p><img src=\"/MOVIES/index/迦百农.jpg\" alt=\"迦百农\"></p>\n"},{"title":"LINUX","date":"2019-03-04T08:17:30.000Z","_content":"\nLINUX 官网 https://www.kernel.org/\n\nLINUX 源码阅读网站 https://elixir.bootlin.com/linux/v4.20.13/source\n\n\n","source":"LINUX/index.md","raw":"---\ntitle: LINUX\ndate: 2019-03-04 16:17:30\n---\n\nLINUX 官网 https://www.kernel.org/\n\nLINUX 源码阅读网站 https://elixir.bootlin.com/linux/v4.20.13/source\n\n\n","updated":"2019-03-04T08:22:17.803Z","path":"LINUX/index.html","comments":1,"layout":"page","_id":"cjtsdaw1f0007no3y9e3jjvmn","content":"<p>LINUX 官网 <a href=\"https://www.kernel.org/\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/</a></p>\n<p>LINUX 源码阅读网站 <a href=\"https://elixir.bootlin.com/linux/v4.20.13/source\" target=\"_blank\" rel=\"noopener\">https://elixir.bootlin.com/linux/v4.20.13/source</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>LINUX 官网 <a href=\"https://www.kernel.org/\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/</a></p>\n<p>LINUX 源码阅读网站 <a href=\"https://elixir.bootlin.com/linux/v4.20.13/source\" target=\"_blank\" rel=\"noopener\">https://elixir.bootlin.com/linux/v4.20.13/source</a></p>\n"}],"Post":[{"title":"2018总结","date":"2019-01-07T16:11:48.000Z","_content":"\n  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。\n  \n  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。\n  \n  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！\n  \n  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。\n  \n  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。\n  \n 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。\n \n 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。\n \n 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。\n \n<div style=\"width: 360px; margin: auto\">![2018](2018总结/2018.jpeg)</div>\n\n\n","source":"_posts/2018总结.md","raw":"---\ntitle: 2018总结\ndate: 2019-01-08 00:11:48\ntags:\n---\n\n  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。\n  \n  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。\n  \n  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！\n  \n  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。\n  \n  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。\n  \n 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。\n \n 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。\n \n 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。\n \n<div style=\"width: 360px; margin: auto\">![2018](2018总结/2018.jpeg)</div>\n\n\n","slug":"2018总结","published":1,"updated":"2019-01-15T12:18:35.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw0s0000no3y764v269n","content":"<p>  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。</p>\n<p>  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。</p>\n<p>  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！</p>\n<p>  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。</p>\n<p>  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。</p>\n<p> 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。</p>\n<p> 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。</p>\n<p> 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。</p>\n<div style=\"width: 360px; margin: auto\"><img src=\"/2019/01/08/2018总结/2018.jpeg\" alt=\"2018\"></div>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。</p>\n<p>  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。</p>\n<p>  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！</p>\n<p>  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。</p>\n<p>  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。</p>\n<p> 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。</p>\n<p> 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。</p>\n<p> 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。</p>\n<div style=\"width: 360px; margin: auto\"><img src=\"/2019/01/08/2018总结/2018.jpeg\" alt=\"2018\"></div>\n\n\n"},{"title":"C++编程思想笔记","date":"2019-03-15T09:39:38.000Z","_content":"\n1.改变已存在的基类函数的行为，称为重载这个函数？\n\n2.面向对象编程的宗旨\n\n- 系统中有哪些对象？\n- 它们之间的接口是什么？\n\n3.函数声明时参数标识符是可选的。函数定义时则要求要有标识符。(C++中允许不命名参数为了给程序员提供在参数列表中保留位置)\n\n4.关于#include ：永尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。用双引号时，预处理器以“由实现定义的方式”来寻找文件。它通常是从当前目录开始寻找，如果没有找到，那么include 命令按与尖括号同样的方式开始寻找。\n\n5.名字空间的作用：当程序达到一定规模后，通常分成许多块，每一块由不同的人或小组来构造和连接。不同模块中碰巧用到了相同的函数名和标识符会导致不必要的冲突，标准的C++中用namespace的机制防止这种冲突。\n\n6.string 具有动态特性，不必担心string的内存分配；只管添加新的内容进去就行了，string会自动扩展以保存新的输入。\n\n7.C++函数原型必须指明函数的返回值类型\n\n8.static变量的两层意义\n\n- 如果想使局部变量的值在程序整个生命期里仍然存在，我们可以定义函数的局部变量为static\n- static的第二层意思是“在某个作用域外不可访问”，函数名是局部于文件的，我们说它具有文件作用域\n\n9.extern关键字的意义\n\n- 它告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它。这个变量或函数可能在另一个文件中或者当前文件后面定义。\n\n10.C++中的显示转换\n\n| static_cast      | 用于“良性”和“适度良性”转换，包括不用强制转换                 |\n| ---------------- | ------------------------------------------------------------ |\n| const_cast       | 对\"const\"和/或\"volatile\"进行转换(从const转换为非const或从volatile转换为非volatile) |\n| reinterpret_cast | 重解释转换                                                   |\n| Dynamic_cast     | 用于类型安全的向下转换                                       |\n\n11.typedef 给struct定义别名\n\n```\ntypedef struct SelfReferential {\n \tint i;\n    SelfReferential* sr;\n}SelfReferential;\n\n//使用\nSelfReferential sr1, sr2;\n```\n\n12.使用预处理调试标记\n\n```\n#define DEBUG\n#ifdef DEBUG\n/*调试的代码*/\n#endif DEBUG\n```\n\n13.在写调试代码时，编写包含变量名后跟变量名是很无聊的，可以用字符串化运算符简化\n\n```\n#define P(A) cout << #A << \": \" << (A) << endl;\n```\n\n```\nint main() {\n    int a = 1, b = 2, c = 3;\n    P(a); P(b); P(c);\n    P(a + b);\n    P((c - b) / b);\n}\n```\n\n```\n[root@localhost CPPDemo]# ./cast1 \na: 1\nb: 2\nc: 3\na + b: 3\n(c - b) / b: 0\n```\n\n14.一旦定义了一个函数指针，在使用前必须给它赋一个函数的地址\n\n```\nvoid func() {\n    cout << \"func() called ...\" << endl;\n}\n\nvoid func2() {\n    cout << \"func2() called ..\" << endl;\n}\n\nint main() {\n    void (*fp)(); //定义一个函数指针\n    fp = func; //初始化它\n    (*fp)(); //调用它指向的函数\n    void (*fp2)() = func2; //定义并初始化一个函数指针\n    (*fp2)();\n}\n```\n\n```\n[root@localhost CPPDemo]# ./fun_ptr \nfunc() called ...\nfunc2() called ..\n```\n\n15.妙用函数指针数组\n\n```\n#include <iostream>\nusing namespace std;\n\n#define DF(N) void N() {\\ \n    cout << \"function \" #N \" called ... \" << endl; }\n\nDF(a); DF(b); DF(c); DF(d); DF(e); DF(f); DF(g);\n\nvoid (*func_table[])() = {a, b, c, d, e, f, g};\n\nint main() {\n    while(1) {\n        cout << \"press a key from 'a' to 'g'\"\n            \"or q to quit\" << endl;\n        char c, cr;\n        cin.get(c); cin.get(cr);\n        if (c == 'q')\n            break;\n        if (c < 'a' || c > 'g')\n            continue;\n        (*func_table[c - 'a'])();\n\n    }\n}\n\n[root@localhost CPPDemo]# ./fun_ptr_table \npress a key from 'a' to 'g'or q to quit\nb\nfunction b called ... \npress a key from 'a' to 'g'or q to quit\nc\nfunction c called ... \npress a key from 'a' to 'g'or q to quit\nq\n```\n\n16.C++允许将任何类型的指针赋值给void *，但不允许指针赋给任何其他类型的指针。\n\n17.C++中的访问控制\n\n| public    | 在其后声明的所有成员可以被所有的人访问                       |\n| --------- | ------------------------------------------------------------ |\n| private   | private关键字意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问 |\n| protected | 继承的结构可以访问protected成员，但不能访问private成员       |\n\n18.访问控制为类的创建者提供了很有价值的控制。类的客户程序员可以清楚的看到，什么可以用，什么应该忽略。更重要的是，它保证了使用类的客户程序员不会依赖类的实现细节，这样类库的开发者更改某些实现客户程序员不会因此受到影响。\n\n19.构造函数执行原理\n\n```\nclass X {\n    int i;\npublic:\n\tX();\n}\n\nvoid f() {\n    X a;\n    // ...\n}\n```\n\n当程序执行到a的序列点执行的点时，构造函数自动被调用，编译器悄悄的在a的定义点处拆入了一个X::X()的调用。就像其他成员函数被调用一样，传递到构造函数的第一个(秘密)参数是this指针，也就是调用这一个函数对象的内存地址，不过，对构造函数来说，this指针指向一个没有被初始化的内存块，构造函数的作用就是正确初始化该内存块\n\n20.当对象超出它的作用域的时候，编译器将自动调用析构函数。\n\n21.C++中禁止用返回值重载函数\n\n22.在C++中，struct和class唯一的不同之处在于，struct默认为public，而class默认为private。自然的，也可以让struct有构造啊函数和析构函数。另外，一个union（联合）也可以带有构造函数、析构函数、成员函数甚至访问控制。\n\n23.只有参数列表的后部参数才是可默认的；一旦在一个函数调用中开始使用默认参数，那么这个参数后面所有参数都必须是默认的。\n\n24.占位符参数:函数声明时，参数可以没有标识符\n\n```\nvoid f(int x, int, float flt);\n```\n\n如果开始用了一个函数参数，而后来发现不需要用它，可以将它去掉而不会产生警告错误，而且不需要改动那些调用该函数以前版本的程序代码。\n\n25.不能把默认参数作为一个标志去决定执行函数的哪一块，这是基本原则。在这种情况下，只要能够，就应该把函数分解成两个或多个重载的函数。\n\n26.关于const和指针\n\nu是一个指针，它指向一个const int，它所指的内容是不能被改变的\n\n```\nconst int* u;\n```\n\nw是一个指针，这个指针是指向int的const指针，指针本身不可改变\n\n```\nint d = 1;\nint* const w = &d;\n```\n\n指针的对象都不能改变\n\n```\nint d = 1;\nconst int* const x = &d\n```\n\n","source":"_posts/C-编程思想笔记.md","raw":"---\ntitle: C++编程思想笔记\ndate: 2019-03-15 17:39:38\ntags:\n---\n\n1.改变已存在的基类函数的行为，称为重载这个函数？\n\n2.面向对象编程的宗旨\n\n- 系统中有哪些对象？\n- 它们之间的接口是什么？\n\n3.函数声明时参数标识符是可选的。函数定义时则要求要有标识符。(C++中允许不命名参数为了给程序员提供在参数列表中保留位置)\n\n4.关于#include ：永尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。用双引号时，预处理器以“由实现定义的方式”来寻找文件。它通常是从当前目录开始寻找，如果没有找到，那么include 命令按与尖括号同样的方式开始寻找。\n\n5.名字空间的作用：当程序达到一定规模后，通常分成许多块，每一块由不同的人或小组来构造和连接。不同模块中碰巧用到了相同的函数名和标识符会导致不必要的冲突，标准的C++中用namespace的机制防止这种冲突。\n\n6.string 具有动态特性，不必担心string的内存分配；只管添加新的内容进去就行了，string会自动扩展以保存新的输入。\n\n7.C++函数原型必须指明函数的返回值类型\n\n8.static变量的两层意义\n\n- 如果想使局部变量的值在程序整个生命期里仍然存在，我们可以定义函数的局部变量为static\n- static的第二层意思是“在某个作用域外不可访问”，函数名是局部于文件的，我们说它具有文件作用域\n\n9.extern关键字的意义\n\n- 它告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它。这个变量或函数可能在另一个文件中或者当前文件后面定义。\n\n10.C++中的显示转换\n\n| static_cast      | 用于“良性”和“适度良性”转换，包括不用强制转换                 |\n| ---------------- | ------------------------------------------------------------ |\n| const_cast       | 对\"const\"和/或\"volatile\"进行转换(从const转换为非const或从volatile转换为非volatile) |\n| reinterpret_cast | 重解释转换                                                   |\n| Dynamic_cast     | 用于类型安全的向下转换                                       |\n\n11.typedef 给struct定义别名\n\n```\ntypedef struct SelfReferential {\n \tint i;\n    SelfReferential* sr;\n}SelfReferential;\n\n//使用\nSelfReferential sr1, sr2;\n```\n\n12.使用预处理调试标记\n\n```\n#define DEBUG\n#ifdef DEBUG\n/*调试的代码*/\n#endif DEBUG\n```\n\n13.在写调试代码时，编写包含变量名后跟变量名是很无聊的，可以用字符串化运算符简化\n\n```\n#define P(A) cout << #A << \": \" << (A) << endl;\n```\n\n```\nint main() {\n    int a = 1, b = 2, c = 3;\n    P(a); P(b); P(c);\n    P(a + b);\n    P((c - b) / b);\n}\n```\n\n```\n[root@localhost CPPDemo]# ./cast1 \na: 1\nb: 2\nc: 3\na + b: 3\n(c - b) / b: 0\n```\n\n14.一旦定义了一个函数指针，在使用前必须给它赋一个函数的地址\n\n```\nvoid func() {\n    cout << \"func() called ...\" << endl;\n}\n\nvoid func2() {\n    cout << \"func2() called ..\" << endl;\n}\n\nint main() {\n    void (*fp)(); //定义一个函数指针\n    fp = func; //初始化它\n    (*fp)(); //调用它指向的函数\n    void (*fp2)() = func2; //定义并初始化一个函数指针\n    (*fp2)();\n}\n```\n\n```\n[root@localhost CPPDemo]# ./fun_ptr \nfunc() called ...\nfunc2() called ..\n```\n\n15.妙用函数指针数组\n\n```\n#include <iostream>\nusing namespace std;\n\n#define DF(N) void N() {\\ \n    cout << \"function \" #N \" called ... \" << endl; }\n\nDF(a); DF(b); DF(c); DF(d); DF(e); DF(f); DF(g);\n\nvoid (*func_table[])() = {a, b, c, d, e, f, g};\n\nint main() {\n    while(1) {\n        cout << \"press a key from 'a' to 'g'\"\n            \"or q to quit\" << endl;\n        char c, cr;\n        cin.get(c); cin.get(cr);\n        if (c == 'q')\n            break;\n        if (c < 'a' || c > 'g')\n            continue;\n        (*func_table[c - 'a'])();\n\n    }\n}\n\n[root@localhost CPPDemo]# ./fun_ptr_table \npress a key from 'a' to 'g'or q to quit\nb\nfunction b called ... \npress a key from 'a' to 'g'or q to quit\nc\nfunction c called ... \npress a key from 'a' to 'g'or q to quit\nq\n```\n\n16.C++允许将任何类型的指针赋值给void *，但不允许指针赋给任何其他类型的指针。\n\n17.C++中的访问控制\n\n| public    | 在其后声明的所有成员可以被所有的人访问                       |\n| --------- | ------------------------------------------------------------ |\n| private   | private关键字意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问 |\n| protected | 继承的结构可以访问protected成员，但不能访问private成员       |\n\n18.访问控制为类的创建者提供了很有价值的控制。类的客户程序员可以清楚的看到，什么可以用，什么应该忽略。更重要的是，它保证了使用类的客户程序员不会依赖类的实现细节，这样类库的开发者更改某些实现客户程序员不会因此受到影响。\n\n19.构造函数执行原理\n\n```\nclass X {\n    int i;\npublic:\n\tX();\n}\n\nvoid f() {\n    X a;\n    // ...\n}\n```\n\n当程序执行到a的序列点执行的点时，构造函数自动被调用，编译器悄悄的在a的定义点处拆入了一个X::X()的调用。就像其他成员函数被调用一样，传递到构造函数的第一个(秘密)参数是this指针，也就是调用这一个函数对象的内存地址，不过，对构造函数来说，this指针指向一个没有被初始化的内存块，构造函数的作用就是正确初始化该内存块\n\n20.当对象超出它的作用域的时候，编译器将自动调用析构函数。\n\n21.C++中禁止用返回值重载函数\n\n22.在C++中，struct和class唯一的不同之处在于，struct默认为public，而class默认为private。自然的，也可以让struct有构造啊函数和析构函数。另外，一个union（联合）也可以带有构造函数、析构函数、成员函数甚至访问控制。\n\n23.只有参数列表的后部参数才是可默认的；一旦在一个函数调用中开始使用默认参数，那么这个参数后面所有参数都必须是默认的。\n\n24.占位符参数:函数声明时，参数可以没有标识符\n\n```\nvoid f(int x, int, float flt);\n```\n\n如果开始用了一个函数参数，而后来发现不需要用它，可以将它去掉而不会产生警告错误，而且不需要改动那些调用该函数以前版本的程序代码。\n\n25.不能把默认参数作为一个标志去决定执行函数的哪一块，这是基本原则。在这种情况下，只要能够，就应该把函数分解成两个或多个重载的函数。\n\n26.关于const和指针\n\nu是一个指针，它指向一个const int，它所指的内容是不能被改变的\n\n```\nconst int* u;\n```\n\nw是一个指针，这个指针是指向int的const指针，指针本身不可改变\n\n```\nint d = 1;\nint* const w = &d;\n```\n\n指针的对象都不能改变\n\n```\nint d = 1;\nconst int* const x = &d\n```\n\n","slug":"C-编程思想笔记","published":1,"updated":"2019-03-23T06:56:16.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw110002no3yiuiaqdta","content":"<p>1.改变已存在的基类函数的行为，称为重载这个函数？</p>\n<p>2.面向对象编程的宗旨</p>\n<ul>\n<li>系统中有哪些对象？</li>\n<li>它们之间的接口是什么？</li>\n</ul>\n<p>3.函数声明时参数标识符是可选的。函数定义时则要求要有标识符。(C++中允许不命名参数为了给程序员提供在参数列表中保留位置)</p>\n<p>4.关于#include ：永尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。用双引号时，预处理器以“由实现定义的方式”来寻找文件。它通常是从当前目录开始寻找，如果没有找到，那么include 命令按与尖括号同样的方式开始寻找。</p>\n<p>5.名字空间的作用：当程序达到一定规模后，通常分成许多块，每一块由不同的人或小组来构造和连接。不同模块中碰巧用到了相同的函数名和标识符会导致不必要的冲突，标准的C++中用namespace的机制防止这种冲突。</p>\n<p>6.string 具有动态特性，不必担心string的内存分配；只管添加新的内容进去就行了，string会自动扩展以保存新的输入。</p>\n<p>7.C++函数原型必须指明函数的返回值类型</p>\n<p>8.static变量的两层意义</p>\n<ul>\n<li>如果想使局部变量的值在程序整个生命期里仍然存在，我们可以定义函数的局部变量为static</li>\n<li>static的第二层意思是“在某个作用域外不可访问”，函数名是局部于文件的，我们说它具有文件作用域</li>\n</ul>\n<p>9.extern关键字的意义</p>\n<ul>\n<li>它告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它。这个变量或函数可能在另一个文件中或者当前文件后面定义。</li>\n</ul>\n<p>10.C++中的显示转换</p>\n<table>\n<thead>\n<tr>\n<th>static_cast</th>\n<th>用于“良性”和“适度良性”转换，包括不用强制转换</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>const_cast</td>\n<td>对”const”和/或”volatile”进行转换(从const转换为非const或从volatile转换为非volatile)</td>\n</tr>\n<tr>\n<td>reinterpret_cast</td>\n<td>重解释转换</td>\n</tr>\n<tr>\n<td>Dynamic_cast</td>\n<td>用于类型安全的向下转换</td>\n</tr>\n</tbody>\n</table>\n<p>11.typedef 给struct定义别名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct SelfReferential &#123;</span><br><span class=\"line\"> \tint i;</span><br><span class=\"line\">    SelfReferential* sr;</span><br><span class=\"line\">&#125;SelfReferential;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用</span><br><span class=\"line\">SelfReferential sr1, sr2;</span><br></pre></td></tr></table></figure>\n<p>12.使用预处理调试标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DEBUG</span><br><span class=\"line\">#ifdef DEBUG</span><br><span class=\"line\">/*调试的代码*/</span><br><span class=\"line\">#endif DEBUG</span><br></pre></td></tr></table></figure>\n<p>13.在写调试代码时，编写包含变量名后跟变量名是很无聊的，可以用字符串化运算符简化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define P(A) cout &lt;&lt; #A &lt;&lt; &quot;: &quot; &lt;&lt; (A) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int a = 1, b = 2, c = 3;</span><br><span class=\"line\">    P(a); P(b); P(c);</span><br><span class=\"line\">    P(a + b);</span><br><span class=\"line\">    P((c - b) / b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost CPPDemo]# ./cast1 </span><br><span class=\"line\">a: 1</span><br><span class=\"line\">b: 2</span><br><span class=\"line\">c: 3</span><br><span class=\"line\">a + b: 3</span><br><span class=\"line\">(c - b) / b: 0</span><br></pre></td></tr></table></figure>\n<p>14.一旦定义了一个函数指针，在使用前必须给它赋一个函数的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;func() called ...&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;func2() called ..&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    void (*fp)(); //定义一个函数指针</span><br><span class=\"line\">    fp = func; //初始化它</span><br><span class=\"line\">    (*fp)(); //调用它指向的函数</span><br><span class=\"line\">    void (*fp2)() = func2; //定义并初始化一个函数指针</span><br><span class=\"line\">    (*fp2)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost CPPDemo]# ./fun_ptr </span><br><span class=\"line\">func() called ...</span><br><span class=\"line\">func2() called ..</span><br></pre></td></tr></table></figure>\n<p>15.妙用函数指针数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">#define DF(N) void N() &#123;\\ </span><br><span class=\"line\">    cout &lt;&lt; &quot;function &quot; #N &quot; called ... &quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DF(a); DF(b); DF(c); DF(d); DF(e); DF(f); DF(g);</span><br><span class=\"line\"></span><br><span class=\"line\">void (*func_table[])() = &#123;a, b, c, d, e, f, g&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    while(1) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;press a key from &apos;a&apos; to &apos;g&apos;&quot;</span><br><span class=\"line\">            &quot;or q to quit&quot; &lt;&lt; endl;</span><br><span class=\"line\">        char c, cr;</span><br><span class=\"line\">        cin.get(c); cin.get(cr);</span><br><span class=\"line\">        if (c == &apos;q&apos;)</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        if (c &lt; &apos;a&apos; || c &gt; &apos;g&apos;)</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        (*func_table[c - &apos;a&apos;])();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost CPPDemo]# ./fun_ptr_table </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">b</span><br><span class=\"line\">function b called ... </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">c</span><br><span class=\"line\">function c called ... </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">q</span><br></pre></td></tr></table></figure>\n<p>16.C++允许将任何类型的指针赋值给void *，但不允许指针赋给任何其他类型的指针。</p>\n<p>17.C++中的访问控制</p>\n<table>\n<thead>\n<tr>\n<th>public</th>\n<th>在其后声明的所有成员可以被所有的人访问</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>private</td>\n<td>private关键字意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>继承的结构可以访问protected成员，但不能访问private成员</td>\n</tr>\n</tbody>\n</table>\n<p>18.访问控制为类的创建者提供了很有价值的控制。类的客户程序员可以清楚的看到，什么可以用，什么应该忽略。更重要的是，它保证了使用类的客户程序员不会依赖类的实现细节，这样类库的开发者更改某些实现客户程序员不会因此受到影响。</p>\n<p>19.构造函数执行原理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class X &#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tX();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void f() &#123;</span><br><span class=\"line\">    X a;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当程序执行到a的序列点执行的点时，构造函数自动被调用，编译器悄悄的在a的定义点处拆入了一个X::X()的调用。就像其他成员函数被调用一样，传递到构造函数的第一个(秘密)参数是this指针，也就是调用这一个函数对象的内存地址，不过，对构造函数来说，this指针指向一个没有被初始化的内存块，构造函数的作用就是正确初始化该内存块</p>\n<p>20.当对象超出它的作用域的时候，编译器将自动调用析构函数。</p>\n<p>21.C++中禁止用返回值重载函数</p>\n<p>22.在C++中，struct和class唯一的不同之处在于，struct默认为public，而class默认为private。自然的，也可以让struct有构造啊函数和析构函数。另外，一个union（联合）也可以带有构造函数、析构函数、成员函数甚至访问控制。</p>\n<p>23.只有参数列表的后部参数才是可默认的；一旦在一个函数调用中开始使用默认参数，那么这个参数后面所有参数都必须是默认的。</p>\n<p>24.占位符参数:函数声明时，参数可以没有标识符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void f(int x, int, float flt);</span><br></pre></td></tr></table></figure>\n<p>如果开始用了一个函数参数，而后来发现不需要用它，可以将它去掉而不会产生警告错误，而且不需要改动那些调用该函数以前版本的程序代码。</p>\n<p>25.不能把默认参数作为一个标志去决定执行函数的哪一块，这是基本原则。在这种情况下，只要能够，就应该把函数分解成两个或多个重载的函数。</p>\n<p>26.关于const和指针</p>\n<p>u是一个指针，它指向一个const int，它所指的内容是不能被改变的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int* u;</span><br></pre></td></tr></table></figure>\n<p>w是一个指针，这个指针是指向int的const指针，指针本身不可改变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int d = 1;</span><br><span class=\"line\">int* const w = &amp;d;</span><br></pre></td></tr></table></figure>\n<p>指针的对象都不能改变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int d = 1;</span><br><span class=\"line\">const int* const x = &amp;d</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>1.改变已存在的基类函数的行为，称为重载这个函数？</p>\n<p>2.面向对象编程的宗旨</p>\n<ul>\n<li>系统中有哪些对象？</li>\n<li>它们之间的接口是什么？</li>\n</ul>\n<p>3.函数声明时参数标识符是可选的。函数定义时则要求要有标识符。(C++中允许不命名参数为了给程序员提供在参数列表中保留位置)</p>\n<p>4.关于#include ：永尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。用双引号时，预处理器以“由实现定义的方式”来寻找文件。它通常是从当前目录开始寻找，如果没有找到，那么include 命令按与尖括号同样的方式开始寻找。</p>\n<p>5.名字空间的作用：当程序达到一定规模后，通常分成许多块，每一块由不同的人或小组来构造和连接。不同模块中碰巧用到了相同的函数名和标识符会导致不必要的冲突，标准的C++中用namespace的机制防止这种冲突。</p>\n<p>6.string 具有动态特性，不必担心string的内存分配；只管添加新的内容进去就行了，string会自动扩展以保存新的输入。</p>\n<p>7.C++函数原型必须指明函数的返回值类型</p>\n<p>8.static变量的两层意义</p>\n<ul>\n<li>如果想使局部变量的值在程序整个生命期里仍然存在，我们可以定义函数的局部变量为static</li>\n<li>static的第二层意思是“在某个作用域外不可访问”，函数名是局部于文件的，我们说它具有文件作用域</li>\n</ul>\n<p>9.extern关键字的意义</p>\n<ul>\n<li>它告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它。这个变量或函数可能在另一个文件中或者当前文件后面定义。</li>\n</ul>\n<p>10.C++中的显示转换</p>\n<table>\n<thead>\n<tr>\n<th>static_cast</th>\n<th>用于“良性”和“适度良性”转换，包括不用强制转换</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>const_cast</td>\n<td>对”const”和/或”volatile”进行转换(从const转换为非const或从volatile转换为非volatile)</td>\n</tr>\n<tr>\n<td>reinterpret_cast</td>\n<td>重解释转换</td>\n</tr>\n<tr>\n<td>Dynamic_cast</td>\n<td>用于类型安全的向下转换</td>\n</tr>\n</tbody>\n</table>\n<p>11.typedef 给struct定义别名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct SelfReferential &#123;</span><br><span class=\"line\"> \tint i;</span><br><span class=\"line\">    SelfReferential* sr;</span><br><span class=\"line\">&#125;SelfReferential;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用</span><br><span class=\"line\">SelfReferential sr1, sr2;</span><br></pre></td></tr></table></figure>\n<p>12.使用预处理调试标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DEBUG</span><br><span class=\"line\">#ifdef DEBUG</span><br><span class=\"line\">/*调试的代码*/</span><br><span class=\"line\">#endif DEBUG</span><br></pre></td></tr></table></figure>\n<p>13.在写调试代码时，编写包含变量名后跟变量名是很无聊的，可以用字符串化运算符简化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define P(A) cout &lt;&lt; #A &lt;&lt; &quot;: &quot; &lt;&lt; (A) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int a = 1, b = 2, c = 3;</span><br><span class=\"line\">    P(a); P(b); P(c);</span><br><span class=\"line\">    P(a + b);</span><br><span class=\"line\">    P((c - b) / b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost CPPDemo]# ./cast1 </span><br><span class=\"line\">a: 1</span><br><span class=\"line\">b: 2</span><br><span class=\"line\">c: 3</span><br><span class=\"line\">a + b: 3</span><br><span class=\"line\">(c - b) / b: 0</span><br></pre></td></tr></table></figure>\n<p>14.一旦定义了一个函数指针，在使用前必须给它赋一个函数的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;func() called ...&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;func2() called ..&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    void (*fp)(); //定义一个函数指针</span><br><span class=\"line\">    fp = func; //初始化它</span><br><span class=\"line\">    (*fp)(); //调用它指向的函数</span><br><span class=\"line\">    void (*fp2)() = func2; //定义并初始化一个函数指针</span><br><span class=\"line\">    (*fp2)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost CPPDemo]# ./fun_ptr </span><br><span class=\"line\">func() called ...</span><br><span class=\"line\">func2() called ..</span><br></pre></td></tr></table></figure>\n<p>15.妙用函数指针数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">#define DF(N) void N() &#123;\\ </span><br><span class=\"line\">    cout &lt;&lt; &quot;function &quot; #N &quot; called ... &quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DF(a); DF(b); DF(c); DF(d); DF(e); DF(f); DF(g);</span><br><span class=\"line\"></span><br><span class=\"line\">void (*func_table[])() = &#123;a, b, c, d, e, f, g&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    while(1) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;press a key from &apos;a&apos; to &apos;g&apos;&quot;</span><br><span class=\"line\">            &quot;or q to quit&quot; &lt;&lt; endl;</span><br><span class=\"line\">        char c, cr;</span><br><span class=\"line\">        cin.get(c); cin.get(cr);</span><br><span class=\"line\">        if (c == &apos;q&apos;)</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        if (c &lt; &apos;a&apos; || c &gt; &apos;g&apos;)</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        (*func_table[c - &apos;a&apos;])();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost CPPDemo]# ./fun_ptr_table </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">b</span><br><span class=\"line\">function b called ... </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">c</span><br><span class=\"line\">function c called ... </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">q</span><br></pre></td></tr></table></figure>\n<p>16.C++允许将任何类型的指针赋值给void *，但不允许指针赋给任何其他类型的指针。</p>\n<p>17.C++中的访问控制</p>\n<table>\n<thead>\n<tr>\n<th>public</th>\n<th>在其后声明的所有成员可以被所有的人访问</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>private</td>\n<td>private关键字意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>继承的结构可以访问protected成员，但不能访问private成员</td>\n</tr>\n</tbody>\n</table>\n<p>18.访问控制为类的创建者提供了很有价值的控制。类的客户程序员可以清楚的看到，什么可以用，什么应该忽略。更重要的是，它保证了使用类的客户程序员不会依赖类的实现细节，这样类库的开发者更改某些实现客户程序员不会因此受到影响。</p>\n<p>19.构造函数执行原理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class X &#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tX();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void f() &#123;</span><br><span class=\"line\">    X a;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当程序执行到a的序列点执行的点时，构造函数自动被调用，编译器悄悄的在a的定义点处拆入了一个X::X()的调用。就像其他成员函数被调用一样，传递到构造函数的第一个(秘密)参数是this指针，也就是调用这一个函数对象的内存地址，不过，对构造函数来说，this指针指向一个没有被初始化的内存块，构造函数的作用就是正确初始化该内存块</p>\n<p>20.当对象超出它的作用域的时候，编译器将自动调用析构函数。</p>\n<p>21.C++中禁止用返回值重载函数</p>\n<p>22.在C++中，struct和class唯一的不同之处在于，struct默认为public，而class默认为private。自然的，也可以让struct有构造啊函数和析构函数。另外，一个union（联合）也可以带有构造函数、析构函数、成员函数甚至访问控制。</p>\n<p>23.只有参数列表的后部参数才是可默认的；一旦在一个函数调用中开始使用默认参数，那么这个参数后面所有参数都必须是默认的。</p>\n<p>24.占位符参数:函数声明时，参数可以没有标识符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void f(int x, int, float flt);</span><br></pre></td></tr></table></figure>\n<p>如果开始用了一个函数参数，而后来发现不需要用它，可以将它去掉而不会产生警告错误，而且不需要改动那些调用该函数以前版本的程序代码。</p>\n<p>25.不能把默认参数作为一个标志去决定执行函数的哪一块，这是基本原则。在这种情况下，只要能够，就应该把函数分解成两个或多个重载的函数。</p>\n<p>26.关于const和指针</p>\n<p>u是一个指针，它指向一个const int，它所指的内容是不能被改变的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int* u;</span><br></pre></td></tr></table></figure>\n<p>w是一个指针，这个指针是指向int的const指针，指针本身不可改变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int d = 1;</span><br><span class=\"line\">int* const w = &amp;d;</span><br></pre></td></tr></table></figure>\n<p>指针的对象都不能改变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int d = 1;</span><br><span class=\"line\">const int* const x = &amp;d</span><br></pre></td></tr></table></figure>\n"},{"title":"CMU-Intro-to-Database-Systems-02-notes","date":"2019-03-25T08:27:05.000Z","_content":"\n","source":"_posts/CMU-Intro-to-Database-Systems-02-notes.md","raw":"---\ntitle: CMU-Intro-to-Database-Systems-02-notes\ndate: 2019-03-25 16:27:05\ntags:\n---\n\n","slug":"CMU-Intro-to-Database-Systems-02-notes","published":1,"updated":"2019-03-25T08:27:33.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw160004no3y9hekq1bo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"CMU-Intro-to-Database-Systems-03-notes","date":"2019-03-25T08:27:43.000Z","_content":"\n**存储器架构**\n\n![StorageHierarchy](CMU-Intro-to-Database-Systems-03-notes/StorageHierarchy.png)\n\n- 存储器根据其存储特性可以分为多层，上层存储器容量小，运行速度快。\n- 寄存器，CPU缓存，DRAM是易失性存储，一旦断电，存储数据将丢失。\n- SSD，HDD等是非易失性存储，断电数据仍然保留。\n\n- Non-Volatile Memory(NVM) 是位于分界线上的一种存储，它有着比SSD更高的性能，并能提供持久化存储。\n\n**访问这些存储器的时延**\n\n![ACCESSTIMES](CMU-Intro-to-Database-Systems-03-notes/ACCESSTIMES.png)\n\n**数据库设计的目标**\n\n- 允许DBMS去管理超过可用内存大小的存储量。\n- 读写磁盘的开销是很大的，所以必须要谨慎管理磁盘，避免出现性能下降。\n\n**顺序和随机访问的区别**\n\n- 随机访问HDD要比顺序访问慢很多。\n- 传统的数据库管理系统都是以最大化顺序访问为准则的。\n- 算法尝试减少写入随机页面的次数，将数据存在连续的块中。\n\n**mmap**\n\n- 可以使用mmap映射一个文件的内容到一个进程的地址空间\n- 操作系统的责任是将文件的页换入换出内存\n\n![mmap1](CMU-Intro-to-Database-Systems-03-notes/mmap1.png)\n\n![mmap2](CMU-Intro-to-Database-Systems-03-notes/mmap2.png)\n\n**为什么不使用操作系统的调用管理文件？**\n\n![mmap3](CMU-Intro-to-Database-Systems-03-notes/mmap3.png)\n\n![mmap4](CMU-Intro-to-Database-Systems-03-notes/mmap4.png)\n\n![mmap5](CMU-Intro-to-Database-Systems-03-notes/mmap5.png)\n\n- 如果我们允许多个线程访问mmap文件去隐藏缺页错误呢？\n- 这对只读的请求是正常工作的，但是当面对多个写请求的时候情况就复杂了。\n\n- madvise：告诉操作系统，你期待怎么样去读某些页面？\n- mlock：告诉操作系统一定范围内的内存不能被还出\n- msync：告诉操作系统把内存的一定范围页面刷如磁盘\n\n****\n\n**DBMS做的一些事情**\n\n- 以正确的顺序将脏页面写回磁盘\n- 专业的预读\n- 缓冲区的替换策略\n- 线程/进程调度\n\n**DBMS关注的两个问题**\n\n- DBMS如何在磁盘文件中表示数据库？\n- DBMS如何管理内存和磁盘之间来回的移动数据？\n\n**文件存储**\n\n- DBMS在一个或者多个磁盘文件中存储数据\n\n- 存储管理器(storage manager)的责任是管理数据库文件，它将文件组织成页集合的形式，跟踪读写到页面的数据，跟踪可用的存储空间\n\n**数据库页面**\n\n- 一个页面是固定大小的数据块，它可以包括元组(tuples)，元数据(meta-data)，索引(indexes)，日志记录(log records)\n- 大多数系统不回混合页面类型\n- 有些系统需要一个独立的页面\n- 每个页面都有一个唯一的标识符，DBMS使用一个间接层将页ID映射到实际的物理存储位置\n- 对于数据库系统中的页，有三种不同的概念：硬件页(Hardware Page)通常是4KB；操作系统页(OS Page)通常是4KB；数据库页面(Database Page)1-16KB\n\n**常见数据库页面大小**\n\n![pages](CMU-Intro-to-Database-Systems-03-notes/pages.png)\n\n**页面存储架构**\n\n- 不同的DBMSs用不同的方式管理磁盘上面的页\n  - 堆文件组织(Heap File Organization)\n  - 顺序/排序文件组织(Sequential/Sorted File Organization)\n  - 哈希文件组织(Hash File Organization)\n\n**数据库Heap**\n\n- 堆文件(Heap file)是无序的页面集合，其中是按随机顺序存储的元组。作用：获取/删除页面；必须支持对所有页面进行迭代。\n\n- 需要元数据来跟踪存在的页面，以及哪些有空闲的空间\n\n- Heap file的形式有两种: LinkedList和Page Directory\n\n**LINKED LIST结构Heap file 特点**\n\n![PageLinkList](CMU-Intro-to-Database-Systems-03-notes/PageLinkList.png)\n\n- 在文件开头存储了两个指针：空闲页list的头指针；数据页list的头指针\n- 每一页都跟踪它自己空闲slots的序号\n\n![DirPages](CMU-Intro-to-Database-Systems-03-notes/DirPages.png)\n\n- DBMS维护了一个特殊的页面来跟踪数据页的位置在数据库文件中\n- 这个目录也记录了每个页面空闲slot序号\n- DBMS确保目录页与数据页同步\n\n**页面头部**\n\n![page_header](CMU-Intro-to-Database-Systems-03-notes/page_header.png)\n\n- 每个页面都包含一个头部，里面包含了页面的元数据信息\n  - 页面大小\n  - 校验和\n  - DBMS的版本\n  - 事务的可见性\n  - 压缩信息\n- 有些系统需要页面变得独立，比如Oracle\n\n**页面的布局**\n\n- 对于任何页面存储架构来说，我们现在需要知道怎样在页面里面组织数据存储\n- 两种方法：\n  - 面向元组\n  - 日志结构\n\n**元组的存储**\n\n- 记录页面中远足的数量，然后往尾部增加新的元组\n\n![tuple1](CMU-Intro-to-Database-Systems-03-notes/tuple1.png)\n\n![tuple2](CMU-Intro-to-Database-Systems-03-notes/tuple2.png)\n\n![tuple3](CMU-Intro-to-Database-Systems-03-notes/tuple3.png)\n\n![tuple4](CMU-Intro-to-Database-Systems-03-notes/tuple4.png)\n\n**页面槽(Slotted pages)**\n\n- 最常见的页面部署方案称为槽页(slotted pages)\n- slot数组映射了slots到元组开始位置的偏移量、\n- header存储了使用了的slots，最后一个被使用slot的起始位置\n\n![slot-page1](CMU-Intro-to-Database-Systems-03-notes/slot-page1.png)\n\n![slot-page2](CMU-Intro-to-Database-Systems-03-notes/slot-page2.png)\n\n**日志文件型数据组织方式**\n\n![log1](CMU-Intro-to-Database-Systems-03-notes/log1.png)\n\n- DBMS只存储日志记录，而不是将元组存储在页面中\n- 系统将数据库如何修改的日志追加到文件\n  - 插入存储整个元组\n  - 将元组标记为已删除\n  - 更新属性包含被修改的增量\n\n![log2](CMU-Intro-to-Database-Systems-03-notes/log2.png)\n\n- 要读取记录，DBMS反向记录并重新创建元组，并找到它需要的东西\n- 建立索引允许跳到log的指定位置\n- 定期的压缩日志\n\n![log3](CMU-Intro-to-Database-Systems-03-notes/log3.png)\n\n**日志的压缩**\n\n- 通过删除不必要的记录来将较大的日志文件合并成较小的文件\n\n- compaction的过程\n\n![compaction1](CMU-Intro-to-Database-Systems-03-notes/compaction1.png)\n\n![compaction2](CMU-Intro-to-Database-Systems-03-notes/compaction2.png)\n\n![compaction3](CMU-Intro-to-Database-Systems-03-notes/compaction3.png)\n\n![compaction4](CMU-Intro-to-Database-Systems-03-notes/compaction4.png)\n\n![compaction5](CMU-Intro-to-Database-Systems-03-notes/compaction5.png)\n\n![compaction6](CMU-Intro-to-Database-Systems-03-notes/compaction6.png)\n\n![compaction7](CMU-Intro-to-Database-Systems-03-notes/compaction7.png)\n\n**元组布局**\n\n- 元组本质上是一个字节序列\n- DBMS的工作就是解释这些字节属性类型和值\n\n![tuple-header](CMU-Intro-to-Database-Systems-03-notes/tuple-header.png)\n\n- 每个元组前面都有一个头包含有关它的元数据：可见性信息（用于并发控制）；为NULL值提供的BitMap\n- 我们为什么不需要存储schema的元数据信息呢？\n- 元组里面的数据按你创建表时候的命令组织\n- 组织这些数据是软件工程师要做的事情\n\n![tuple-data](CMU-Intro-to-Database-Systems-03-notes/tuple-data.png)\n\n**非规范化元组数据(denormalized tuple data)**\n\n- 可以在物理上取消规范化相关元组并存储它们在同一页中\n  - 可以减少常见工作负载的I/O请求数量\n  - 可以使得update操作更高效\n\n![denormalized1](CMU-Intro-to-Database-Systems-03-notes/denormalized1.png)\n\n![denormalized2](CMU-Intro-to-Database-Systems-03-notes/denormalized2.png)\n\n![denormalized3](CMU-Intro-to-Database-Systems-03-notes/denormalized3.png)\n\n**记录的ID**\n\n- DBMS需要一种跟踪单个元组的方法\n- 每个元组都被分配一个唯一的记录标识符\n  - 最常见：page_id + offset/slot\n  - 也可以包含文件的位置信息\n\n![record-ids](CMU-Intro-to-Database-Systems-03-notes/record-ids.png)\n\n","source":"_posts/CMU-Intro-to-Database-Systems-03-notes.md","raw":"---\ntitle: CMU-Intro-to-Database-Systems-03-notes\ndate: 2019-03-25 16:27:43\ntags:\n---\n\n**存储器架构**\n\n![StorageHierarchy](CMU-Intro-to-Database-Systems-03-notes/StorageHierarchy.png)\n\n- 存储器根据其存储特性可以分为多层，上层存储器容量小，运行速度快。\n- 寄存器，CPU缓存，DRAM是易失性存储，一旦断电，存储数据将丢失。\n- SSD，HDD等是非易失性存储，断电数据仍然保留。\n\n- Non-Volatile Memory(NVM) 是位于分界线上的一种存储，它有着比SSD更高的性能，并能提供持久化存储。\n\n**访问这些存储器的时延**\n\n![ACCESSTIMES](CMU-Intro-to-Database-Systems-03-notes/ACCESSTIMES.png)\n\n**数据库设计的目标**\n\n- 允许DBMS去管理超过可用内存大小的存储量。\n- 读写磁盘的开销是很大的，所以必须要谨慎管理磁盘，避免出现性能下降。\n\n**顺序和随机访问的区别**\n\n- 随机访问HDD要比顺序访问慢很多。\n- 传统的数据库管理系统都是以最大化顺序访问为准则的。\n- 算法尝试减少写入随机页面的次数，将数据存在连续的块中。\n\n**mmap**\n\n- 可以使用mmap映射一个文件的内容到一个进程的地址空间\n- 操作系统的责任是将文件的页换入换出内存\n\n![mmap1](CMU-Intro-to-Database-Systems-03-notes/mmap1.png)\n\n![mmap2](CMU-Intro-to-Database-Systems-03-notes/mmap2.png)\n\n**为什么不使用操作系统的调用管理文件？**\n\n![mmap3](CMU-Intro-to-Database-Systems-03-notes/mmap3.png)\n\n![mmap4](CMU-Intro-to-Database-Systems-03-notes/mmap4.png)\n\n![mmap5](CMU-Intro-to-Database-Systems-03-notes/mmap5.png)\n\n- 如果我们允许多个线程访问mmap文件去隐藏缺页错误呢？\n- 这对只读的请求是正常工作的，但是当面对多个写请求的时候情况就复杂了。\n\n- madvise：告诉操作系统，你期待怎么样去读某些页面？\n- mlock：告诉操作系统一定范围内的内存不能被还出\n- msync：告诉操作系统把内存的一定范围页面刷如磁盘\n\n****\n\n**DBMS做的一些事情**\n\n- 以正确的顺序将脏页面写回磁盘\n- 专业的预读\n- 缓冲区的替换策略\n- 线程/进程调度\n\n**DBMS关注的两个问题**\n\n- DBMS如何在磁盘文件中表示数据库？\n- DBMS如何管理内存和磁盘之间来回的移动数据？\n\n**文件存储**\n\n- DBMS在一个或者多个磁盘文件中存储数据\n\n- 存储管理器(storage manager)的责任是管理数据库文件，它将文件组织成页集合的形式，跟踪读写到页面的数据，跟踪可用的存储空间\n\n**数据库页面**\n\n- 一个页面是固定大小的数据块，它可以包括元组(tuples)，元数据(meta-data)，索引(indexes)，日志记录(log records)\n- 大多数系统不回混合页面类型\n- 有些系统需要一个独立的页面\n- 每个页面都有一个唯一的标识符，DBMS使用一个间接层将页ID映射到实际的物理存储位置\n- 对于数据库系统中的页，有三种不同的概念：硬件页(Hardware Page)通常是4KB；操作系统页(OS Page)通常是4KB；数据库页面(Database Page)1-16KB\n\n**常见数据库页面大小**\n\n![pages](CMU-Intro-to-Database-Systems-03-notes/pages.png)\n\n**页面存储架构**\n\n- 不同的DBMSs用不同的方式管理磁盘上面的页\n  - 堆文件组织(Heap File Organization)\n  - 顺序/排序文件组织(Sequential/Sorted File Organization)\n  - 哈希文件组织(Hash File Organization)\n\n**数据库Heap**\n\n- 堆文件(Heap file)是无序的页面集合，其中是按随机顺序存储的元组。作用：获取/删除页面；必须支持对所有页面进行迭代。\n\n- 需要元数据来跟踪存在的页面，以及哪些有空闲的空间\n\n- Heap file的形式有两种: LinkedList和Page Directory\n\n**LINKED LIST结构Heap file 特点**\n\n![PageLinkList](CMU-Intro-to-Database-Systems-03-notes/PageLinkList.png)\n\n- 在文件开头存储了两个指针：空闲页list的头指针；数据页list的头指针\n- 每一页都跟踪它自己空闲slots的序号\n\n![DirPages](CMU-Intro-to-Database-Systems-03-notes/DirPages.png)\n\n- DBMS维护了一个特殊的页面来跟踪数据页的位置在数据库文件中\n- 这个目录也记录了每个页面空闲slot序号\n- DBMS确保目录页与数据页同步\n\n**页面头部**\n\n![page_header](CMU-Intro-to-Database-Systems-03-notes/page_header.png)\n\n- 每个页面都包含一个头部，里面包含了页面的元数据信息\n  - 页面大小\n  - 校验和\n  - DBMS的版本\n  - 事务的可见性\n  - 压缩信息\n- 有些系统需要页面变得独立，比如Oracle\n\n**页面的布局**\n\n- 对于任何页面存储架构来说，我们现在需要知道怎样在页面里面组织数据存储\n- 两种方法：\n  - 面向元组\n  - 日志结构\n\n**元组的存储**\n\n- 记录页面中远足的数量，然后往尾部增加新的元组\n\n![tuple1](CMU-Intro-to-Database-Systems-03-notes/tuple1.png)\n\n![tuple2](CMU-Intro-to-Database-Systems-03-notes/tuple2.png)\n\n![tuple3](CMU-Intro-to-Database-Systems-03-notes/tuple3.png)\n\n![tuple4](CMU-Intro-to-Database-Systems-03-notes/tuple4.png)\n\n**页面槽(Slotted pages)**\n\n- 最常见的页面部署方案称为槽页(slotted pages)\n- slot数组映射了slots到元组开始位置的偏移量、\n- header存储了使用了的slots，最后一个被使用slot的起始位置\n\n![slot-page1](CMU-Intro-to-Database-Systems-03-notes/slot-page1.png)\n\n![slot-page2](CMU-Intro-to-Database-Systems-03-notes/slot-page2.png)\n\n**日志文件型数据组织方式**\n\n![log1](CMU-Intro-to-Database-Systems-03-notes/log1.png)\n\n- DBMS只存储日志记录，而不是将元组存储在页面中\n- 系统将数据库如何修改的日志追加到文件\n  - 插入存储整个元组\n  - 将元组标记为已删除\n  - 更新属性包含被修改的增量\n\n![log2](CMU-Intro-to-Database-Systems-03-notes/log2.png)\n\n- 要读取记录，DBMS反向记录并重新创建元组，并找到它需要的东西\n- 建立索引允许跳到log的指定位置\n- 定期的压缩日志\n\n![log3](CMU-Intro-to-Database-Systems-03-notes/log3.png)\n\n**日志的压缩**\n\n- 通过删除不必要的记录来将较大的日志文件合并成较小的文件\n\n- compaction的过程\n\n![compaction1](CMU-Intro-to-Database-Systems-03-notes/compaction1.png)\n\n![compaction2](CMU-Intro-to-Database-Systems-03-notes/compaction2.png)\n\n![compaction3](CMU-Intro-to-Database-Systems-03-notes/compaction3.png)\n\n![compaction4](CMU-Intro-to-Database-Systems-03-notes/compaction4.png)\n\n![compaction5](CMU-Intro-to-Database-Systems-03-notes/compaction5.png)\n\n![compaction6](CMU-Intro-to-Database-Systems-03-notes/compaction6.png)\n\n![compaction7](CMU-Intro-to-Database-Systems-03-notes/compaction7.png)\n\n**元组布局**\n\n- 元组本质上是一个字节序列\n- DBMS的工作就是解释这些字节属性类型和值\n\n![tuple-header](CMU-Intro-to-Database-Systems-03-notes/tuple-header.png)\n\n- 每个元组前面都有一个头包含有关它的元数据：可见性信息（用于并发控制）；为NULL值提供的BitMap\n- 我们为什么不需要存储schema的元数据信息呢？\n- 元组里面的数据按你创建表时候的命令组织\n- 组织这些数据是软件工程师要做的事情\n\n![tuple-data](CMU-Intro-to-Database-Systems-03-notes/tuple-data.png)\n\n**非规范化元组数据(denormalized tuple data)**\n\n- 可以在物理上取消规范化相关元组并存储它们在同一页中\n  - 可以减少常见工作负载的I/O请求数量\n  - 可以使得update操作更高效\n\n![denormalized1](CMU-Intro-to-Database-Systems-03-notes/denormalized1.png)\n\n![denormalized2](CMU-Intro-to-Database-Systems-03-notes/denormalized2.png)\n\n![denormalized3](CMU-Intro-to-Database-Systems-03-notes/denormalized3.png)\n\n**记录的ID**\n\n- DBMS需要一种跟踪单个元组的方法\n- 每个元组都被分配一个唯一的记录标识符\n  - 最常见：page_id + offset/slot\n  - 也可以包含文件的位置信息\n\n![record-ids](CMU-Intro-to-Database-Systems-03-notes/record-ids.png)\n\n","slug":"CMU-Intro-to-Database-Systems-03-notes","published":1,"updated":"2019-03-28T08:19:49.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw1c0006no3y6kn18m2h","content":"<p><strong>存储器架构</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/StorageHierarchy.png\" alt=\"StorageHierarchy\"></p>\n<ul>\n<li>存储器根据其存储特性可以分为多层，上层存储器容量小，运行速度快。</li>\n<li>寄存器，CPU缓存，DRAM是易失性存储，一旦断电，存储数据将丢失。</li>\n<li><p>SSD，HDD等是非易失性存储，断电数据仍然保留。</p>\n</li>\n<li><p>Non-Volatile Memory(NVM) 是位于分界线上的一种存储，它有着比SSD更高的性能，并能提供持久化存储。</p>\n</li>\n</ul>\n<p><strong>访问这些存储器的时延</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/ACCESSTIMES.png\" alt=\"ACCESSTIMES\"></p>\n<p><strong>数据库设计的目标</strong></p>\n<ul>\n<li>允许DBMS去管理超过可用内存大小的存储量。</li>\n<li>读写磁盘的开销是很大的，所以必须要谨慎管理磁盘，避免出现性能下降。</li>\n</ul>\n<p><strong>顺序和随机访问的区别</strong></p>\n<ul>\n<li>随机访问HDD要比顺序访问慢很多。</li>\n<li>传统的数据库管理系统都是以最大化顺序访问为准则的。</li>\n<li>算法尝试减少写入随机页面的次数，将数据存在连续的块中。</li>\n</ul>\n<p><strong>mmap</strong></p>\n<ul>\n<li>可以使用mmap映射一个文件的内容到一个进程的地址空间</li>\n<li>操作系统的责任是将文件的页换入换出内存</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap1.png\" alt=\"mmap1\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap2.png\" alt=\"mmap2\"></p>\n<p><strong>为什么不使用操作系统的调用管理文件？</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap3.png\" alt=\"mmap3\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap4.png\" alt=\"mmap4\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap5.png\" alt=\"mmap5\"></p>\n<ul>\n<li>如果我们允许多个线程访问mmap文件去隐藏缺页错误呢？</li>\n<li><p>这对只读的请求是正常工作的，但是当面对多个写请求的时候情况就复杂了。</p>\n</li>\n<li><p>madvise：告诉操作系统，你期待怎么样去读某些页面？</p>\n</li>\n<li>mlock：告诉操作系统一定范围内的内存不能被还出</li>\n<li>msync：告诉操作系统把内存的一定范围页面刷如磁盘</li>\n</ul>\n<hr>\n<p><strong>DBMS做的一些事情</strong></p>\n<ul>\n<li>以正确的顺序将脏页面写回磁盘</li>\n<li>专业的预读</li>\n<li>缓冲区的替换策略</li>\n<li>线程/进程调度</li>\n</ul>\n<p><strong>DBMS关注的两个问题</strong></p>\n<ul>\n<li>DBMS如何在磁盘文件中表示数据库？</li>\n<li>DBMS如何管理内存和磁盘之间来回的移动数据？</li>\n</ul>\n<p><strong>文件存储</strong></p>\n<ul>\n<li><p>DBMS在一个或者多个磁盘文件中存储数据</p>\n</li>\n<li><p>存储管理器(storage manager)的责任是管理数据库文件，它将文件组织成页集合的形式，跟踪读写到页面的数据，跟踪可用的存储空间</p>\n</li>\n</ul>\n<p><strong>数据库页面</strong></p>\n<ul>\n<li>一个页面是固定大小的数据块，它可以包括元组(tuples)，元数据(meta-data)，索引(indexes)，日志记录(log records)</li>\n<li>大多数系统不回混合页面类型</li>\n<li>有些系统需要一个独立的页面</li>\n<li>每个页面都有一个唯一的标识符，DBMS使用一个间接层将页ID映射到实际的物理存储位置</li>\n<li>对于数据库系统中的页，有三种不同的概念：硬件页(Hardware Page)通常是4KB；操作系统页(OS Page)通常是4KB；数据库页面(Database Page)1-16KB</li>\n</ul>\n<p><strong>常见数据库页面大小</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/pages.png\" alt=\"pages\"></p>\n<p><strong>页面存储架构</strong></p>\n<ul>\n<li>不同的DBMSs用不同的方式管理磁盘上面的页<ul>\n<li>堆文件组织(Heap File Organization)</li>\n<li>顺序/排序文件组织(Sequential/Sorted File Organization)</li>\n<li>哈希文件组织(Hash File Organization)</li>\n</ul>\n</li>\n</ul>\n<p><strong>数据库Heap</strong></p>\n<ul>\n<li><p>堆文件(Heap file)是无序的页面集合，其中是按随机顺序存储的元组。作用：获取/删除页面；必须支持对所有页面进行迭代。</p>\n</li>\n<li><p>需要元数据来跟踪存在的页面，以及哪些有空闲的空间</p>\n</li>\n<li><p>Heap file的形式有两种: LinkedList和Page Directory</p>\n</li>\n</ul>\n<p><strong>LINKED LIST结构Heap file 特点</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/PageLinkList.png\" alt=\"PageLinkList\"></p>\n<ul>\n<li>在文件开头存储了两个指针：空闲页list的头指针；数据页list的头指针</li>\n<li>每一页都跟踪它自己空闲slots的序号</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/DirPages.png\" alt=\"DirPages\"></p>\n<ul>\n<li>DBMS维护了一个特殊的页面来跟踪数据页的位置在数据库文件中</li>\n<li>这个目录也记录了每个页面空闲slot序号</li>\n<li>DBMS确保目录页与数据页同步</li>\n</ul>\n<p><strong>页面头部</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/page_header.png\" alt=\"page_header\"></p>\n<ul>\n<li>每个页面都包含一个头部，里面包含了页面的元数据信息<ul>\n<li>页面大小</li>\n<li>校验和</li>\n<li>DBMS的版本</li>\n<li>事务的可见性</li>\n<li>压缩信息</li>\n</ul>\n</li>\n<li>有些系统需要页面变得独立，比如Oracle</li>\n</ul>\n<p><strong>页面的布局</strong></p>\n<ul>\n<li>对于任何页面存储架构来说，我们现在需要知道怎样在页面里面组织数据存储</li>\n<li>两种方法：<ul>\n<li>面向元组</li>\n<li>日志结构</li>\n</ul>\n</li>\n</ul>\n<p><strong>元组的存储</strong></p>\n<ul>\n<li>记录页面中远足的数量，然后往尾部增加新的元组</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple1.png\" alt=\"tuple1\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple2.png\" alt=\"tuple2\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple3.png\" alt=\"tuple3\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple4.png\" alt=\"tuple4\"></p>\n<p><strong>页面槽(Slotted pages)</strong></p>\n<ul>\n<li>最常见的页面部署方案称为槽页(slotted pages)</li>\n<li>slot数组映射了slots到元组开始位置的偏移量、</li>\n<li>header存储了使用了的slots，最后一个被使用slot的起始位置</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/slot-page1.png\" alt=\"slot-page1\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/slot-page2.png\" alt=\"slot-page2\"></p>\n<p><strong>日志文件型数据组织方式</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/log1.png\" alt=\"log1\"></p>\n<ul>\n<li>DBMS只存储日志记录，而不是将元组存储在页面中</li>\n<li>系统将数据库如何修改的日志追加到文件<ul>\n<li>插入存储整个元组</li>\n<li>将元组标记为已删除</li>\n<li>更新属性包含被修改的增量</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/log2.png\" alt=\"log2\"></p>\n<ul>\n<li>要读取记录，DBMS反向记录并重新创建元组，并找到它需要的东西</li>\n<li>建立索引允许跳到log的指定位置</li>\n<li>定期的压缩日志</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/log3.png\" alt=\"log3\"></p>\n<p><strong>日志的压缩</strong></p>\n<ul>\n<li><p>通过删除不必要的记录来将较大的日志文件合并成较小的文件</p>\n</li>\n<li><p>compaction的过程</p>\n</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction1.png\" alt=\"compaction1\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction2.png\" alt=\"compaction2\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction3.png\" alt=\"compaction3\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction4.png\" alt=\"compaction4\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction5.png\" alt=\"compaction5\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction6.png\" alt=\"compaction6\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction7.png\" alt=\"compaction7\"></p>\n<p><strong>元组布局</strong></p>\n<ul>\n<li>元组本质上是一个字节序列</li>\n<li>DBMS的工作就是解释这些字节属性类型和值</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple-header.png\" alt=\"tuple-header\"></p>\n<ul>\n<li>每个元组前面都有一个头包含有关它的元数据：可见性信息（用于并发控制）；为NULL值提供的BitMap</li>\n<li>我们为什么不需要存储schema的元数据信息呢？</li>\n<li>元组里面的数据按你创建表时候的命令组织</li>\n<li>组织这些数据是软件工程师要做的事情</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple-data.png\" alt=\"tuple-data\"></p>\n<p><strong>非规范化元组数据(denormalized tuple data)</strong></p>\n<ul>\n<li>可以在物理上取消规范化相关元组并存储它们在同一页中<ul>\n<li>可以减少常见工作负载的I/O请求数量</li>\n<li>可以使得update操作更高效</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/denormalized1.png\" alt=\"denormalized1\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/denormalized2.png\" alt=\"denormalized2\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/denormalized3.png\" alt=\"denormalized3\"></p>\n<p><strong>记录的ID</strong></p>\n<ul>\n<li>DBMS需要一种跟踪单个元组的方法</li>\n<li>每个元组都被分配一个唯一的记录标识符<ul>\n<li>最常见：page_id + offset/slot</li>\n<li>也可以包含文件的位置信息</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/record-ids.png\" alt=\"record-ids\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>存储器架构</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/StorageHierarchy.png\" alt=\"StorageHierarchy\"></p>\n<ul>\n<li>存储器根据其存储特性可以分为多层，上层存储器容量小，运行速度快。</li>\n<li>寄存器，CPU缓存，DRAM是易失性存储，一旦断电，存储数据将丢失。</li>\n<li><p>SSD，HDD等是非易失性存储，断电数据仍然保留。</p>\n</li>\n<li><p>Non-Volatile Memory(NVM) 是位于分界线上的一种存储，它有着比SSD更高的性能，并能提供持久化存储。</p>\n</li>\n</ul>\n<p><strong>访问这些存储器的时延</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/ACCESSTIMES.png\" alt=\"ACCESSTIMES\"></p>\n<p><strong>数据库设计的目标</strong></p>\n<ul>\n<li>允许DBMS去管理超过可用内存大小的存储量。</li>\n<li>读写磁盘的开销是很大的，所以必须要谨慎管理磁盘，避免出现性能下降。</li>\n</ul>\n<p><strong>顺序和随机访问的区别</strong></p>\n<ul>\n<li>随机访问HDD要比顺序访问慢很多。</li>\n<li>传统的数据库管理系统都是以最大化顺序访问为准则的。</li>\n<li>算法尝试减少写入随机页面的次数，将数据存在连续的块中。</li>\n</ul>\n<p><strong>mmap</strong></p>\n<ul>\n<li>可以使用mmap映射一个文件的内容到一个进程的地址空间</li>\n<li>操作系统的责任是将文件的页换入换出内存</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap1.png\" alt=\"mmap1\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap2.png\" alt=\"mmap2\"></p>\n<p><strong>为什么不使用操作系统的调用管理文件？</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap3.png\" alt=\"mmap3\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap4.png\" alt=\"mmap4\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/mmap5.png\" alt=\"mmap5\"></p>\n<ul>\n<li>如果我们允许多个线程访问mmap文件去隐藏缺页错误呢？</li>\n<li><p>这对只读的请求是正常工作的，但是当面对多个写请求的时候情况就复杂了。</p>\n</li>\n<li><p>madvise：告诉操作系统，你期待怎么样去读某些页面？</p>\n</li>\n<li>mlock：告诉操作系统一定范围内的内存不能被还出</li>\n<li>msync：告诉操作系统把内存的一定范围页面刷如磁盘</li>\n</ul>\n<hr>\n<p><strong>DBMS做的一些事情</strong></p>\n<ul>\n<li>以正确的顺序将脏页面写回磁盘</li>\n<li>专业的预读</li>\n<li>缓冲区的替换策略</li>\n<li>线程/进程调度</li>\n</ul>\n<p><strong>DBMS关注的两个问题</strong></p>\n<ul>\n<li>DBMS如何在磁盘文件中表示数据库？</li>\n<li>DBMS如何管理内存和磁盘之间来回的移动数据？</li>\n</ul>\n<p><strong>文件存储</strong></p>\n<ul>\n<li><p>DBMS在一个或者多个磁盘文件中存储数据</p>\n</li>\n<li><p>存储管理器(storage manager)的责任是管理数据库文件，它将文件组织成页集合的形式，跟踪读写到页面的数据，跟踪可用的存储空间</p>\n</li>\n</ul>\n<p><strong>数据库页面</strong></p>\n<ul>\n<li>一个页面是固定大小的数据块，它可以包括元组(tuples)，元数据(meta-data)，索引(indexes)，日志记录(log records)</li>\n<li>大多数系统不回混合页面类型</li>\n<li>有些系统需要一个独立的页面</li>\n<li>每个页面都有一个唯一的标识符，DBMS使用一个间接层将页ID映射到实际的物理存储位置</li>\n<li>对于数据库系统中的页，有三种不同的概念：硬件页(Hardware Page)通常是4KB；操作系统页(OS Page)通常是4KB；数据库页面(Database Page)1-16KB</li>\n</ul>\n<p><strong>常见数据库页面大小</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/pages.png\" alt=\"pages\"></p>\n<p><strong>页面存储架构</strong></p>\n<ul>\n<li>不同的DBMSs用不同的方式管理磁盘上面的页<ul>\n<li>堆文件组织(Heap File Organization)</li>\n<li>顺序/排序文件组织(Sequential/Sorted File Organization)</li>\n<li>哈希文件组织(Hash File Organization)</li>\n</ul>\n</li>\n</ul>\n<p><strong>数据库Heap</strong></p>\n<ul>\n<li><p>堆文件(Heap file)是无序的页面集合，其中是按随机顺序存储的元组。作用：获取/删除页面；必须支持对所有页面进行迭代。</p>\n</li>\n<li><p>需要元数据来跟踪存在的页面，以及哪些有空闲的空间</p>\n</li>\n<li><p>Heap file的形式有两种: LinkedList和Page Directory</p>\n</li>\n</ul>\n<p><strong>LINKED LIST结构Heap file 特点</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/PageLinkList.png\" alt=\"PageLinkList\"></p>\n<ul>\n<li>在文件开头存储了两个指针：空闲页list的头指针；数据页list的头指针</li>\n<li>每一页都跟踪它自己空闲slots的序号</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/DirPages.png\" alt=\"DirPages\"></p>\n<ul>\n<li>DBMS维护了一个特殊的页面来跟踪数据页的位置在数据库文件中</li>\n<li>这个目录也记录了每个页面空闲slot序号</li>\n<li>DBMS确保目录页与数据页同步</li>\n</ul>\n<p><strong>页面头部</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/page_header.png\" alt=\"page_header\"></p>\n<ul>\n<li>每个页面都包含一个头部，里面包含了页面的元数据信息<ul>\n<li>页面大小</li>\n<li>校验和</li>\n<li>DBMS的版本</li>\n<li>事务的可见性</li>\n<li>压缩信息</li>\n</ul>\n</li>\n<li>有些系统需要页面变得独立，比如Oracle</li>\n</ul>\n<p><strong>页面的布局</strong></p>\n<ul>\n<li>对于任何页面存储架构来说，我们现在需要知道怎样在页面里面组织数据存储</li>\n<li>两种方法：<ul>\n<li>面向元组</li>\n<li>日志结构</li>\n</ul>\n</li>\n</ul>\n<p><strong>元组的存储</strong></p>\n<ul>\n<li>记录页面中远足的数量，然后往尾部增加新的元组</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple1.png\" alt=\"tuple1\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple2.png\" alt=\"tuple2\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple3.png\" alt=\"tuple3\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple4.png\" alt=\"tuple4\"></p>\n<p><strong>页面槽(Slotted pages)</strong></p>\n<ul>\n<li>最常见的页面部署方案称为槽页(slotted pages)</li>\n<li>slot数组映射了slots到元组开始位置的偏移量、</li>\n<li>header存储了使用了的slots，最后一个被使用slot的起始位置</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/slot-page1.png\" alt=\"slot-page1\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/slot-page2.png\" alt=\"slot-page2\"></p>\n<p><strong>日志文件型数据组织方式</strong></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/log1.png\" alt=\"log1\"></p>\n<ul>\n<li>DBMS只存储日志记录，而不是将元组存储在页面中</li>\n<li>系统将数据库如何修改的日志追加到文件<ul>\n<li>插入存储整个元组</li>\n<li>将元组标记为已删除</li>\n<li>更新属性包含被修改的增量</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/log2.png\" alt=\"log2\"></p>\n<ul>\n<li>要读取记录，DBMS反向记录并重新创建元组，并找到它需要的东西</li>\n<li>建立索引允许跳到log的指定位置</li>\n<li>定期的压缩日志</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/log3.png\" alt=\"log3\"></p>\n<p><strong>日志的压缩</strong></p>\n<ul>\n<li><p>通过删除不必要的记录来将较大的日志文件合并成较小的文件</p>\n</li>\n<li><p>compaction的过程</p>\n</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction1.png\" alt=\"compaction1\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction2.png\" alt=\"compaction2\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction3.png\" alt=\"compaction3\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction4.png\" alt=\"compaction4\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction5.png\" alt=\"compaction5\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction6.png\" alt=\"compaction6\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/compaction7.png\" alt=\"compaction7\"></p>\n<p><strong>元组布局</strong></p>\n<ul>\n<li>元组本质上是一个字节序列</li>\n<li>DBMS的工作就是解释这些字节属性类型和值</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple-header.png\" alt=\"tuple-header\"></p>\n<ul>\n<li>每个元组前面都有一个头包含有关它的元数据：可见性信息（用于并发控制）；为NULL值提供的BitMap</li>\n<li>我们为什么不需要存储schema的元数据信息呢？</li>\n<li>元组里面的数据按你创建表时候的命令组织</li>\n<li>组织这些数据是软件工程师要做的事情</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/tuple-data.png\" alt=\"tuple-data\"></p>\n<p><strong>非规范化元组数据(denormalized tuple data)</strong></p>\n<ul>\n<li>可以在物理上取消规范化相关元组并存储它们在同一页中<ul>\n<li>可以减少常见工作负载的I/O请求数量</li>\n<li>可以使得update操作更高效</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/denormalized1.png\" alt=\"denormalized1\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/denormalized2.png\" alt=\"denormalized2\"></p>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/denormalized3.png\" alt=\"denormalized3\"></p>\n<p><strong>记录的ID</strong></p>\n<ul>\n<li>DBMS需要一种跟踪单个元组的方法</li>\n<li>每个元组都被分配一个唯一的记录标识符<ul>\n<li>最常见：page_id + offset/slot</li>\n<li>也可以包含文件的位置信息</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/03/25/CMU-Intro-to-Database-Systems-03-notes/record-ids.png\" alt=\"record-ids\"></p>\n"},{"title":"LEC1-vedio","date":"2019-01-16T14:03:56.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC1-vedio.md","raw":"---\ntitle: LEC1-vedio\ndate: 2019-01-16 22:03:56\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC1-vedio","published":1,"updated":"2019-01-17T04:53:18.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw1i0008no3y04gvxug8","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC1","date":"2019-01-15T15:03:03.000Z","_content":"\n**不敢确认的翻译给出了原文，避免误解**\n\n**什么是分布式系统**？\n\n1.多台主机合作\n\n2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的\n\n**为什么需要分布式**？\n\n1.连接物理上分离的实体\n\n2.通过隔离实现安全\n\n3.通过副本来实现容错\n\n4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量\n\n5.但是：\n\n1) 分布式系统具有复杂性，包括很多并发的部分\n\n2) 必须应对系统中部分部分失败\n\n3) 很难实现性能潜力\n\n**实验的目标**：\n\n1.更加深入的了解一些重要技术\n\n2.积累分布式系统的编程经验\n\n**主话题**\n\n1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用\n\n2.用来应用程序分布的复杂性\n\n1）三大抽象\n\n存储，交互，计算\n\n2）实现分布式系统的一些基础知识\n\nRPC，线程，并发控制\n\n3）分布式系统的性能\n\n**理想：可扩展的吞吐量**\n\n可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现\n\n所以可以通过购买更多的服务器来处理更多的负载\n\n**现实：扩展变得越来越困难**\n\n负载均衡，(stragglers)性能落后的机器\n\n很小的，不可以并行化的部分\n\n隐藏共享资源，比如网络\n\n分布式系统的容错性(fault tolerance)\n\n1000个服务器，复杂的网络连接，总是会出现一些问题\n我们想通过应用程序来隐藏(容忍)这些失败\n\n可用性：尽管失败，我仍然可以继续使用我的文件\n\n耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复\n\n一个好主意：使用副本服务器(replicated servers)\n\n如果一个服务宕机了，客户端可以选择使用其他的服务器\n\n**分布式系统的一致性**\n\n通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的\n\n1.客户端提交并行的操作\n2.服务器在尴尬的时候崩溃\n3.网络问题可能是服务器看起来像是死机了\n4.脑裂的风险(split brain)\n\n**一致性和性能是相对的**\n\n1.一致性需要交互\n2.具有令人满意(\"严格\")语以的系统通常很慢\n3.快速的系统通常可以使应用程序面对复杂的行为\n\n案例学习: MapReduce\n\n**MapReduce概述**\n\n1.Context: 对多个TB的数据集进行多个小时的计算\n\n例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的\n\n2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理\n\n3.程序员定义Map和Reduce函数的顺序代码，通常很简单\n\n4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节\n\n**MapReduce的抽象视图**\n\n输入(input)被分为M个文件\n\n[maps 生成多行 K-V对，reduces合并列]\n\n![MapReduce](LEC1/MapReduce.png)\n\nMR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。\n\nMR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 <k2, v3> 对，结果存储在R输出文件中\n\n[MapReduce API]\n\n![MapReduceApi](LEC1/MapReduceApi.png)\n\n**MapReduce隐藏了一些细节痛点**\n\n1.在服务器上启动 s/w\n\n2.跟踪哪些任务已经完成了\n\n3.数据移动\n\n4.任务失败后恢复\n\n**Mapreduce 具有很好的扩展性**\n\n1.用N台服务器可以获得Nx的吞吐量\n\n假设 M和R >= N （即：很多的输入文件和map输出的key）\n\nMaps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的\n\n唯一的交互是maps和reduces之间的 \"shuffle\"\n\n2.因此，你可以通过购买更多的服务器来获得更多的吞吐量\n\n而不是对每个应用程序做特殊，高效的并行化\n\n**限制性能的因素是什么？**\n\n1.我们关心这个因为这正是系统性能的优化点\nCPU? 内存? 磁盘? 网络？\n\n2.网络带宽的限制\n\n网络的内部总容量，通常远小于主机之间网络链路的速度总和\n\n难以建立一个比单台计算机运行速度快1000倍的网络\n\n所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动\n\n**容灾处理**\n\n如果有服务器在MR job过程中宕机怎么处理\n\n隐藏失败是实现模型简易编程一个大的部分\n\n为什么不从一开始就重启整个job\n\nMR过程只会重新运行失败的Map()和Reduce()\n\n它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果\n\nMR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要\n\n**更多的细节**\n\n1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片\n\n输入数据存在GFS中，每个分片存了3个副本\n\n2.所有的计算机同时运行GFS和MR workers\n\n3.输入分片数比workers数要多\n\n4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务\n\n5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘\n\n直到所有Maps操作结束后才会进行Reduce计算\n\n6.Master告诉Reducers从Map操作的workers那里获取中间数据分块\n\n7.Reduce操作的workers将最终输出结果写到GFS中\n\n**如何通过细节处的设计来提高网络性能**\n\n1.Map的输入从本地磁盘读取，不是通过网络\n\n2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS\n\n3.生成的中间数据分块保存很多的key，并存储在文件中\n\n4.大块的网络传输效率更高\n\n**如果更均衡的分配负载**\n\n1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益\n\n2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件\n\n3.解决方案：split的数多于workes数\n\nMaster将新的splits分发给已经完成先前任务的workers\n\n所以更快的服务器比慢速的服务器做更多的工作，并同时完成。\n\n**MR如何应对worker崩溃呢**\n\n1.Map worker 崩溃\n\nmaster重新运行，通过其他GFS的副本作为输入\n\n即使worker已经完成，因为我们仍需要磁盘上的中间数据\n\n一些Reduce workers可能已经督过workers的中间数据\n\n2.Master怎么知道worker崩溃了(通过 pings)\n\n如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行\n\n3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker\n\n4.Reduce worker在写输出的过程中崩溃\n\nGFS具有 atomic rename ,可以防止输出在完成之前可见\n\n5.所以master在其他的地方重新运行Reduce 任务是安全的\n\n","source":"_posts/LEC1.md","raw":"---\ntitle: LEC1\ndate: 2019-01-15 23:03:03\ntags: 分布式系统6.824笔记\n---\n\n**不敢确认的翻译给出了原文，避免误解**\n\n**什么是分布式系统**？\n\n1.多台主机合作\n\n2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的\n\n**为什么需要分布式**？\n\n1.连接物理上分离的实体\n\n2.通过隔离实现安全\n\n3.通过副本来实现容错\n\n4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量\n\n5.但是：\n\n1) 分布式系统具有复杂性，包括很多并发的部分\n\n2) 必须应对系统中部分部分失败\n\n3) 很难实现性能潜力\n\n**实验的目标**：\n\n1.更加深入的了解一些重要技术\n\n2.积累分布式系统的编程经验\n\n**主话题**\n\n1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用\n\n2.用来应用程序分布的复杂性\n\n1）三大抽象\n\n存储，交互，计算\n\n2）实现分布式系统的一些基础知识\n\nRPC，线程，并发控制\n\n3）分布式系统的性能\n\n**理想：可扩展的吞吐量**\n\n可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现\n\n所以可以通过购买更多的服务器来处理更多的负载\n\n**现实：扩展变得越来越困难**\n\n负载均衡，(stragglers)性能落后的机器\n\n很小的，不可以并行化的部分\n\n隐藏共享资源，比如网络\n\n分布式系统的容错性(fault tolerance)\n\n1000个服务器，复杂的网络连接，总是会出现一些问题\n我们想通过应用程序来隐藏(容忍)这些失败\n\n可用性：尽管失败，我仍然可以继续使用我的文件\n\n耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复\n\n一个好主意：使用副本服务器(replicated servers)\n\n如果一个服务宕机了，客户端可以选择使用其他的服务器\n\n**分布式系统的一致性**\n\n通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的\n\n1.客户端提交并行的操作\n2.服务器在尴尬的时候崩溃\n3.网络问题可能是服务器看起来像是死机了\n4.脑裂的风险(split brain)\n\n**一致性和性能是相对的**\n\n1.一致性需要交互\n2.具有令人满意(\"严格\")语以的系统通常很慢\n3.快速的系统通常可以使应用程序面对复杂的行为\n\n案例学习: MapReduce\n\n**MapReduce概述**\n\n1.Context: 对多个TB的数据集进行多个小时的计算\n\n例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的\n\n2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理\n\n3.程序员定义Map和Reduce函数的顺序代码，通常很简单\n\n4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节\n\n**MapReduce的抽象视图**\n\n输入(input)被分为M个文件\n\n[maps 生成多行 K-V对，reduces合并列]\n\n![MapReduce](LEC1/MapReduce.png)\n\nMR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。\n\nMR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 <k2, v3> 对，结果存储在R输出文件中\n\n[MapReduce API]\n\n![MapReduceApi](LEC1/MapReduceApi.png)\n\n**MapReduce隐藏了一些细节痛点**\n\n1.在服务器上启动 s/w\n\n2.跟踪哪些任务已经完成了\n\n3.数据移动\n\n4.任务失败后恢复\n\n**Mapreduce 具有很好的扩展性**\n\n1.用N台服务器可以获得Nx的吞吐量\n\n假设 M和R >= N （即：很多的输入文件和map输出的key）\n\nMaps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的\n\n唯一的交互是maps和reduces之间的 \"shuffle\"\n\n2.因此，你可以通过购买更多的服务器来获得更多的吞吐量\n\n而不是对每个应用程序做特殊，高效的并行化\n\n**限制性能的因素是什么？**\n\n1.我们关心这个因为这正是系统性能的优化点\nCPU? 内存? 磁盘? 网络？\n\n2.网络带宽的限制\n\n网络的内部总容量，通常远小于主机之间网络链路的速度总和\n\n难以建立一个比单台计算机运行速度快1000倍的网络\n\n所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动\n\n**容灾处理**\n\n如果有服务器在MR job过程中宕机怎么处理\n\n隐藏失败是实现模型简易编程一个大的部分\n\n为什么不从一开始就重启整个job\n\nMR过程只会重新运行失败的Map()和Reduce()\n\n它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果\n\nMR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要\n\n**更多的细节**\n\n1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片\n\n输入数据存在GFS中，每个分片存了3个副本\n\n2.所有的计算机同时运行GFS和MR workers\n\n3.输入分片数比workers数要多\n\n4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务\n\n5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘\n\n直到所有Maps操作结束后才会进行Reduce计算\n\n6.Master告诉Reducers从Map操作的workers那里获取中间数据分块\n\n7.Reduce操作的workers将最终输出结果写到GFS中\n\n**如何通过细节处的设计来提高网络性能**\n\n1.Map的输入从本地磁盘读取，不是通过网络\n\n2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS\n\n3.生成的中间数据分块保存很多的key，并存储在文件中\n\n4.大块的网络传输效率更高\n\n**如果更均衡的分配负载**\n\n1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益\n\n2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件\n\n3.解决方案：split的数多于workes数\n\nMaster将新的splits分发给已经完成先前任务的workers\n\n所以更快的服务器比慢速的服务器做更多的工作，并同时完成。\n\n**MR如何应对worker崩溃呢**\n\n1.Map worker 崩溃\n\nmaster重新运行，通过其他GFS的副本作为输入\n\n即使worker已经完成，因为我们仍需要磁盘上的中间数据\n\n一些Reduce workers可能已经督过workers的中间数据\n\n2.Master怎么知道worker崩溃了(通过 pings)\n\n如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行\n\n3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker\n\n4.Reduce worker在写输出的过程中崩溃\n\nGFS具有 atomic rename ,可以防止输出在完成之前可见\n\n5.所以master在其他的地方重新运行Reduce 任务是安全的\n\n","slug":"LEC1","published":1,"updated":"2019-01-17T04:40:36.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw1l0009no3y8llg85sm","content":"<p><strong>不敢确认的翻译给出了原文，避免误解</strong></p>\n<p><strong>什么是分布式系统</strong>？</p>\n<p>1.多台主机合作</p>\n<p>2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的</p>\n<p><strong>为什么需要分布式</strong>？</p>\n<p>1.连接物理上分离的实体</p>\n<p>2.通过隔离实现安全</p>\n<p>3.通过副本来实现容错</p>\n<p>4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量</p>\n<p>5.但是：</p>\n<p>1) 分布式系统具有复杂性，包括很多并发的部分</p>\n<p>2) 必须应对系统中部分部分失败</p>\n<p>3) 很难实现性能潜力</p>\n<p><strong>实验的目标</strong>：</p>\n<p>1.更加深入的了解一些重要技术</p>\n<p>2.积累分布式系统的编程经验</p>\n<p><strong>主话题</strong></p>\n<p>1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用</p>\n<p>2.用来应用程序分布的复杂性</p>\n<p>1）三大抽象</p>\n<p>存储，交互，计算</p>\n<p>2）实现分布式系统的一些基础知识</p>\n<p>RPC，线程，并发控制</p>\n<p>3）分布式系统的性能</p>\n<p><strong>理想：可扩展的吞吐量</strong></p>\n<p>可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现</p>\n<p>所以可以通过购买更多的服务器来处理更多的负载</p>\n<p><strong>现实：扩展变得越来越困难</strong></p>\n<p>负载均衡，(stragglers)性能落后的机器</p>\n<p>很小的，不可以并行化的部分</p>\n<p>隐藏共享资源，比如网络</p>\n<p>分布式系统的容错性(fault tolerance)</p>\n<p>1000个服务器，复杂的网络连接，总是会出现一些问题<br>我们想通过应用程序来隐藏(容忍)这些失败</p>\n<p>可用性：尽管失败，我仍然可以继续使用我的文件</p>\n<p>耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复</p>\n<p>一个好主意：使用副本服务器(replicated servers)</p>\n<p>如果一个服务宕机了，客户端可以选择使用其他的服务器</p>\n<p><strong>分布式系统的一致性</strong></p>\n<p>通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的</p>\n<p>1.客户端提交并行的操作<br>2.服务器在尴尬的时候崩溃<br>3.网络问题可能是服务器看起来像是死机了<br>4.脑裂的风险(split brain)</p>\n<p><strong>一致性和性能是相对的</strong></p>\n<p>1.一致性需要交互<br>2.具有令人满意(“严格”)语以的系统通常很慢<br>3.快速的系统通常可以使应用程序面对复杂的行为</p>\n<p>案例学习: MapReduce</p>\n<p><strong>MapReduce概述</strong></p>\n<p>1.Context: 对多个TB的数据集进行多个小时的计算</p>\n<p>例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的</p>\n<p>2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理</p>\n<p>3.程序员定义Map和Reduce函数的顺序代码，通常很简单</p>\n<p>4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节</p>\n<p><strong>MapReduce的抽象视图</strong></p>\n<p>输入(input)被分为M个文件</p>\n<p>[maps 生成多行 K-V对，reduces合并列]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduce.png\" alt=\"MapReduce\"></p>\n<p>MR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。</p>\n<p>MR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 &lt;k2, v3&gt; 对，结果存储在R输出文件中</p>\n<p>[MapReduce API]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduceApi.png\" alt=\"MapReduceApi\"></p>\n<p><strong>MapReduce隐藏了一些细节痛点</strong></p>\n<p>1.在服务器上启动 s/w</p>\n<p>2.跟踪哪些任务已经完成了</p>\n<p>3.数据移动</p>\n<p>4.任务失败后恢复</p>\n<p><strong>Mapreduce 具有很好的扩展性</strong></p>\n<p>1.用N台服务器可以获得Nx的吞吐量</p>\n<p>假设 M和R &gt;= N （即：很多的输入文件和map输出的key）</p>\n<p>Maps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的</p>\n<p>唯一的交互是maps和reduces之间的 “shuffle”</p>\n<p>2.因此，你可以通过购买更多的服务器来获得更多的吞吐量</p>\n<p>而不是对每个应用程序做特殊，高效的并行化</p>\n<p><strong>限制性能的因素是什么？</strong></p>\n<p>1.我们关心这个因为这正是系统性能的优化点<br>CPU? 内存? 磁盘? 网络？</p>\n<p>2.网络带宽的限制</p>\n<p>网络的内部总容量，通常远小于主机之间网络链路的速度总和</p>\n<p>难以建立一个比单台计算机运行速度快1000倍的网络</p>\n<p>所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动</p>\n<p><strong>容灾处理</strong></p>\n<p>如果有服务器在MR job过程中宕机怎么处理</p>\n<p>隐藏失败是实现模型简易编程一个大的部分</p>\n<p>为什么不从一开始就重启整个job</p>\n<p>MR过程只会重新运行失败的Map()和Reduce()</p>\n<p>它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果</p>\n<p>MR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要</p>\n<p><strong>更多的细节</strong></p>\n<p>1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片</p>\n<p>输入数据存在GFS中，每个分片存了3个副本</p>\n<p>2.所有的计算机同时运行GFS和MR workers</p>\n<p>3.输入分片数比workers数要多</p>\n<p>4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务</p>\n<p>5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘</p>\n<p>直到所有Maps操作结束后才会进行Reduce计算</p>\n<p>6.Master告诉Reducers从Map操作的workers那里获取中间数据分块</p>\n<p>7.Reduce操作的workers将最终输出结果写到GFS中</p>\n<p><strong>如何通过细节处的设计来提高网络性能</strong></p>\n<p>1.Map的输入从本地磁盘读取，不是通过网络</p>\n<p>2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS</p>\n<p>3.生成的中间数据分块保存很多的key，并存储在文件中</p>\n<p>4.大块的网络传输效率更高</p>\n<p><strong>如果更均衡的分配负载</strong></p>\n<p>1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益</p>\n<p>2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件</p>\n<p>3.解决方案：split的数多于workes数</p>\n<p>Master将新的splits分发给已经完成先前任务的workers</p>\n<p>所以更快的服务器比慢速的服务器做更多的工作，并同时完成。</p>\n<p><strong>MR如何应对worker崩溃呢</strong></p>\n<p>1.Map worker 崩溃</p>\n<p>master重新运行，通过其他GFS的副本作为输入</p>\n<p>即使worker已经完成，因为我们仍需要磁盘上的中间数据</p>\n<p>一些Reduce workers可能已经督过workers的中间数据</p>\n<p>2.Master怎么知道worker崩溃了(通过 pings)</p>\n<p>如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行</p>\n<p>3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker</p>\n<p>4.Reduce worker在写输出的过程中崩溃</p>\n<p>GFS具有 atomic rename ,可以防止输出在完成之前可见</p>\n<p>5.所以master在其他的地方重新运行Reduce 任务是安全的</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>不敢确认的翻译给出了原文，避免误解</strong></p>\n<p><strong>什么是分布式系统</strong>？</p>\n<p>1.多台主机合作</p>\n<p>2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的</p>\n<p><strong>为什么需要分布式</strong>？</p>\n<p>1.连接物理上分离的实体</p>\n<p>2.通过隔离实现安全</p>\n<p>3.通过副本来实现容错</p>\n<p>4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量</p>\n<p>5.但是：</p>\n<p>1) 分布式系统具有复杂性，包括很多并发的部分</p>\n<p>2) 必须应对系统中部分部分失败</p>\n<p>3) 很难实现性能潜力</p>\n<p><strong>实验的目标</strong>：</p>\n<p>1.更加深入的了解一些重要技术</p>\n<p>2.积累分布式系统的编程经验</p>\n<p><strong>主话题</strong></p>\n<p>1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用</p>\n<p>2.用来应用程序分布的复杂性</p>\n<p>1）三大抽象</p>\n<p>存储，交互，计算</p>\n<p>2）实现分布式系统的一些基础知识</p>\n<p>RPC，线程，并发控制</p>\n<p>3）分布式系统的性能</p>\n<p><strong>理想：可扩展的吞吐量</strong></p>\n<p>可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现</p>\n<p>所以可以通过购买更多的服务器来处理更多的负载</p>\n<p><strong>现实：扩展变得越来越困难</strong></p>\n<p>负载均衡，(stragglers)性能落后的机器</p>\n<p>很小的，不可以并行化的部分</p>\n<p>隐藏共享资源，比如网络</p>\n<p>分布式系统的容错性(fault tolerance)</p>\n<p>1000个服务器，复杂的网络连接，总是会出现一些问题<br>我们想通过应用程序来隐藏(容忍)这些失败</p>\n<p>可用性：尽管失败，我仍然可以继续使用我的文件</p>\n<p>耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复</p>\n<p>一个好主意：使用副本服务器(replicated servers)</p>\n<p>如果一个服务宕机了，客户端可以选择使用其他的服务器</p>\n<p><strong>分布式系统的一致性</strong></p>\n<p>通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的</p>\n<p>1.客户端提交并行的操作<br>2.服务器在尴尬的时候崩溃<br>3.网络问题可能是服务器看起来像是死机了<br>4.脑裂的风险(split brain)</p>\n<p><strong>一致性和性能是相对的</strong></p>\n<p>1.一致性需要交互<br>2.具有令人满意(“严格”)语以的系统通常很慢<br>3.快速的系统通常可以使应用程序面对复杂的行为</p>\n<p>案例学习: MapReduce</p>\n<p><strong>MapReduce概述</strong></p>\n<p>1.Context: 对多个TB的数据集进行多个小时的计算</p>\n<p>例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的</p>\n<p>2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理</p>\n<p>3.程序员定义Map和Reduce函数的顺序代码，通常很简单</p>\n<p>4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节</p>\n<p><strong>MapReduce的抽象视图</strong></p>\n<p>输入(input)被分为M个文件</p>\n<p>[maps 生成多行 K-V对，reduces合并列]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduce.png\" alt=\"MapReduce\"></p>\n<p>MR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。</p>\n<p>MR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 &lt;k2, v3&gt; 对，结果存储在R输出文件中</p>\n<p>[MapReduce API]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduceApi.png\" alt=\"MapReduceApi\"></p>\n<p><strong>MapReduce隐藏了一些细节痛点</strong></p>\n<p>1.在服务器上启动 s/w</p>\n<p>2.跟踪哪些任务已经完成了</p>\n<p>3.数据移动</p>\n<p>4.任务失败后恢复</p>\n<p><strong>Mapreduce 具有很好的扩展性</strong></p>\n<p>1.用N台服务器可以获得Nx的吞吐量</p>\n<p>假设 M和R &gt;= N （即：很多的输入文件和map输出的key）</p>\n<p>Maps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的</p>\n<p>唯一的交互是maps和reduces之间的 “shuffle”</p>\n<p>2.因此，你可以通过购买更多的服务器来获得更多的吞吐量</p>\n<p>而不是对每个应用程序做特殊，高效的并行化</p>\n<p><strong>限制性能的因素是什么？</strong></p>\n<p>1.我们关心这个因为这正是系统性能的优化点<br>CPU? 内存? 磁盘? 网络？</p>\n<p>2.网络带宽的限制</p>\n<p>网络的内部总容量，通常远小于主机之间网络链路的速度总和</p>\n<p>难以建立一个比单台计算机运行速度快1000倍的网络</p>\n<p>所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动</p>\n<p><strong>容灾处理</strong></p>\n<p>如果有服务器在MR job过程中宕机怎么处理</p>\n<p>隐藏失败是实现模型简易编程一个大的部分</p>\n<p>为什么不从一开始就重启整个job</p>\n<p>MR过程只会重新运行失败的Map()和Reduce()</p>\n<p>它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果</p>\n<p>MR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要</p>\n<p><strong>更多的细节</strong></p>\n<p>1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片</p>\n<p>输入数据存在GFS中，每个分片存了3个副本</p>\n<p>2.所有的计算机同时运行GFS和MR workers</p>\n<p>3.输入分片数比workers数要多</p>\n<p>4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务</p>\n<p>5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘</p>\n<p>直到所有Maps操作结束后才会进行Reduce计算</p>\n<p>6.Master告诉Reducers从Map操作的workers那里获取中间数据分块</p>\n<p>7.Reduce操作的workers将最终输出结果写到GFS中</p>\n<p><strong>如何通过细节处的设计来提高网络性能</strong></p>\n<p>1.Map的输入从本地磁盘读取，不是通过网络</p>\n<p>2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS</p>\n<p>3.生成的中间数据分块保存很多的key，并存储在文件中</p>\n<p>4.大块的网络传输效率更高</p>\n<p><strong>如果更均衡的分配负载</strong></p>\n<p>1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益</p>\n<p>2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件</p>\n<p>3.解决方案：split的数多于workes数</p>\n<p>Master将新的splits分发给已经完成先前任务的workers</p>\n<p>所以更快的服务器比慢速的服务器做更多的工作，并同时完成。</p>\n<p><strong>MR如何应对worker崩溃呢</strong></p>\n<p>1.Map worker 崩溃</p>\n<p>master重新运行，通过其他GFS的副本作为输入</p>\n<p>即使worker已经完成，因为我们仍需要磁盘上的中间数据</p>\n<p>一些Reduce workers可能已经督过workers的中间数据</p>\n<p>2.Master怎么知道worker崩溃了(通过 pings)</p>\n<p>如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行</p>\n<p>3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker</p>\n<p>4.Reduce worker在写输出的过程中崩溃</p>\n<p>GFS具有 atomic rename ,可以防止输出在完成之前可见</p>\n<p>5.所以master在其他的地方重新运行Reduce 任务是安全的</p>\n"},{"title":"LEC10-vedio","date":"2019-01-17T01:36:41.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC10-vedio.md","raw":"---\ntitle: LEC10-vedio\ndate: 2019-01-17 09:36:41\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC10-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw1q000bno3y785ydor0","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC12-vedio","date":"2019-01-17T01:36:53.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC12-vedio.md","raw":"---\ntitle: LEC12-vedio\ndate: 2019-01-17 09:36:53\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC12-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw1s000cno3ytfgh6yw6","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC13-vedio","date":"2019-01-17T01:36:59.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC13-vedio.md","raw":"---\ntitle: LEC13-vedio\ndate: 2019-01-17 09:36:59\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC13-vedio","published":1,"updated":"2019-01-17T04:50:19.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw1u000dno3y1txepfuc","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC15-vedio","date":"2019-01-17T01:37:08.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC15-vedio.md","raw":"---\ntitle: LEC15-vedio\ndate: 2019-01-17 09:37:08\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC15-vedio","published":1,"updated":"2019-01-17T04:50:19.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw1w000gno3yvyxqtuio","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC16-vedio","date":"2019-01-17T04:36:30.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n","source":"_posts/LEC16-vedio.md","raw":"---\ntitle: LEC16-vedio\ndate: 2019-01-17 12:36:30\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n","slug":"LEC16-vedio","published":1,"updated":"2019-01-17T04:50:19.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw1x000ino3ybb3a4sx6","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n"},{"title":"LEC17-vedio","date":"2019-01-17T04:36:35.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC17-vedio.md","raw":"---\ntitle: LEC17-vedio\ndate: 2019-01-17 12:36:35\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC17-vedio","published":1,"updated":"2019-01-17T04:55:01.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw21000lno3yaia8rmaw","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC2-vedio","date":"2019-01-17T01:35:51.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC2-vedio.md","raw":"---\ntitle: LEC2-vedio\ndate: 2019-01-17 09:35:51\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC2-vedio","published":1,"updated":"2019-01-17T04:53:21.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw23000nno3yx9t1nqzn","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC2","date":"2019-01-17T04:50:09.000Z","_content":"\n#### 基础设施: RPC 和 线程\n\n**一个最常被问到的问题:为什么使用Go**\n\n***6.824这门课原先是使用C++的***\n\n学生花了很多时间去修与构建分布式系统无关的bug\n\n例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象\n\n***Go 语言可以让你更专注的处理分布式系统的问题***\n\n1.Go语言是类型安全的\n\n2.它有垃圾收集器（不会存在对象没有free导致的程序bug）\n\n3.对并发编程的支持很友好\n\n4.对RPC的支持很友好\n\n***我们喜欢用Go编程***\n\n1.Go很容易学习\n\n2.Go语言推荐资料 https://golang.org/doc/effective_go.html#generality\n\n**远程过程调用 (RPC)**\n\n1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写\n\n2.隐藏了客户端/服务器通信的大部分细节\n\n3.通过RPC客户端的远程调用就像普通的过程调用\n\n4.服务器的处理程序和普通的程序类似\n\n5.RPC被广泛使用\n\n**理想情况下，RPC使得网络通信看起来就像函数的调用**\n\n客户端：\n\n```\nz = fn(x, y)\n```\n\n服务器：\n\n```\nfn(x, y) {\n    compute\n    return z\n}\n```\n\nRPC旨在实现这种透明度的调用\n\nGo语言RPC的库 https://golang.org/pkg/net/rpc/\n\n**RPC 消息图**\n\nClient\t\t\t\tServer\n\nrequest --->\n\n​\t\t\t<--- response\n\n**软件架构**\n\n客户端应用存根\t\t\t处理调用\n\nRPC 库\t\t\t\t\tRPC库\n\nNet   ——————————   Net\n\n**更多的细节**\n\n1.要调用服务器的那个处理函数\n\n2.Marshalling（编组）：将数据格式化为数据包\n\n​\t1）处理数组、指针和对象是很棘手的\n\n​\t2）Go的RPC库是相当强大的\n\n​\t3）有一些东西你不能传送：例如，channels（通道）,functions（函数）\n\n3.Binding（绑定）:客户端如何知道与谁交互?\n\n​       1）客户端被提供了服务器的主机名\n\n​       2）也许名称服务将服务映射到最佳的服务器主机\n\n4.线程：\n\n​\t1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应\n\n​\t2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序\n\n**RPC问题：如何处理失败**\n\n​\t例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃\n\n**客户端RPC库中的故障是什么样的?**\n\n1.客户端从未收到服务器的响应\n\n2.客户端不知道服务器是否能看到请求\n\n3.可能服务器或者网络在发送回复之前失败了\n\n**最简单的方案：“至少一次”行为**\n\n1.RPC库等待响应一段时间\n\n2.如果没有响应到达，重新发送请求\n\n3.多次尝试\n\n4.仍然没有响应的话，向应用程序返回一个错误\n\n5.问题：应用程序容易处理至少一次的操作吗？\n\n​\t至少一次：客户端发送“从银行账户中扣除5美元”\n\n6.问题：这个客户端程序有什么问题？\n\n​\tput(\"k\", 10) 通过RPC在数据库服务器中设置key的值\t\n\n​\tput(\"k\", 20) 然后客户端执行第二次put操作到同一个key\n\n7.问题：至少一次总是OK的吗？\n\n​\t1）重复操作是可以的，例如只读操作\n\n​\t2）如果应用程序有自己对于写副本的执行计划\n\n**更好的PRC行为：“至多一次”**\n\n1.想法：服务器RPC代码检测重复请求\n\n2.返回上一个reply，而不是重新运行处理程序\n\n**如何检测重复的请求**\n\n1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送\t\n\n```\nserver:\nif seen[xid]:\n\tr = old[xid]\nelse\n\tr = handler()\n\told[xid] = r\n\tseen[xid] = true\n```\n\n**至多一次请求的复杂之处**\n\n1.这将在实验2和以后的实验中出现\n\n2.如何确保XID是唯一的？\n\n​\t大的随机数？\n\n​\t合并唯一客户端ID（IP地址？）有序列？\n\n​\t服务器必须最终放弃优化旧的RPC的信息\n\n​\t1）什么时候丢弃是安全的\n\n​\t想法：\n\n​\t唯一的客户端ID\n\n​\t上一次客户端RPC请求的序列号\n\n​\t客户端的每一个RPCC包含\"seen all replies <= X\"\n\n​\t像TCP的sequence号一样\n\n​\t或者一次只允许一个客户端PRC\n\n​\t当seq + 1到达允许服务器放弃所有的 <= seq 的请求\n\n​\t或者客户端同意小于5分钟的重试，5分钟后服务器放弃\n\n如何处理相同的请求当原来的请求仍然在执行？\n\n​\t服务器不知道要回复，不想重复运行\n\n​\t想法：给每个正在执行的RPC设置一个\"pending\" flag；等待或者忽略相同的请求\n\n**当一个 at-most-once 服务器宕机和重启怎么办？**\n\n1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求\n\n2.也许它应该吧重复的信息写到磁盘？\n\n3.也许副本服务器也应该复制重复的信息？\n\n**\"一次就好\"怎么样？**\n\n最多一次加上无限制的重试加上容错服务\n\n**Go的RPC是 “at-most-once”**\n\n1.打开TCP连接\n\n2.向TCP连接中写入请求\n\n3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求\n\n4.Go的代码里面没有重试\n\n5.Go RPC代码在没有得到回复的时候会返回一个error\n\n1）可能在一个TCP超时之后\n\n2）可能服务器没有看到请求\n\n3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败\n\n**Go RPC的 at-most-once 不足以应对Lab1**\n\n1.它只适用于单个RPC调用\n\n2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败\n\n3.Go的RPC不能检测出这种重复\n\n1）在lab1中没问题，它在应用层处理了\n\n2）Lab2需要明确的检测重复提交\n\n**线程**\n\n1.线程是一个基本的服务结构工具\n\n2.你将会在lab中广泛的使用它\n\n3.它们可能很棘手\n\n4.但是对PRC非常有用\n\n5.Go称它们为Goroutines，也有很多人称它们为线程\n\n**Thread = \"Thread of control\"**\n\n1.多线程允许程序逻辑上在同一时刻同时做很多事情\n\n2.线程共享内存\n\n3.线程之间共享程序计数器，寄存器，栈空间\n\n**多线程的一些挑战**\n\n1.共享数据\n\n1）两个线程如果同时修改了相同的变量会怎么样？\n\n2）一个线程正在读数据，另一个线程改变数据呢？\n\n3）需要保护共享数据上的不变量\n\n4）使用Go sync.Mutex锁\n\n2.线程之间的通过\n\n例如：等待所有的Map线程完成\n\n使用Go channels\n\n3.死锁\n\n1）线程1等待线程2\n\n2）线程2等待线程1\n\n4.锁粒度\n\n1）粗粒度->实现简单，但是并发性能不好\n\n2）细粒度->更好的并发性能，更多的锁竞争(races)和死锁\n\n5.让我们来看labrpc 包里如何解决这些问题\n\n1）它类似于Go的RPC系统，但是网络是一个模拟网络\n\n- 网络延迟请求和响应\n- 网络丢包请求和响应\n- 网络的重发请求和响应\n\n2）说明 threads，mutexes，channels的用法\n\n3）使用Go实现了一个完整的RPC包\n\n**网络的结构**\n\n1.网络的描述\n\n1）服务器\n\n2）客户端\n\n2.每个网络都是互斥的\n\n**RPC概述**\n\n1.在test_test.go文件里面有很多例子\n\n2.应用调用RPC\n\n```\nreply := end.Call(\"Raft.AppendEntries\", args, &reply) //发出一个RPC请求，等待回复\n```\n\n3.服务端\n\n```\nsrv := MakeServer()\nsrv.AddService(svc) -- 一个服务器可以有多种服务\n```\n\n4.k/v\n\n将srv传递给 net.AddServer()\n\n```\nsvc := MakeService(recevierPbject) -- obj's 方法会处理RPC请求\n```\n\n非常像Go的rpcs.Register()\n\n传递svc给 srv.AddService()\n\n5.服务器的数据结构\n\n1）AddService()\n\n添加一个服务名\n\n问题：为什么使用锁？\n\n问题：什么事defer()？\n\n2）Dispatch()\n\n分发一个请求到正确的服务\n\n问题：为什么持有锁？\n\n问题：为什么持有锁的范围互道函数的末尾？\n\n3）Call()\n\n使用反射查找参数的类型\n\n使用gob编码参数\n\ne.ch 是网络发送请求的通道\n\n使用一个通道来接收网络的回复（<- req.replyCh）\n\n4）MakeEnd()\n\n有一个模拟网络的线程/goroutine\n\n从e.ch中读取并处理请求\n\n每个请求都在一个单独的goroutine中处理\n\nQ：一个endpoint 可以有很多未完成的请求吗\n\nQ：为什么使用rn.mu.Lock()？\n\nQ：锁保护了什么？\n\n5）ProcessReq()\n\n查找一个服务endpoint\n\n如果网络不可靠，可能会延迟或者丢失请求\n\n分发请求到一个新的线程\n\n通过读取ech中的数据等待服务端回复直到100ms过去\n\n100ms只是用来验证服务器是不是宕机了\n\n然后回复\n\nQ：谁将会读取回复？\n\nQ：如果ProcessReq不持有rn的锁可以吗？\n\n6）Service.dispatch()\n\n给请求找到一个处理的方法\n\n解码参数\n\n调用函数\n\n编码回复\n\n返回回复信息\n\nGo的内存模型需要显示同步才能进行通信\n\n下面代码是不正确的\n\n```\nvar x int\ndone := false\ngo func() { x = f(...); done = true }\nwhile done == false { }\n```\n\n这是一个非常诱人的写法，但是Go会说这是为定义的\n\n使用通道或者sync.WaitGroup代替\n\n**学习Go的goroutines和channels**\n\nhttps://golang.org/doc/articles/race_detector.html","source":"_posts/LEC2.md","raw":"---\ntitle: LEC2\ndate: 2019-01-17 12:50:09\ntags: 分布式系统6.824笔记\n---\n\n#### 基础设施: RPC 和 线程\n\n**一个最常被问到的问题:为什么使用Go**\n\n***6.824这门课原先是使用C++的***\n\n学生花了很多时间去修与构建分布式系统无关的bug\n\n例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象\n\n***Go 语言可以让你更专注的处理分布式系统的问题***\n\n1.Go语言是类型安全的\n\n2.它有垃圾收集器（不会存在对象没有free导致的程序bug）\n\n3.对并发编程的支持很友好\n\n4.对RPC的支持很友好\n\n***我们喜欢用Go编程***\n\n1.Go很容易学习\n\n2.Go语言推荐资料 https://golang.org/doc/effective_go.html#generality\n\n**远程过程调用 (RPC)**\n\n1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写\n\n2.隐藏了客户端/服务器通信的大部分细节\n\n3.通过RPC客户端的远程调用就像普通的过程调用\n\n4.服务器的处理程序和普通的程序类似\n\n5.RPC被广泛使用\n\n**理想情况下，RPC使得网络通信看起来就像函数的调用**\n\n客户端：\n\n```\nz = fn(x, y)\n```\n\n服务器：\n\n```\nfn(x, y) {\n    compute\n    return z\n}\n```\n\nRPC旨在实现这种透明度的调用\n\nGo语言RPC的库 https://golang.org/pkg/net/rpc/\n\n**RPC 消息图**\n\nClient\t\t\t\tServer\n\nrequest --->\n\n​\t\t\t<--- response\n\n**软件架构**\n\n客户端应用存根\t\t\t处理调用\n\nRPC 库\t\t\t\t\tRPC库\n\nNet   ——————————   Net\n\n**更多的细节**\n\n1.要调用服务器的那个处理函数\n\n2.Marshalling（编组）：将数据格式化为数据包\n\n​\t1）处理数组、指针和对象是很棘手的\n\n​\t2）Go的RPC库是相当强大的\n\n​\t3）有一些东西你不能传送：例如，channels（通道）,functions（函数）\n\n3.Binding（绑定）:客户端如何知道与谁交互?\n\n​       1）客户端被提供了服务器的主机名\n\n​       2）也许名称服务将服务映射到最佳的服务器主机\n\n4.线程：\n\n​\t1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应\n\n​\t2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序\n\n**RPC问题：如何处理失败**\n\n​\t例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃\n\n**客户端RPC库中的故障是什么样的?**\n\n1.客户端从未收到服务器的响应\n\n2.客户端不知道服务器是否能看到请求\n\n3.可能服务器或者网络在发送回复之前失败了\n\n**最简单的方案：“至少一次”行为**\n\n1.RPC库等待响应一段时间\n\n2.如果没有响应到达，重新发送请求\n\n3.多次尝试\n\n4.仍然没有响应的话，向应用程序返回一个错误\n\n5.问题：应用程序容易处理至少一次的操作吗？\n\n​\t至少一次：客户端发送“从银行账户中扣除5美元”\n\n6.问题：这个客户端程序有什么问题？\n\n​\tput(\"k\", 10) 通过RPC在数据库服务器中设置key的值\t\n\n​\tput(\"k\", 20) 然后客户端执行第二次put操作到同一个key\n\n7.问题：至少一次总是OK的吗？\n\n​\t1）重复操作是可以的，例如只读操作\n\n​\t2）如果应用程序有自己对于写副本的执行计划\n\n**更好的PRC行为：“至多一次”**\n\n1.想法：服务器RPC代码检测重复请求\n\n2.返回上一个reply，而不是重新运行处理程序\n\n**如何检测重复的请求**\n\n1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送\t\n\n```\nserver:\nif seen[xid]:\n\tr = old[xid]\nelse\n\tr = handler()\n\told[xid] = r\n\tseen[xid] = true\n```\n\n**至多一次请求的复杂之处**\n\n1.这将在实验2和以后的实验中出现\n\n2.如何确保XID是唯一的？\n\n​\t大的随机数？\n\n​\t合并唯一客户端ID（IP地址？）有序列？\n\n​\t服务器必须最终放弃优化旧的RPC的信息\n\n​\t1）什么时候丢弃是安全的\n\n​\t想法：\n\n​\t唯一的客户端ID\n\n​\t上一次客户端RPC请求的序列号\n\n​\t客户端的每一个RPCC包含\"seen all replies <= X\"\n\n​\t像TCP的sequence号一样\n\n​\t或者一次只允许一个客户端PRC\n\n​\t当seq + 1到达允许服务器放弃所有的 <= seq 的请求\n\n​\t或者客户端同意小于5分钟的重试，5分钟后服务器放弃\n\n如何处理相同的请求当原来的请求仍然在执行？\n\n​\t服务器不知道要回复，不想重复运行\n\n​\t想法：给每个正在执行的RPC设置一个\"pending\" flag；等待或者忽略相同的请求\n\n**当一个 at-most-once 服务器宕机和重启怎么办？**\n\n1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求\n\n2.也许它应该吧重复的信息写到磁盘？\n\n3.也许副本服务器也应该复制重复的信息？\n\n**\"一次就好\"怎么样？**\n\n最多一次加上无限制的重试加上容错服务\n\n**Go的RPC是 “at-most-once”**\n\n1.打开TCP连接\n\n2.向TCP连接中写入请求\n\n3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求\n\n4.Go的代码里面没有重试\n\n5.Go RPC代码在没有得到回复的时候会返回一个error\n\n1）可能在一个TCP超时之后\n\n2）可能服务器没有看到请求\n\n3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败\n\n**Go RPC的 at-most-once 不足以应对Lab1**\n\n1.它只适用于单个RPC调用\n\n2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败\n\n3.Go的RPC不能检测出这种重复\n\n1）在lab1中没问题，它在应用层处理了\n\n2）Lab2需要明确的检测重复提交\n\n**线程**\n\n1.线程是一个基本的服务结构工具\n\n2.你将会在lab中广泛的使用它\n\n3.它们可能很棘手\n\n4.但是对PRC非常有用\n\n5.Go称它们为Goroutines，也有很多人称它们为线程\n\n**Thread = \"Thread of control\"**\n\n1.多线程允许程序逻辑上在同一时刻同时做很多事情\n\n2.线程共享内存\n\n3.线程之间共享程序计数器，寄存器，栈空间\n\n**多线程的一些挑战**\n\n1.共享数据\n\n1）两个线程如果同时修改了相同的变量会怎么样？\n\n2）一个线程正在读数据，另一个线程改变数据呢？\n\n3）需要保护共享数据上的不变量\n\n4）使用Go sync.Mutex锁\n\n2.线程之间的通过\n\n例如：等待所有的Map线程完成\n\n使用Go channels\n\n3.死锁\n\n1）线程1等待线程2\n\n2）线程2等待线程1\n\n4.锁粒度\n\n1）粗粒度->实现简单，但是并发性能不好\n\n2）细粒度->更好的并发性能，更多的锁竞争(races)和死锁\n\n5.让我们来看labrpc 包里如何解决这些问题\n\n1）它类似于Go的RPC系统，但是网络是一个模拟网络\n\n- 网络延迟请求和响应\n- 网络丢包请求和响应\n- 网络的重发请求和响应\n\n2）说明 threads，mutexes，channels的用法\n\n3）使用Go实现了一个完整的RPC包\n\n**网络的结构**\n\n1.网络的描述\n\n1）服务器\n\n2）客户端\n\n2.每个网络都是互斥的\n\n**RPC概述**\n\n1.在test_test.go文件里面有很多例子\n\n2.应用调用RPC\n\n```\nreply := end.Call(\"Raft.AppendEntries\", args, &reply) //发出一个RPC请求，等待回复\n```\n\n3.服务端\n\n```\nsrv := MakeServer()\nsrv.AddService(svc) -- 一个服务器可以有多种服务\n```\n\n4.k/v\n\n将srv传递给 net.AddServer()\n\n```\nsvc := MakeService(recevierPbject) -- obj's 方法会处理RPC请求\n```\n\n非常像Go的rpcs.Register()\n\n传递svc给 srv.AddService()\n\n5.服务器的数据结构\n\n1）AddService()\n\n添加一个服务名\n\n问题：为什么使用锁？\n\n问题：什么事defer()？\n\n2）Dispatch()\n\n分发一个请求到正确的服务\n\n问题：为什么持有锁？\n\n问题：为什么持有锁的范围互道函数的末尾？\n\n3）Call()\n\n使用反射查找参数的类型\n\n使用gob编码参数\n\ne.ch 是网络发送请求的通道\n\n使用一个通道来接收网络的回复（<- req.replyCh）\n\n4）MakeEnd()\n\n有一个模拟网络的线程/goroutine\n\n从e.ch中读取并处理请求\n\n每个请求都在一个单独的goroutine中处理\n\nQ：一个endpoint 可以有很多未完成的请求吗\n\nQ：为什么使用rn.mu.Lock()？\n\nQ：锁保护了什么？\n\n5）ProcessReq()\n\n查找一个服务endpoint\n\n如果网络不可靠，可能会延迟或者丢失请求\n\n分发请求到一个新的线程\n\n通过读取ech中的数据等待服务端回复直到100ms过去\n\n100ms只是用来验证服务器是不是宕机了\n\n然后回复\n\nQ：谁将会读取回复？\n\nQ：如果ProcessReq不持有rn的锁可以吗？\n\n6）Service.dispatch()\n\n给请求找到一个处理的方法\n\n解码参数\n\n调用函数\n\n编码回复\n\n返回回复信息\n\nGo的内存模型需要显示同步才能进行通信\n\n下面代码是不正确的\n\n```\nvar x int\ndone := false\ngo func() { x = f(...); done = true }\nwhile done == false { }\n```\n\n这是一个非常诱人的写法，但是Go会说这是为定义的\n\n使用通道或者sync.WaitGroup代替\n\n**学习Go的goroutines和channels**\n\nhttps://golang.org/doc/articles/race_detector.html","slug":"LEC2","published":1,"updated":"2019-01-24T15:32:30.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw26000pno3yuqczwj5t","content":"<h4 id=\"基础设施-RPC-和-线程\"><a href=\"#基础设施-RPC-和-线程\" class=\"headerlink\" title=\"基础设施: RPC 和 线程\"></a>基础设施: RPC 和 线程</h4><p><strong>一个最常被问到的问题:为什么使用Go</strong></p>\n<p><strong><em>6.824这门课原先是使用C++的</em></strong></p>\n<p>学生花了很多时间去修与构建分布式系统无关的bug</p>\n<p>例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象</p>\n<p><strong><em>Go 语言可以让你更专注的处理分布式系统的问题</em></strong></p>\n<p>1.Go语言是类型安全的</p>\n<p>2.它有垃圾收集器（不会存在对象没有free导致的程序bug）</p>\n<p>3.对并发编程的支持很友好</p>\n<p>4.对RPC的支持很友好</p>\n<p><strong><em>我们喜欢用Go编程</em></strong></p>\n<p>1.Go很容易学习</p>\n<p>2.Go语言推荐资料 <a href=\"https://golang.org/doc/effective_go.html#generality\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/effective_go.html#generality</a></p>\n<p><strong>远程过程调用 (RPC)</strong></p>\n<p>1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写</p>\n<p>2.隐藏了客户端/服务器通信的大部分细节</p>\n<p>3.通过RPC客户端的远程调用就像普通的过程调用</p>\n<p>4.服务器的处理程序和普通的程序类似</p>\n<p>5.RPC被广泛使用</p>\n<p><strong>理想情况下，RPC使得网络通信看起来就像函数的调用</strong></p>\n<p>客户端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = fn(x, y)</span><br></pre></td></tr></table></figure>\n<p>服务器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn(x, y) &#123;</span><br><span class=\"line\">    compute</span><br><span class=\"line\">    return z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RPC旨在实现这种透明度的调用</p>\n<p>Go语言RPC的库 <a href=\"https://golang.org/pkg/net/rpc/\" target=\"_blank\" rel=\"noopener\">https://golang.org/pkg/net/rpc/</a></p>\n<p><strong>RPC 消息图</strong></p>\n<p>Client                Server</p>\n<p>request —&gt;</p>\n<p>​            &lt;— response</p>\n<p><strong>软件架构</strong></p>\n<p>客户端应用存根            处理调用</p>\n<p>RPC 库                    RPC库</p>\n<p>Net   ——————————   Net</p>\n<p><strong>更多的细节</strong></p>\n<p>1.要调用服务器的那个处理函数</p>\n<p>2.Marshalling（编组）：将数据格式化为数据包</p>\n<p>​    1）处理数组、指针和对象是很棘手的</p>\n<p>​    2）Go的RPC库是相当强大的</p>\n<p>​    3）有一些东西你不能传送：例如，channels（通道）,functions（函数）</p>\n<p>3.Binding（绑定）:客户端如何知道与谁交互?</p>\n<p>​       1）客户端被提供了服务器的主机名</p>\n<p>​       2）也许名称服务将服务映射到最佳的服务器主机</p>\n<p>4.线程：</p>\n<p>​    1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应</p>\n<p>​    2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序</p>\n<p><strong>RPC问题：如何处理失败</strong></p>\n<p>​    例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃</p>\n<p><strong>客户端RPC库中的故障是什么样的?</strong></p>\n<p>1.客户端从未收到服务器的响应</p>\n<p>2.客户端不知道服务器是否能看到请求</p>\n<p>3.可能服务器或者网络在发送回复之前失败了</p>\n<p><strong>最简单的方案：“至少一次”行为</strong></p>\n<p>1.RPC库等待响应一段时间</p>\n<p>2.如果没有响应到达，重新发送请求</p>\n<p>3.多次尝试</p>\n<p>4.仍然没有响应的话，向应用程序返回一个错误</p>\n<p>5.问题：应用程序容易处理至少一次的操作吗？</p>\n<p>​    至少一次：客户端发送“从银行账户中扣除5美元”</p>\n<p>6.问题：这个客户端程序有什么问题？</p>\n<p>​    put(“k”, 10) 通过RPC在数据库服务器中设置key的值    </p>\n<p>​    put(“k”, 20) 然后客户端执行第二次put操作到同一个key</p>\n<p>7.问题：至少一次总是OK的吗？</p>\n<p>​    1）重复操作是可以的，例如只读操作</p>\n<p>​    2）如果应用程序有自己对于写副本的执行计划</p>\n<p><strong>更好的PRC行为：“至多一次”</strong></p>\n<p>1.想法：服务器RPC代码检测重复请求</p>\n<p>2.返回上一个reply，而不是重新运行处理程序</p>\n<p><strong>如何检测重复的请求</strong></p>\n<p>1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">if seen[xid]:</span><br><span class=\"line\">\tr = old[xid]</span><br><span class=\"line\">else</span><br><span class=\"line\">\tr = handler()</span><br><span class=\"line\">\told[xid] = r</span><br><span class=\"line\">\tseen[xid] = true</span><br></pre></td></tr></table></figure>\n<p><strong>至多一次请求的复杂之处</strong></p>\n<p>1.这将在实验2和以后的实验中出现</p>\n<p>2.如何确保XID是唯一的？</p>\n<p>​    大的随机数？</p>\n<p>​    合并唯一客户端ID（IP地址？）有序列？</p>\n<p>​    服务器必须最终放弃优化旧的RPC的信息</p>\n<p>​    1）什么时候丢弃是安全的</p>\n<p>​    想法：</p>\n<p>​    唯一的客户端ID</p>\n<p>​    上一次客户端RPC请求的序列号</p>\n<p>​    客户端的每一个RPCC包含”seen all replies &lt;= X”</p>\n<p>​    像TCP的sequence号一样</p>\n<p>​    或者一次只允许一个客户端PRC</p>\n<p>​    当seq + 1到达允许服务器放弃所有的 &lt;= seq 的请求</p>\n<p>​    或者客户端同意小于5分钟的重试，5分钟后服务器放弃</p>\n<p>如何处理相同的请求当原来的请求仍然在执行？</p>\n<p>​    服务器不知道要回复，不想重复运行</p>\n<p>​    想法：给每个正在执行的RPC设置一个”pending” flag；等待或者忽略相同的请求</p>\n<p><strong>当一个 at-most-once 服务器宕机和重启怎么办？</strong></p>\n<p>1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求</p>\n<p>2.也许它应该吧重复的信息写到磁盘？</p>\n<p>3.也许副本服务器也应该复制重复的信息？</p>\n<p><strong>“一次就好”怎么样？</strong></p>\n<p>最多一次加上无限制的重试加上容错服务</p>\n<p><strong>Go的RPC是 “at-most-once”</strong></p>\n<p>1.打开TCP连接</p>\n<p>2.向TCP连接中写入请求</p>\n<p>3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求</p>\n<p>4.Go的代码里面没有重试</p>\n<p>5.Go RPC代码在没有得到回复的时候会返回一个error</p>\n<p>1）可能在一个TCP超时之后</p>\n<p>2）可能服务器没有看到请求</p>\n<p>3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败</p>\n<p><strong>Go RPC的 at-most-once 不足以应对Lab1</strong></p>\n<p>1.它只适用于单个RPC调用</p>\n<p>2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败</p>\n<p>3.Go的RPC不能检测出这种重复</p>\n<p>1）在lab1中没问题，它在应用层处理了</p>\n<p>2）Lab2需要明确的检测重复提交</p>\n<p><strong>线程</strong></p>\n<p>1.线程是一个基本的服务结构工具</p>\n<p>2.你将会在lab中广泛的使用它</p>\n<p>3.它们可能很棘手</p>\n<p>4.但是对PRC非常有用</p>\n<p>5.Go称它们为Goroutines，也有很多人称它们为线程</p>\n<p><strong>Thread = “Thread of control”</strong></p>\n<p>1.多线程允许程序逻辑上在同一时刻同时做很多事情</p>\n<p>2.线程共享内存</p>\n<p>3.线程之间共享程序计数器，寄存器，栈空间</p>\n<p><strong>多线程的一些挑战</strong></p>\n<p>1.共享数据</p>\n<p>1）两个线程如果同时修改了相同的变量会怎么样？</p>\n<p>2）一个线程正在读数据，另一个线程改变数据呢？</p>\n<p>3）需要保护共享数据上的不变量</p>\n<p>4）使用Go sync.Mutex锁</p>\n<p>2.线程之间的通过</p>\n<p>例如：等待所有的Map线程完成</p>\n<p>使用Go channels</p>\n<p>3.死锁</p>\n<p>1）线程1等待线程2</p>\n<p>2）线程2等待线程1</p>\n<p>4.锁粒度</p>\n<p>1）粗粒度-&gt;实现简单，但是并发性能不好</p>\n<p>2）细粒度-&gt;更好的并发性能，更多的锁竞争(races)和死锁</p>\n<p>5.让我们来看labrpc 包里如何解决这些问题</p>\n<p>1）它类似于Go的RPC系统，但是网络是一个模拟网络</p>\n<ul>\n<li>网络延迟请求和响应</li>\n<li>网络丢包请求和响应</li>\n<li>网络的重发请求和响应</li>\n</ul>\n<p>2）说明 threads，mutexes，channels的用法</p>\n<p>3）使用Go实现了一个完整的RPC包</p>\n<p><strong>网络的结构</strong></p>\n<p>1.网络的描述</p>\n<p>1）服务器</p>\n<p>2）客户端</p>\n<p>2.每个网络都是互斥的</p>\n<p><strong>RPC概述</strong></p>\n<p>1.在test_test.go文件里面有很多例子</p>\n<p>2.应用调用RPC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reply := end.Call(&quot;Raft.AppendEntries&quot;, args, &amp;reply) //发出一个RPC请求，等待回复</span><br></pre></td></tr></table></figure>\n<p>3.服务端</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srv := MakeServer()</span><br><span class=\"line\">srv.AddService(svc) -- 一个服务器可以有多种服务</span><br></pre></td></tr></table></figure>\n<p>4.k/v</p>\n<p>将srv传递给 net.AddServer()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svc := MakeService(recevierPbject) -- obj&apos;s 方法会处理RPC请求</span><br></pre></td></tr></table></figure>\n<p>非常像Go的rpcs.Register()</p>\n<p>传递svc给 srv.AddService()</p>\n<p>5.服务器的数据结构</p>\n<p>1）AddService()</p>\n<p>添加一个服务名</p>\n<p>问题：为什么使用锁？</p>\n<p>问题：什么事defer()？</p>\n<p>2）Dispatch()</p>\n<p>分发一个请求到正确的服务</p>\n<p>问题：为什么持有锁？</p>\n<p>问题：为什么持有锁的范围互道函数的末尾？</p>\n<p>3）Call()</p>\n<p>使用反射查找参数的类型</p>\n<p>使用gob编码参数</p>\n<p>e.ch 是网络发送请求的通道</p>\n<p>使用一个通道来接收网络的回复（&lt;- req.replyCh）</p>\n<p>4）MakeEnd()</p>\n<p>有一个模拟网络的线程/goroutine</p>\n<p>从e.ch中读取并处理请求</p>\n<p>每个请求都在一个单独的goroutine中处理</p>\n<p>Q：一个endpoint 可以有很多未完成的请求吗</p>\n<p>Q：为什么使用rn.mu.Lock()？</p>\n<p>Q：锁保护了什么？</p>\n<p>5）ProcessReq()</p>\n<p>查找一个服务endpoint</p>\n<p>如果网络不可靠，可能会延迟或者丢失请求</p>\n<p>分发请求到一个新的线程</p>\n<p>通过读取ech中的数据等待服务端回复直到100ms过去</p>\n<p>100ms只是用来验证服务器是不是宕机了</p>\n<p>然后回复</p>\n<p>Q：谁将会读取回复？</p>\n<p>Q：如果ProcessReq不持有rn的锁可以吗？</p>\n<p>6）Service.dispatch()</p>\n<p>给请求找到一个处理的方法</p>\n<p>解码参数</p>\n<p>调用函数</p>\n<p>编码回复</p>\n<p>返回回复信息</p>\n<p>Go的内存模型需要显示同步才能进行通信</p>\n<p>下面代码是不正确的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x int</span><br><span class=\"line\">done := false</span><br><span class=\"line\">go func() &#123; x = f(...); done = true &#125;</span><br><span class=\"line\">while done == false &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个非常诱人的写法，但是Go会说这是为定义的</p>\n<p>使用通道或者sync.WaitGroup代替</p>\n<p><strong>学习Go的goroutines和channels</strong></p>\n<p><a href=\"https://golang.org/doc/articles/race_detector.html\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/articles/race_detector.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"基础设施-RPC-和-线程\"><a href=\"#基础设施-RPC-和-线程\" class=\"headerlink\" title=\"基础设施: RPC 和 线程\"></a>基础设施: RPC 和 线程</h4><p><strong>一个最常被问到的问题:为什么使用Go</strong></p>\n<p><strong><em>6.824这门课原先是使用C++的</em></strong></p>\n<p>学生花了很多时间去修与构建分布式系统无关的bug</p>\n<p>例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象</p>\n<p><strong><em>Go 语言可以让你更专注的处理分布式系统的问题</em></strong></p>\n<p>1.Go语言是类型安全的</p>\n<p>2.它有垃圾收集器（不会存在对象没有free导致的程序bug）</p>\n<p>3.对并发编程的支持很友好</p>\n<p>4.对RPC的支持很友好</p>\n<p><strong><em>我们喜欢用Go编程</em></strong></p>\n<p>1.Go很容易学习</p>\n<p>2.Go语言推荐资料 <a href=\"https://golang.org/doc/effective_go.html#generality\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/effective_go.html#generality</a></p>\n<p><strong>远程过程调用 (RPC)</strong></p>\n<p>1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写</p>\n<p>2.隐藏了客户端/服务器通信的大部分细节</p>\n<p>3.通过RPC客户端的远程调用就像普通的过程调用</p>\n<p>4.服务器的处理程序和普通的程序类似</p>\n<p>5.RPC被广泛使用</p>\n<p><strong>理想情况下，RPC使得网络通信看起来就像函数的调用</strong></p>\n<p>客户端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = fn(x, y)</span><br></pre></td></tr></table></figure>\n<p>服务器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn(x, y) &#123;</span><br><span class=\"line\">    compute</span><br><span class=\"line\">    return z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RPC旨在实现这种透明度的调用</p>\n<p>Go语言RPC的库 <a href=\"https://golang.org/pkg/net/rpc/\" target=\"_blank\" rel=\"noopener\">https://golang.org/pkg/net/rpc/</a></p>\n<p><strong>RPC 消息图</strong></p>\n<p>Client                Server</p>\n<p>request —&gt;</p>\n<p>​            &lt;— response</p>\n<p><strong>软件架构</strong></p>\n<p>客户端应用存根            处理调用</p>\n<p>RPC 库                    RPC库</p>\n<p>Net   ——————————   Net</p>\n<p><strong>更多的细节</strong></p>\n<p>1.要调用服务器的那个处理函数</p>\n<p>2.Marshalling（编组）：将数据格式化为数据包</p>\n<p>​    1）处理数组、指针和对象是很棘手的</p>\n<p>​    2）Go的RPC库是相当强大的</p>\n<p>​    3）有一些东西你不能传送：例如，channels（通道）,functions（函数）</p>\n<p>3.Binding（绑定）:客户端如何知道与谁交互?</p>\n<p>​       1）客户端被提供了服务器的主机名</p>\n<p>​       2）也许名称服务将服务映射到最佳的服务器主机</p>\n<p>4.线程：</p>\n<p>​    1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应</p>\n<p>​    2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序</p>\n<p><strong>RPC问题：如何处理失败</strong></p>\n<p>​    例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃</p>\n<p><strong>客户端RPC库中的故障是什么样的?</strong></p>\n<p>1.客户端从未收到服务器的响应</p>\n<p>2.客户端不知道服务器是否能看到请求</p>\n<p>3.可能服务器或者网络在发送回复之前失败了</p>\n<p><strong>最简单的方案：“至少一次”行为</strong></p>\n<p>1.RPC库等待响应一段时间</p>\n<p>2.如果没有响应到达，重新发送请求</p>\n<p>3.多次尝试</p>\n<p>4.仍然没有响应的话，向应用程序返回一个错误</p>\n<p>5.问题：应用程序容易处理至少一次的操作吗？</p>\n<p>​    至少一次：客户端发送“从银行账户中扣除5美元”</p>\n<p>6.问题：这个客户端程序有什么问题？</p>\n<p>​    put(“k”, 10) 通过RPC在数据库服务器中设置key的值    </p>\n<p>​    put(“k”, 20) 然后客户端执行第二次put操作到同一个key</p>\n<p>7.问题：至少一次总是OK的吗？</p>\n<p>​    1）重复操作是可以的，例如只读操作</p>\n<p>​    2）如果应用程序有自己对于写副本的执行计划</p>\n<p><strong>更好的PRC行为：“至多一次”</strong></p>\n<p>1.想法：服务器RPC代码检测重复请求</p>\n<p>2.返回上一个reply，而不是重新运行处理程序</p>\n<p><strong>如何检测重复的请求</strong></p>\n<p>1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">if seen[xid]:</span><br><span class=\"line\">\tr = old[xid]</span><br><span class=\"line\">else</span><br><span class=\"line\">\tr = handler()</span><br><span class=\"line\">\told[xid] = r</span><br><span class=\"line\">\tseen[xid] = true</span><br></pre></td></tr></table></figure>\n<p><strong>至多一次请求的复杂之处</strong></p>\n<p>1.这将在实验2和以后的实验中出现</p>\n<p>2.如何确保XID是唯一的？</p>\n<p>​    大的随机数？</p>\n<p>​    合并唯一客户端ID（IP地址？）有序列？</p>\n<p>​    服务器必须最终放弃优化旧的RPC的信息</p>\n<p>​    1）什么时候丢弃是安全的</p>\n<p>​    想法：</p>\n<p>​    唯一的客户端ID</p>\n<p>​    上一次客户端RPC请求的序列号</p>\n<p>​    客户端的每一个RPCC包含”seen all replies &lt;= X”</p>\n<p>​    像TCP的sequence号一样</p>\n<p>​    或者一次只允许一个客户端PRC</p>\n<p>​    当seq + 1到达允许服务器放弃所有的 &lt;= seq 的请求</p>\n<p>​    或者客户端同意小于5分钟的重试，5分钟后服务器放弃</p>\n<p>如何处理相同的请求当原来的请求仍然在执行？</p>\n<p>​    服务器不知道要回复，不想重复运行</p>\n<p>​    想法：给每个正在执行的RPC设置一个”pending” flag；等待或者忽略相同的请求</p>\n<p><strong>当一个 at-most-once 服务器宕机和重启怎么办？</strong></p>\n<p>1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求</p>\n<p>2.也许它应该吧重复的信息写到磁盘？</p>\n<p>3.也许副本服务器也应该复制重复的信息？</p>\n<p><strong>“一次就好”怎么样？</strong></p>\n<p>最多一次加上无限制的重试加上容错服务</p>\n<p><strong>Go的RPC是 “at-most-once”</strong></p>\n<p>1.打开TCP连接</p>\n<p>2.向TCP连接中写入请求</p>\n<p>3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求</p>\n<p>4.Go的代码里面没有重试</p>\n<p>5.Go RPC代码在没有得到回复的时候会返回一个error</p>\n<p>1）可能在一个TCP超时之后</p>\n<p>2）可能服务器没有看到请求</p>\n<p>3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败</p>\n<p><strong>Go RPC的 at-most-once 不足以应对Lab1</strong></p>\n<p>1.它只适用于单个RPC调用</p>\n<p>2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败</p>\n<p>3.Go的RPC不能检测出这种重复</p>\n<p>1）在lab1中没问题，它在应用层处理了</p>\n<p>2）Lab2需要明确的检测重复提交</p>\n<p><strong>线程</strong></p>\n<p>1.线程是一个基本的服务结构工具</p>\n<p>2.你将会在lab中广泛的使用它</p>\n<p>3.它们可能很棘手</p>\n<p>4.但是对PRC非常有用</p>\n<p>5.Go称它们为Goroutines，也有很多人称它们为线程</p>\n<p><strong>Thread = “Thread of control”</strong></p>\n<p>1.多线程允许程序逻辑上在同一时刻同时做很多事情</p>\n<p>2.线程共享内存</p>\n<p>3.线程之间共享程序计数器，寄存器，栈空间</p>\n<p><strong>多线程的一些挑战</strong></p>\n<p>1.共享数据</p>\n<p>1）两个线程如果同时修改了相同的变量会怎么样？</p>\n<p>2）一个线程正在读数据，另一个线程改变数据呢？</p>\n<p>3）需要保护共享数据上的不变量</p>\n<p>4）使用Go sync.Mutex锁</p>\n<p>2.线程之间的通过</p>\n<p>例如：等待所有的Map线程完成</p>\n<p>使用Go channels</p>\n<p>3.死锁</p>\n<p>1）线程1等待线程2</p>\n<p>2）线程2等待线程1</p>\n<p>4.锁粒度</p>\n<p>1）粗粒度-&gt;实现简单，但是并发性能不好</p>\n<p>2）细粒度-&gt;更好的并发性能，更多的锁竞争(races)和死锁</p>\n<p>5.让我们来看labrpc 包里如何解决这些问题</p>\n<p>1）它类似于Go的RPC系统，但是网络是一个模拟网络</p>\n<ul>\n<li>网络延迟请求和响应</li>\n<li>网络丢包请求和响应</li>\n<li>网络的重发请求和响应</li>\n</ul>\n<p>2）说明 threads，mutexes，channels的用法</p>\n<p>3）使用Go实现了一个完整的RPC包</p>\n<p><strong>网络的结构</strong></p>\n<p>1.网络的描述</p>\n<p>1）服务器</p>\n<p>2）客户端</p>\n<p>2.每个网络都是互斥的</p>\n<p><strong>RPC概述</strong></p>\n<p>1.在test_test.go文件里面有很多例子</p>\n<p>2.应用调用RPC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reply := end.Call(&quot;Raft.AppendEntries&quot;, args, &amp;reply) //发出一个RPC请求，等待回复</span><br></pre></td></tr></table></figure>\n<p>3.服务端</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srv := MakeServer()</span><br><span class=\"line\">srv.AddService(svc) -- 一个服务器可以有多种服务</span><br></pre></td></tr></table></figure>\n<p>4.k/v</p>\n<p>将srv传递给 net.AddServer()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svc := MakeService(recevierPbject) -- obj&apos;s 方法会处理RPC请求</span><br></pre></td></tr></table></figure>\n<p>非常像Go的rpcs.Register()</p>\n<p>传递svc给 srv.AddService()</p>\n<p>5.服务器的数据结构</p>\n<p>1）AddService()</p>\n<p>添加一个服务名</p>\n<p>问题：为什么使用锁？</p>\n<p>问题：什么事defer()？</p>\n<p>2）Dispatch()</p>\n<p>分发一个请求到正确的服务</p>\n<p>问题：为什么持有锁？</p>\n<p>问题：为什么持有锁的范围互道函数的末尾？</p>\n<p>3）Call()</p>\n<p>使用反射查找参数的类型</p>\n<p>使用gob编码参数</p>\n<p>e.ch 是网络发送请求的通道</p>\n<p>使用一个通道来接收网络的回复（&lt;- req.replyCh）</p>\n<p>4）MakeEnd()</p>\n<p>有一个模拟网络的线程/goroutine</p>\n<p>从e.ch中读取并处理请求</p>\n<p>每个请求都在一个单独的goroutine中处理</p>\n<p>Q：一个endpoint 可以有很多未完成的请求吗</p>\n<p>Q：为什么使用rn.mu.Lock()？</p>\n<p>Q：锁保护了什么？</p>\n<p>5）ProcessReq()</p>\n<p>查找一个服务endpoint</p>\n<p>如果网络不可靠，可能会延迟或者丢失请求</p>\n<p>分发请求到一个新的线程</p>\n<p>通过读取ech中的数据等待服务端回复直到100ms过去</p>\n<p>100ms只是用来验证服务器是不是宕机了</p>\n<p>然后回复</p>\n<p>Q：谁将会读取回复？</p>\n<p>Q：如果ProcessReq不持有rn的锁可以吗？</p>\n<p>6）Service.dispatch()</p>\n<p>给请求找到一个处理的方法</p>\n<p>解码参数</p>\n<p>调用函数</p>\n<p>编码回复</p>\n<p>返回回复信息</p>\n<p>Go的内存模型需要显示同步才能进行通信</p>\n<p>下面代码是不正确的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x int</span><br><span class=\"line\">done := false</span><br><span class=\"line\">go func() &#123; x = f(...); done = true &#125;</span><br><span class=\"line\">while done == false &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个非常诱人的写法，但是Go会说这是为定义的</p>\n<p>使用通道或者sync.WaitGroup代替</p>\n<p><strong>学习Go的goroutines和channels</strong></p>\n<p><a href=\"https://golang.org/doc/articles/race_detector.html\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/articles/race_detector.html</a></p>\n"},{"title":"LEC20-vedio","date":"2019-01-17T04:36:52.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC20-vedio.md","raw":"---\ntitle: LEC20-vedio\ndate: 2019-01-17 12:36:52\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC20-vedio","published":1,"updated":"2019-01-17T04:43:23.603Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw28000rno3yepi298ca","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC3-vedio","date":"2019-01-17T01:35:58.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC3-vedio.md","raw":"---\ntitle: LEC3-vedio\ndate: 2019-01-17 09:35:58\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC3-vedio","published":1,"updated":"2019-01-17T04:50:19.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw2a000tno3ygfjni5zk","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC3","date":"2019-01-24T15:33:17.000Z","_content":"\n**谷歌文件系统(GFS)**\n\n**我们读这篇论文的目的**\n\n1.它是MapReduce操作的文件系统支持\n\n2.存储故障的案例研究\n\n- 交互一致性，实现简单性和性能\n- 后续设计的动机\n\n3.性能好--并行I/O性能好\n\n4.系统方面好的论文—从应用程序到网络的详细信息\n\n5.这篇论文展示了6.824这门课的所有主要主题\n\n- 性能、容错性、一致性\n\n**什么是一致性？**\n\n1.保证正确性的条件\n\n2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要\n\n- 如果应用程序执行写操作，那么后续的读操作会观察到什么？\n- 如果读取操作是来自一个不同的应用程序呢？\n\n3.弱一致性\n\nread（）操作可能返回过时的数据 --- 不是最近写入的结果\n\n4.强一致性\n\nread（）操作总是返回最新写入的数据\n\n5.权衡\n\n- 强一致对应用写入者是有好的\n- 强一致性对性能不友好\n\n6.许多正确性的条件（通常称为一致性模型）\n\n**一致性模型的历史**\n\n1.在体系结构，系统，数据库交互中被广泛使用。\n\n- 具有访问共享内存的专用缓存的并发处理器\n- 访问分布式文件系统的并发客户端\n- 分布式数据库上的并发事务\n\n2.许多不同的模型都有不同的权衡\n\n- 可串行化\n- 顺序一致性\n- 线性化\n- entry的一致性\n- 发布一致性\n\n3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中\n\n**理想的一致性模型**\n\n1.复制文件的行为类似于非复制的文件系统\n\n场景：同一台机器上有许多客户端访问单个磁盘上的文件\n\n2.如果一个应用程序写入，以后的读取会看到写入结果\n\n3.如果两个应用程序并发的写入一个文件会怎么样\n\n在文件系统值通常未定义—文件可能会写入混合乱序的内容\n\n4.如果两个应用程序并发的写入同一个文件夹\n\n```\nOne goes first, the other goes second\n```\n\n**导致不一致的来源**\n\n1.并发操作\n\n2.机器宕机\n\n3.网络分区\n\n**为什么这些想法在一个分布式文件中很难实现**\n\n1.协议会变得很复杂---很难正确的实现系统\n\n2.协议需要客户端和服务器之前的交互，会带来性能开销\n\n**GFS的设计者放弃了同时获得更好性能和简单设计的想法**\n\n1.会使得应用程序的开发者实现更加困难\n\n2.今天的论文主要讨论下面几个特性之间的权衡\n\n- 一致性\n- 容错性\n- 性能\n- 更简单的设计\n\n**GFS的目标**\n\n1.实现一个共享的文件系统\n\n2.成百上千的物理机（以Linux为基础）\n\n3.存储海量数据集\n\n**GFS存了什么？**\n\n1.作者没有实际的说明\n\n2.2003年的猜测\n\n- 搜索索引 & 数据库\n- web上所有的HTML文件\n- web上所有的图片\n\n**文件的属性**\n\n1.多兆字节的数据集\n\n2.很多文件是特别大的\n\n3.作者建议 1M文件 * 100MB = 100TB\n\n但是这是2003年的数据\n\n4.文件都是只追加存储的\n\n**主要挑战**\n\n1.很多机器故障是常见的\n\n假设一台机器每年宕机一次\n\n1000台机器，平均每天就有3台机器宕机\n\n2.高性能：很多并发的写者和读者\n\n- Map/Reduce 任务在GFS中读取和存储最终的结果\n- 注意：不是临时，中间的文件\n\n3.高效的利用网络\n\n**高层面的设计**\n\n1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的\n\n2.100多台带磁盘的块存储(chunk servers)服务器 \n\n- 存储64MB大小的文件块（每个块都是普通的linux文件）\n\n- 每个块存储三个副本在三台服务器上\n\n- 问题：为什么是3x的副本\n\n- 问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡\n\n- 问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？\n\n  是要对整个机器进行容错，而不仅仅是存储设备\n\n- 问题：为什么一个块那么大\n\n3.GFS的Master服务器知道目录的层次结构\n\n- 对于目录，里面存储了什么文件？\n\n- 对于文件，知道每一个64MB块所在的区块服务器\n\n- master将状态保存在内存中\n\n  每个块存储64B 的元数据信息\n\n- master上有元数据的专用可恢复数据库\n\n  master针对断电状况可以迅速的恢复\n\n- Shadow master会比master落后很多，但是可以被变成master\n\n**基本操作**\n\n1.客户端读取：\n\n- 发送文件名以及偏移量给master服务器\n- master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间\n- 请求最近的拥有改文件区块的服务器\n\n2.客户端写入：\n\n- 询问master在哪里存储这个数据\n- 当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储\n- 一个区块服务器是主\n- 它选择更新顺序并转发到两个备份\n\n**两种不同的容错方案**\n\n1.一种是针对master的\n\n2.一种是针对区块服务器的\n\n**针对Master的容错方案**\n\n1.单master\n\n- 客户端总是发请求给master\n- master掌控所有的操作\n\n2.持续存储限制的信息(Stores limited information persistently)\n\n- 名称空间（文件目录）\n- file到chunk的映射\n\n3.在日志中记录对这两项的更改\n\n- 在多个备份机器上复制日志\n- 客户端对状态的在记录写到log中才返回\n- 在后续要读到的很多系统中，log扮演者一个中心角色\n- logs扮演这中心角色在后续的实验中\n\n4.限制log文件的大小\n\n- 给master的状态打一个checkpoint（快照）\n- 移除在checkpoint之前的所有操作日志\n- 将checkpoint复制到备份中\n\n5.恢复\n\n- 从最后一个checkpoint恢复日志\n- 通过询问区块服务器来重新创建区块的位置信息\n\n6.Master是有单点故障风险的\n\n- 恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用\n\n- Shadow master\n\n  落后于master，它们从复制的日志中重播来恢复\n\n  服务器进行只读操作，但是可能返回过时的数据\n\n- 如果master无法恢复，从别处启动master一定要非常小心来避免两个master\n\n- 我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到\n\n**区块的容错性**\n\n1.Master向其中一个副本授予一个租约，这个租约是主区块服务器\n\n2.主决定所有操作\n\n3.客户端将数据推送至副本\n\n- 副本形成一个链\n- 这个链考虑的网络拓扑\n- 允许快速的复制\n\n4.客户端发送写请求到主服务器\n\n- 主分配序列号\n- 主在本地应用更改\n- 主转发请求到副本服务器\n- 主在收到所有副本服务器的请求响应后返回响应客户端\n\n5.如果一个副本没有响应，客户端将重试\n\n6.如果副本数量降到某个数字以下后，则主会重新复制区块\n\n7.主重新平衡副本\n\n**区块的一致性**\n\n1.一些区块可能会过时，它们错过的系统变化的操作\n\n2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器\n\n3.master和区块服务器持久化存储这个版本信息\n\n4.区块的版本信息也会发送给客户端\n\n5.版本号允许master和客户端检测过时数据\n\n**并发写/追加**\n\n1.客户端将并发的写文件的同一Region\n\n2.写入的结果是混合这些写入的--没有保证顺序\n\n- 很少有应用这样做，所以是没问题的\n- UNIX上的并发写入也会导致奇怪的结果\n\n3.许多客户端可能想要并发的追加一个日志文件\n\n- GFS支持原子操作\n- 主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器\n- 如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。\n- 客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）\n- 文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界\n\n**一致性模型**\n\n1.对于文件目录的操作是强一致的\n\n- master对元数据的操作是原子性的\n- 目录的操作遵循下面的想法\n  - 当master伟offline状态时，只有shadow master\n  - 只允许读操作，将有可能返回过期的数据\n\n2.区块的操作是弱一致性的\n\n- 一个失败的操作会导致区块的不一致\n\n  主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的\n\n- 客户端读到的可能不是最新的区块数据\n\n- 当客户端刷新租凭(lease)时，它将了解到新的版本号\n\n3.作者声称弱一致性对于应用来说不是大问题\n\n- 大部分的文件更新操作都是追加的\n- 应用程序可以再附加记录中使用UID来检查重复项\n- 应用程序可能只是读取较少的数据（但不是陈旧的数据）\n- 应用程序可以使用临时文件，或者原子的执行重命名操作\n\n**性能**\n\n1.读取有巨大的吞吐量（3副本）\n\n- 总计125MB/秒\n- 网络链路饱和\n\n2.写入不同文件的次数可能低于最大值\n\n- 作者吐槽了他们的网络栈\n- 网络失效导致了从一个副本传播到下一个副本中间有延迟\n\n3.并发的追加单个文件\n\n受限于存储最后一个区块的服务器\n\n**总结**\n\n1.GFS使用的重要FT技术\n\n- 日志&还原点(checkpoint)\n- 区块的主备复制，但保持一致性\n\n2.GFS优势\n\n- 大量顺序的读和写，追加\n- 大的吞吐量\n- 数据的容灾\n\n3.GFS缺点\n\n- master的容灾\n- 小文件的读写\n- 多个客户端并发的更新同一个文件","source":"_posts/LEC3.md","raw":"---\ntitle: LEC3\ndate: 2019-01-24 23:33:17\ntags: 分布式系统6.824笔记\n---\n\n**谷歌文件系统(GFS)**\n\n**我们读这篇论文的目的**\n\n1.它是MapReduce操作的文件系统支持\n\n2.存储故障的案例研究\n\n- 交互一致性，实现简单性和性能\n- 后续设计的动机\n\n3.性能好--并行I/O性能好\n\n4.系统方面好的论文—从应用程序到网络的详细信息\n\n5.这篇论文展示了6.824这门课的所有主要主题\n\n- 性能、容错性、一致性\n\n**什么是一致性？**\n\n1.保证正确性的条件\n\n2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要\n\n- 如果应用程序执行写操作，那么后续的读操作会观察到什么？\n- 如果读取操作是来自一个不同的应用程序呢？\n\n3.弱一致性\n\nread（）操作可能返回过时的数据 --- 不是最近写入的结果\n\n4.强一致性\n\nread（）操作总是返回最新写入的数据\n\n5.权衡\n\n- 强一致对应用写入者是有好的\n- 强一致性对性能不友好\n\n6.许多正确性的条件（通常称为一致性模型）\n\n**一致性模型的历史**\n\n1.在体系结构，系统，数据库交互中被广泛使用。\n\n- 具有访问共享内存的专用缓存的并发处理器\n- 访问分布式文件系统的并发客户端\n- 分布式数据库上的并发事务\n\n2.许多不同的模型都有不同的权衡\n\n- 可串行化\n- 顺序一致性\n- 线性化\n- entry的一致性\n- 发布一致性\n\n3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中\n\n**理想的一致性模型**\n\n1.复制文件的行为类似于非复制的文件系统\n\n场景：同一台机器上有许多客户端访问单个磁盘上的文件\n\n2.如果一个应用程序写入，以后的读取会看到写入结果\n\n3.如果两个应用程序并发的写入一个文件会怎么样\n\n在文件系统值通常未定义—文件可能会写入混合乱序的内容\n\n4.如果两个应用程序并发的写入同一个文件夹\n\n```\nOne goes first, the other goes second\n```\n\n**导致不一致的来源**\n\n1.并发操作\n\n2.机器宕机\n\n3.网络分区\n\n**为什么这些想法在一个分布式文件中很难实现**\n\n1.协议会变得很复杂---很难正确的实现系统\n\n2.协议需要客户端和服务器之前的交互，会带来性能开销\n\n**GFS的设计者放弃了同时获得更好性能和简单设计的想法**\n\n1.会使得应用程序的开发者实现更加困难\n\n2.今天的论文主要讨论下面几个特性之间的权衡\n\n- 一致性\n- 容错性\n- 性能\n- 更简单的设计\n\n**GFS的目标**\n\n1.实现一个共享的文件系统\n\n2.成百上千的物理机（以Linux为基础）\n\n3.存储海量数据集\n\n**GFS存了什么？**\n\n1.作者没有实际的说明\n\n2.2003年的猜测\n\n- 搜索索引 & 数据库\n- web上所有的HTML文件\n- web上所有的图片\n\n**文件的属性**\n\n1.多兆字节的数据集\n\n2.很多文件是特别大的\n\n3.作者建议 1M文件 * 100MB = 100TB\n\n但是这是2003年的数据\n\n4.文件都是只追加存储的\n\n**主要挑战**\n\n1.很多机器故障是常见的\n\n假设一台机器每年宕机一次\n\n1000台机器，平均每天就有3台机器宕机\n\n2.高性能：很多并发的写者和读者\n\n- Map/Reduce 任务在GFS中读取和存储最终的结果\n- 注意：不是临时，中间的文件\n\n3.高效的利用网络\n\n**高层面的设计**\n\n1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的\n\n2.100多台带磁盘的块存储(chunk servers)服务器 \n\n- 存储64MB大小的文件块（每个块都是普通的linux文件）\n\n- 每个块存储三个副本在三台服务器上\n\n- 问题：为什么是3x的副本\n\n- 问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡\n\n- 问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？\n\n  是要对整个机器进行容错，而不仅仅是存储设备\n\n- 问题：为什么一个块那么大\n\n3.GFS的Master服务器知道目录的层次结构\n\n- 对于目录，里面存储了什么文件？\n\n- 对于文件，知道每一个64MB块所在的区块服务器\n\n- master将状态保存在内存中\n\n  每个块存储64B 的元数据信息\n\n- master上有元数据的专用可恢复数据库\n\n  master针对断电状况可以迅速的恢复\n\n- Shadow master会比master落后很多，但是可以被变成master\n\n**基本操作**\n\n1.客户端读取：\n\n- 发送文件名以及偏移量给master服务器\n- master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间\n- 请求最近的拥有改文件区块的服务器\n\n2.客户端写入：\n\n- 询问master在哪里存储这个数据\n- 当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储\n- 一个区块服务器是主\n- 它选择更新顺序并转发到两个备份\n\n**两种不同的容错方案**\n\n1.一种是针对master的\n\n2.一种是针对区块服务器的\n\n**针对Master的容错方案**\n\n1.单master\n\n- 客户端总是发请求给master\n- master掌控所有的操作\n\n2.持续存储限制的信息(Stores limited information persistently)\n\n- 名称空间（文件目录）\n- file到chunk的映射\n\n3.在日志中记录对这两项的更改\n\n- 在多个备份机器上复制日志\n- 客户端对状态的在记录写到log中才返回\n- 在后续要读到的很多系统中，log扮演者一个中心角色\n- logs扮演这中心角色在后续的实验中\n\n4.限制log文件的大小\n\n- 给master的状态打一个checkpoint（快照）\n- 移除在checkpoint之前的所有操作日志\n- 将checkpoint复制到备份中\n\n5.恢复\n\n- 从最后一个checkpoint恢复日志\n- 通过询问区块服务器来重新创建区块的位置信息\n\n6.Master是有单点故障风险的\n\n- 恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用\n\n- Shadow master\n\n  落后于master，它们从复制的日志中重播来恢复\n\n  服务器进行只读操作，但是可能返回过时的数据\n\n- 如果master无法恢复，从别处启动master一定要非常小心来避免两个master\n\n- 我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到\n\n**区块的容错性**\n\n1.Master向其中一个副本授予一个租约，这个租约是主区块服务器\n\n2.主决定所有操作\n\n3.客户端将数据推送至副本\n\n- 副本形成一个链\n- 这个链考虑的网络拓扑\n- 允许快速的复制\n\n4.客户端发送写请求到主服务器\n\n- 主分配序列号\n- 主在本地应用更改\n- 主转发请求到副本服务器\n- 主在收到所有副本服务器的请求响应后返回响应客户端\n\n5.如果一个副本没有响应，客户端将重试\n\n6.如果副本数量降到某个数字以下后，则主会重新复制区块\n\n7.主重新平衡副本\n\n**区块的一致性**\n\n1.一些区块可能会过时，它们错过的系统变化的操作\n\n2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器\n\n3.master和区块服务器持久化存储这个版本信息\n\n4.区块的版本信息也会发送给客户端\n\n5.版本号允许master和客户端检测过时数据\n\n**并发写/追加**\n\n1.客户端将并发的写文件的同一Region\n\n2.写入的结果是混合这些写入的--没有保证顺序\n\n- 很少有应用这样做，所以是没问题的\n- UNIX上的并发写入也会导致奇怪的结果\n\n3.许多客户端可能想要并发的追加一个日志文件\n\n- GFS支持原子操作\n- 主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器\n- 如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。\n- 客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）\n- 文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界\n\n**一致性模型**\n\n1.对于文件目录的操作是强一致的\n\n- master对元数据的操作是原子性的\n- 目录的操作遵循下面的想法\n  - 当master伟offline状态时，只有shadow master\n  - 只允许读操作，将有可能返回过期的数据\n\n2.区块的操作是弱一致性的\n\n- 一个失败的操作会导致区块的不一致\n\n  主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的\n\n- 客户端读到的可能不是最新的区块数据\n\n- 当客户端刷新租凭(lease)时，它将了解到新的版本号\n\n3.作者声称弱一致性对于应用来说不是大问题\n\n- 大部分的文件更新操作都是追加的\n- 应用程序可以再附加记录中使用UID来检查重复项\n- 应用程序可能只是读取较少的数据（但不是陈旧的数据）\n- 应用程序可以使用临时文件，或者原子的执行重命名操作\n\n**性能**\n\n1.读取有巨大的吞吐量（3副本）\n\n- 总计125MB/秒\n- 网络链路饱和\n\n2.写入不同文件的次数可能低于最大值\n\n- 作者吐槽了他们的网络栈\n- 网络失效导致了从一个副本传播到下一个副本中间有延迟\n\n3.并发的追加单个文件\n\n受限于存储最后一个区块的服务器\n\n**总结**\n\n1.GFS使用的重要FT技术\n\n- 日志&还原点(checkpoint)\n- 区块的主备复制，但保持一致性\n\n2.GFS优势\n\n- 大量顺序的读和写，追加\n- 大的吞吐量\n- 数据的容灾\n\n3.GFS缺点\n\n- master的容灾\n- 小文件的读写\n- 多个客户端并发的更新同一个文件","slug":"LEC3","published":1,"updated":"2019-01-28T05:18:03.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw2d000vno3yoxajm47n","content":"<p><strong>谷歌文件系统(GFS)</strong></p>\n<p><strong>我们读这篇论文的目的</strong></p>\n<p>1.它是MapReduce操作的文件系统支持</p>\n<p>2.存储故障的案例研究</p>\n<ul>\n<li>交互一致性，实现简单性和性能</li>\n<li>后续设计的动机</li>\n</ul>\n<p>3.性能好–并行I/O性能好</p>\n<p>4.系统方面好的论文—从应用程序到网络的详细信息</p>\n<p>5.这篇论文展示了6.824这门课的所有主要主题</p>\n<ul>\n<li>性能、容错性、一致性</li>\n</ul>\n<p><strong>什么是一致性？</strong></p>\n<p>1.保证正确性的条件</p>\n<p>2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要</p>\n<ul>\n<li>如果应用程序执行写操作，那么后续的读操作会观察到什么？</li>\n<li>如果读取操作是来自一个不同的应用程序呢？</li>\n</ul>\n<p>3.弱一致性</p>\n<p>read（）操作可能返回过时的数据 — 不是最近写入的结果</p>\n<p>4.强一致性</p>\n<p>read（）操作总是返回最新写入的数据</p>\n<p>5.权衡</p>\n<ul>\n<li>强一致对应用写入者是有好的</li>\n<li>强一致性对性能不友好</li>\n</ul>\n<p>6.许多正确性的条件（通常称为一致性模型）</p>\n<p><strong>一致性模型的历史</strong></p>\n<p>1.在体系结构，系统，数据库交互中被广泛使用。</p>\n<ul>\n<li>具有访问共享内存的专用缓存的并发处理器</li>\n<li>访问分布式文件系统的并发客户端</li>\n<li>分布式数据库上的并发事务</li>\n</ul>\n<p>2.许多不同的模型都有不同的权衡</p>\n<ul>\n<li>可串行化</li>\n<li>顺序一致性</li>\n<li>线性化</li>\n<li>entry的一致性</li>\n<li>发布一致性</li>\n</ul>\n<p>3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中</p>\n<p><strong>理想的一致性模型</strong></p>\n<p>1.复制文件的行为类似于非复制的文件系统</p>\n<p>场景：同一台机器上有许多客户端访问单个磁盘上的文件</p>\n<p>2.如果一个应用程序写入，以后的读取会看到写入结果</p>\n<p>3.如果两个应用程序并发的写入一个文件会怎么样</p>\n<p>在文件系统值通常未定义—文件可能会写入混合乱序的内容</p>\n<p>4.如果两个应用程序并发的写入同一个文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">One goes first, the other goes second</span><br></pre></td></tr></table></figure>\n<p><strong>导致不一致的来源</strong></p>\n<p>1.并发操作</p>\n<p>2.机器宕机</p>\n<p>3.网络分区</p>\n<p><strong>为什么这些想法在一个分布式文件中很难实现</strong></p>\n<p>1.协议会变得很复杂—很难正确的实现系统</p>\n<p>2.协议需要客户端和服务器之前的交互，会带来性能开销</p>\n<p><strong>GFS的设计者放弃了同时获得更好性能和简单设计的想法</strong></p>\n<p>1.会使得应用程序的开发者实现更加困难</p>\n<p>2.今天的论文主要讨论下面几个特性之间的权衡</p>\n<ul>\n<li>一致性</li>\n<li>容错性</li>\n<li>性能</li>\n<li>更简单的设计</li>\n</ul>\n<p><strong>GFS的目标</strong></p>\n<p>1.实现一个共享的文件系统</p>\n<p>2.成百上千的物理机（以Linux为基础）</p>\n<p>3.存储海量数据集</p>\n<p><strong>GFS存了什么？</strong></p>\n<p>1.作者没有实际的说明</p>\n<p>2.2003年的猜测</p>\n<ul>\n<li>搜索索引 &amp; 数据库</li>\n<li>web上所有的HTML文件</li>\n<li>web上所有的图片</li>\n</ul>\n<p><strong>文件的属性</strong></p>\n<p>1.多兆字节的数据集</p>\n<p>2.很多文件是特别大的</p>\n<p>3.作者建议 1M文件 * 100MB = 100TB</p>\n<p>但是这是2003年的数据</p>\n<p>4.文件都是只追加存储的</p>\n<p><strong>主要挑战</strong></p>\n<p>1.很多机器故障是常见的</p>\n<p>假设一台机器每年宕机一次</p>\n<p>1000台机器，平均每天就有3台机器宕机</p>\n<p>2.高性能：很多并发的写者和读者</p>\n<ul>\n<li>Map/Reduce 任务在GFS中读取和存储最终的结果</li>\n<li>注意：不是临时，中间的文件</li>\n</ul>\n<p>3.高效的利用网络</p>\n<p><strong>高层面的设计</strong></p>\n<p>1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的</p>\n<p>2.100多台带磁盘的块存储(chunk servers)服务器 </p>\n<ul>\n<li><p>存储64MB大小的文件块（每个块都是普通的linux文件）</p>\n</li>\n<li><p>每个块存储三个副本在三台服务器上</p>\n</li>\n<li><p>问题：为什么是3x的副本</p>\n</li>\n<li><p>问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡</p>\n</li>\n<li><p>问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？</p>\n<p>是要对整个机器进行容错，而不仅仅是存储设备</p>\n</li>\n<li><p>问题：为什么一个块那么大</p>\n</li>\n</ul>\n<p>3.GFS的Master服务器知道目录的层次结构</p>\n<ul>\n<li><p>对于目录，里面存储了什么文件？</p>\n</li>\n<li><p>对于文件，知道每一个64MB块所在的区块服务器</p>\n</li>\n<li><p>master将状态保存在内存中</p>\n<p>每个块存储64B 的元数据信息</p>\n</li>\n<li><p>master上有元数据的专用可恢复数据库</p>\n<p>master针对断电状况可以迅速的恢复</p>\n</li>\n<li><p>Shadow master会比master落后很多，但是可以被变成master</p>\n</li>\n</ul>\n<p><strong>基本操作</strong></p>\n<p>1.客户端读取：</p>\n<ul>\n<li>发送文件名以及偏移量给master服务器</li>\n<li>master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间</li>\n<li>请求最近的拥有改文件区块的服务器</li>\n</ul>\n<p>2.客户端写入：</p>\n<ul>\n<li>询问master在哪里存储这个数据</li>\n<li>当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储</li>\n<li>一个区块服务器是主</li>\n<li>它选择更新顺序并转发到两个备份</li>\n</ul>\n<p><strong>两种不同的容错方案</strong></p>\n<p>1.一种是针对master的</p>\n<p>2.一种是针对区块服务器的</p>\n<p><strong>针对Master的容错方案</strong></p>\n<p>1.单master</p>\n<ul>\n<li>客户端总是发请求给master</li>\n<li>master掌控所有的操作</li>\n</ul>\n<p>2.持续存储限制的信息(Stores limited information persistently)</p>\n<ul>\n<li>名称空间（文件目录）</li>\n<li>file到chunk的映射</li>\n</ul>\n<p>3.在日志中记录对这两项的更改</p>\n<ul>\n<li>在多个备份机器上复制日志</li>\n<li>客户端对状态的在记录写到log中才返回</li>\n<li>在后续要读到的很多系统中，log扮演者一个中心角色</li>\n<li>logs扮演这中心角色在后续的实验中</li>\n</ul>\n<p>4.限制log文件的大小</p>\n<ul>\n<li>给master的状态打一个checkpoint（快照）</li>\n<li>移除在checkpoint之前的所有操作日志</li>\n<li>将checkpoint复制到备份中</li>\n</ul>\n<p>5.恢复</p>\n<ul>\n<li>从最后一个checkpoint恢复日志</li>\n<li>通过询问区块服务器来重新创建区块的位置信息</li>\n</ul>\n<p>6.Master是有单点故障风险的</p>\n<ul>\n<li><p>恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用</p>\n</li>\n<li><p>Shadow master</p>\n<p>落后于master，它们从复制的日志中重播来恢复</p>\n<p>服务器进行只读操作，但是可能返回过时的数据</p>\n</li>\n<li><p>如果master无法恢复，从别处启动master一定要非常小心来避免两个master</p>\n</li>\n<li><p>我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到</p>\n</li>\n</ul>\n<p><strong>区块的容错性</strong></p>\n<p>1.Master向其中一个副本授予一个租约，这个租约是主区块服务器</p>\n<p>2.主决定所有操作</p>\n<p>3.客户端将数据推送至副本</p>\n<ul>\n<li>副本形成一个链</li>\n<li>这个链考虑的网络拓扑</li>\n<li>允许快速的复制</li>\n</ul>\n<p>4.客户端发送写请求到主服务器</p>\n<ul>\n<li>主分配序列号</li>\n<li>主在本地应用更改</li>\n<li>主转发请求到副本服务器</li>\n<li>主在收到所有副本服务器的请求响应后返回响应客户端</li>\n</ul>\n<p>5.如果一个副本没有响应，客户端将重试</p>\n<p>6.如果副本数量降到某个数字以下后，则主会重新复制区块</p>\n<p>7.主重新平衡副本</p>\n<p><strong>区块的一致性</strong></p>\n<p>1.一些区块可能会过时，它们错过的系统变化的操作</p>\n<p>2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器</p>\n<p>3.master和区块服务器持久化存储这个版本信息</p>\n<p>4.区块的版本信息也会发送给客户端</p>\n<p>5.版本号允许master和客户端检测过时数据</p>\n<p><strong>并发写/追加</strong></p>\n<p>1.客户端将并发的写文件的同一Region</p>\n<p>2.写入的结果是混合这些写入的–没有保证顺序</p>\n<ul>\n<li>很少有应用这样做，所以是没问题的</li>\n<li>UNIX上的并发写入也会导致奇怪的结果</li>\n</ul>\n<p>3.许多客户端可能想要并发的追加一个日志文件</p>\n<ul>\n<li>GFS支持原子操作</li>\n<li>主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器</li>\n<li>如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。</li>\n<li>客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）</li>\n<li>文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界</li>\n</ul>\n<p><strong>一致性模型</strong></p>\n<p>1.对于文件目录的操作是强一致的</p>\n<ul>\n<li>master对元数据的操作是原子性的</li>\n<li>目录的操作遵循下面的想法<ul>\n<li>当master伟offline状态时，只有shadow master</li>\n<li>只允许读操作，将有可能返回过期的数据</li>\n</ul>\n</li>\n</ul>\n<p>2.区块的操作是弱一致性的</p>\n<ul>\n<li><p>一个失败的操作会导致区块的不一致</p>\n<p>主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的</p>\n</li>\n<li><p>客户端读到的可能不是最新的区块数据</p>\n</li>\n<li><p>当客户端刷新租凭(lease)时，它将了解到新的版本号</p>\n</li>\n</ul>\n<p>3.作者声称弱一致性对于应用来说不是大问题</p>\n<ul>\n<li>大部分的文件更新操作都是追加的</li>\n<li>应用程序可以再附加记录中使用UID来检查重复项</li>\n<li>应用程序可能只是读取较少的数据（但不是陈旧的数据）</li>\n<li>应用程序可以使用临时文件，或者原子的执行重命名操作</li>\n</ul>\n<p><strong>性能</strong></p>\n<p>1.读取有巨大的吞吐量（3副本）</p>\n<ul>\n<li>总计125MB/秒</li>\n<li>网络链路饱和</li>\n</ul>\n<p>2.写入不同文件的次数可能低于最大值</p>\n<ul>\n<li>作者吐槽了他们的网络栈</li>\n<li>网络失效导致了从一个副本传播到下一个副本中间有延迟</li>\n</ul>\n<p>3.并发的追加单个文件</p>\n<p>受限于存储最后一个区块的服务器</p>\n<p><strong>总结</strong></p>\n<p>1.GFS使用的重要FT技术</p>\n<ul>\n<li>日志&amp;还原点(checkpoint)</li>\n<li>区块的主备复制，但保持一致性</li>\n</ul>\n<p>2.GFS优势</p>\n<ul>\n<li>大量顺序的读和写，追加</li>\n<li>大的吞吐量</li>\n<li>数据的容灾</li>\n</ul>\n<p>3.GFS缺点</p>\n<ul>\n<li>master的容灾</li>\n<li>小文件的读写</li>\n<li>多个客户端并发的更新同一个文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>谷歌文件系统(GFS)</strong></p>\n<p><strong>我们读这篇论文的目的</strong></p>\n<p>1.它是MapReduce操作的文件系统支持</p>\n<p>2.存储故障的案例研究</p>\n<ul>\n<li>交互一致性，实现简单性和性能</li>\n<li>后续设计的动机</li>\n</ul>\n<p>3.性能好–并行I/O性能好</p>\n<p>4.系统方面好的论文—从应用程序到网络的详细信息</p>\n<p>5.这篇论文展示了6.824这门课的所有主要主题</p>\n<ul>\n<li>性能、容错性、一致性</li>\n</ul>\n<p><strong>什么是一致性？</strong></p>\n<p>1.保证正确性的条件</p>\n<p>2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要</p>\n<ul>\n<li>如果应用程序执行写操作，那么后续的读操作会观察到什么？</li>\n<li>如果读取操作是来自一个不同的应用程序呢？</li>\n</ul>\n<p>3.弱一致性</p>\n<p>read（）操作可能返回过时的数据 — 不是最近写入的结果</p>\n<p>4.强一致性</p>\n<p>read（）操作总是返回最新写入的数据</p>\n<p>5.权衡</p>\n<ul>\n<li>强一致对应用写入者是有好的</li>\n<li>强一致性对性能不友好</li>\n</ul>\n<p>6.许多正确性的条件（通常称为一致性模型）</p>\n<p><strong>一致性模型的历史</strong></p>\n<p>1.在体系结构，系统，数据库交互中被广泛使用。</p>\n<ul>\n<li>具有访问共享内存的专用缓存的并发处理器</li>\n<li>访问分布式文件系统的并发客户端</li>\n<li>分布式数据库上的并发事务</li>\n</ul>\n<p>2.许多不同的模型都有不同的权衡</p>\n<ul>\n<li>可串行化</li>\n<li>顺序一致性</li>\n<li>线性化</li>\n<li>entry的一致性</li>\n<li>发布一致性</li>\n</ul>\n<p>3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中</p>\n<p><strong>理想的一致性模型</strong></p>\n<p>1.复制文件的行为类似于非复制的文件系统</p>\n<p>场景：同一台机器上有许多客户端访问单个磁盘上的文件</p>\n<p>2.如果一个应用程序写入，以后的读取会看到写入结果</p>\n<p>3.如果两个应用程序并发的写入一个文件会怎么样</p>\n<p>在文件系统值通常未定义—文件可能会写入混合乱序的内容</p>\n<p>4.如果两个应用程序并发的写入同一个文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">One goes first, the other goes second</span><br></pre></td></tr></table></figure>\n<p><strong>导致不一致的来源</strong></p>\n<p>1.并发操作</p>\n<p>2.机器宕机</p>\n<p>3.网络分区</p>\n<p><strong>为什么这些想法在一个分布式文件中很难实现</strong></p>\n<p>1.协议会变得很复杂—很难正确的实现系统</p>\n<p>2.协议需要客户端和服务器之前的交互，会带来性能开销</p>\n<p><strong>GFS的设计者放弃了同时获得更好性能和简单设计的想法</strong></p>\n<p>1.会使得应用程序的开发者实现更加困难</p>\n<p>2.今天的论文主要讨论下面几个特性之间的权衡</p>\n<ul>\n<li>一致性</li>\n<li>容错性</li>\n<li>性能</li>\n<li>更简单的设计</li>\n</ul>\n<p><strong>GFS的目标</strong></p>\n<p>1.实现一个共享的文件系统</p>\n<p>2.成百上千的物理机（以Linux为基础）</p>\n<p>3.存储海量数据集</p>\n<p><strong>GFS存了什么？</strong></p>\n<p>1.作者没有实际的说明</p>\n<p>2.2003年的猜测</p>\n<ul>\n<li>搜索索引 &amp; 数据库</li>\n<li>web上所有的HTML文件</li>\n<li>web上所有的图片</li>\n</ul>\n<p><strong>文件的属性</strong></p>\n<p>1.多兆字节的数据集</p>\n<p>2.很多文件是特别大的</p>\n<p>3.作者建议 1M文件 * 100MB = 100TB</p>\n<p>但是这是2003年的数据</p>\n<p>4.文件都是只追加存储的</p>\n<p><strong>主要挑战</strong></p>\n<p>1.很多机器故障是常见的</p>\n<p>假设一台机器每年宕机一次</p>\n<p>1000台机器，平均每天就有3台机器宕机</p>\n<p>2.高性能：很多并发的写者和读者</p>\n<ul>\n<li>Map/Reduce 任务在GFS中读取和存储最终的结果</li>\n<li>注意：不是临时，中间的文件</li>\n</ul>\n<p>3.高效的利用网络</p>\n<p><strong>高层面的设计</strong></p>\n<p>1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的</p>\n<p>2.100多台带磁盘的块存储(chunk servers)服务器 </p>\n<ul>\n<li><p>存储64MB大小的文件块（每个块都是普通的linux文件）</p>\n</li>\n<li><p>每个块存储三个副本在三台服务器上</p>\n</li>\n<li><p>问题：为什么是3x的副本</p>\n</li>\n<li><p>问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡</p>\n</li>\n<li><p>问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？</p>\n<p>是要对整个机器进行容错，而不仅仅是存储设备</p>\n</li>\n<li><p>问题：为什么一个块那么大</p>\n</li>\n</ul>\n<p>3.GFS的Master服务器知道目录的层次结构</p>\n<ul>\n<li><p>对于目录，里面存储了什么文件？</p>\n</li>\n<li><p>对于文件，知道每一个64MB块所在的区块服务器</p>\n</li>\n<li><p>master将状态保存在内存中</p>\n<p>每个块存储64B 的元数据信息</p>\n</li>\n<li><p>master上有元数据的专用可恢复数据库</p>\n<p>master针对断电状况可以迅速的恢复</p>\n</li>\n<li><p>Shadow master会比master落后很多，但是可以被变成master</p>\n</li>\n</ul>\n<p><strong>基本操作</strong></p>\n<p>1.客户端读取：</p>\n<ul>\n<li>发送文件名以及偏移量给master服务器</li>\n<li>master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间</li>\n<li>请求最近的拥有改文件区块的服务器</li>\n</ul>\n<p>2.客户端写入：</p>\n<ul>\n<li>询问master在哪里存储这个数据</li>\n<li>当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储</li>\n<li>一个区块服务器是主</li>\n<li>它选择更新顺序并转发到两个备份</li>\n</ul>\n<p><strong>两种不同的容错方案</strong></p>\n<p>1.一种是针对master的</p>\n<p>2.一种是针对区块服务器的</p>\n<p><strong>针对Master的容错方案</strong></p>\n<p>1.单master</p>\n<ul>\n<li>客户端总是发请求给master</li>\n<li>master掌控所有的操作</li>\n</ul>\n<p>2.持续存储限制的信息(Stores limited information persistently)</p>\n<ul>\n<li>名称空间（文件目录）</li>\n<li>file到chunk的映射</li>\n</ul>\n<p>3.在日志中记录对这两项的更改</p>\n<ul>\n<li>在多个备份机器上复制日志</li>\n<li>客户端对状态的在记录写到log中才返回</li>\n<li>在后续要读到的很多系统中，log扮演者一个中心角色</li>\n<li>logs扮演这中心角色在后续的实验中</li>\n</ul>\n<p>4.限制log文件的大小</p>\n<ul>\n<li>给master的状态打一个checkpoint（快照）</li>\n<li>移除在checkpoint之前的所有操作日志</li>\n<li>将checkpoint复制到备份中</li>\n</ul>\n<p>5.恢复</p>\n<ul>\n<li>从最后一个checkpoint恢复日志</li>\n<li>通过询问区块服务器来重新创建区块的位置信息</li>\n</ul>\n<p>6.Master是有单点故障风险的</p>\n<ul>\n<li><p>恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用</p>\n</li>\n<li><p>Shadow master</p>\n<p>落后于master，它们从复制的日志中重播来恢复</p>\n<p>服务器进行只读操作，但是可能返回过时的数据</p>\n</li>\n<li><p>如果master无法恢复，从别处启动master一定要非常小心来避免两个master</p>\n</li>\n<li><p>我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到</p>\n</li>\n</ul>\n<p><strong>区块的容错性</strong></p>\n<p>1.Master向其中一个副本授予一个租约，这个租约是主区块服务器</p>\n<p>2.主决定所有操作</p>\n<p>3.客户端将数据推送至副本</p>\n<ul>\n<li>副本形成一个链</li>\n<li>这个链考虑的网络拓扑</li>\n<li>允许快速的复制</li>\n</ul>\n<p>4.客户端发送写请求到主服务器</p>\n<ul>\n<li>主分配序列号</li>\n<li>主在本地应用更改</li>\n<li>主转发请求到副本服务器</li>\n<li>主在收到所有副本服务器的请求响应后返回响应客户端</li>\n</ul>\n<p>5.如果一个副本没有响应，客户端将重试</p>\n<p>6.如果副本数量降到某个数字以下后，则主会重新复制区块</p>\n<p>7.主重新平衡副本</p>\n<p><strong>区块的一致性</strong></p>\n<p>1.一些区块可能会过时，它们错过的系统变化的操作</p>\n<p>2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器</p>\n<p>3.master和区块服务器持久化存储这个版本信息</p>\n<p>4.区块的版本信息也会发送给客户端</p>\n<p>5.版本号允许master和客户端检测过时数据</p>\n<p><strong>并发写/追加</strong></p>\n<p>1.客户端将并发的写文件的同一Region</p>\n<p>2.写入的结果是混合这些写入的–没有保证顺序</p>\n<ul>\n<li>很少有应用这样做，所以是没问题的</li>\n<li>UNIX上的并发写入也会导致奇怪的结果</li>\n</ul>\n<p>3.许多客户端可能想要并发的追加一个日志文件</p>\n<ul>\n<li>GFS支持原子操作</li>\n<li>主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器</li>\n<li>如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。</li>\n<li>客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）</li>\n<li>文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界</li>\n</ul>\n<p><strong>一致性模型</strong></p>\n<p>1.对于文件目录的操作是强一致的</p>\n<ul>\n<li>master对元数据的操作是原子性的</li>\n<li>目录的操作遵循下面的想法<ul>\n<li>当master伟offline状态时，只有shadow master</li>\n<li>只允许读操作，将有可能返回过期的数据</li>\n</ul>\n</li>\n</ul>\n<p>2.区块的操作是弱一致性的</p>\n<ul>\n<li><p>一个失败的操作会导致区块的不一致</p>\n<p>主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的</p>\n</li>\n<li><p>客户端读到的可能不是最新的区块数据</p>\n</li>\n<li><p>当客户端刷新租凭(lease)时，它将了解到新的版本号</p>\n</li>\n</ul>\n<p>3.作者声称弱一致性对于应用来说不是大问题</p>\n<ul>\n<li>大部分的文件更新操作都是追加的</li>\n<li>应用程序可以再附加记录中使用UID来检查重复项</li>\n<li>应用程序可能只是读取较少的数据（但不是陈旧的数据）</li>\n<li>应用程序可以使用临时文件，或者原子的执行重命名操作</li>\n</ul>\n<p><strong>性能</strong></p>\n<p>1.读取有巨大的吞吐量（3副本）</p>\n<ul>\n<li>总计125MB/秒</li>\n<li>网络链路饱和</li>\n</ul>\n<p>2.写入不同文件的次数可能低于最大值</p>\n<ul>\n<li>作者吐槽了他们的网络栈</li>\n<li>网络失效导致了从一个副本传播到下一个副本中间有延迟</li>\n</ul>\n<p>3.并发的追加单个文件</p>\n<p>受限于存储最后一个区块的服务器</p>\n<p><strong>总结</strong></p>\n<p>1.GFS使用的重要FT技术</p>\n<ul>\n<li>日志&amp;还原点(checkpoint)</li>\n<li>区块的主备复制，但保持一致性</li>\n</ul>\n<p>2.GFS优势</p>\n<ul>\n<li>大量顺序的读和写，追加</li>\n<li>大的吞吐量</li>\n<li>数据的容灾</li>\n</ul>\n<p>3.GFS缺点</p>\n<ul>\n<li>master的容灾</li>\n<li>小文件的读写</li>\n<li>多个客户端并发的更新同一个文件</li>\n</ul>\n"},{"title":"LEC4-vedio","date":"2019-01-17T01:36:13.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC4-vedio.md","raw":"---\ntitle: LEC4-vedio\ndate: 2019-01-17 09:36:13\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC4-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw2f000xno3yh52ab2zl","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC4","date":"2019-02-07T00:52:12.000Z","_content":"\n**今天的主题**\n\n1.主/从复制\n\n- 广泛使用，例如GFS的区块服务器\n- 但是今天被广泛应用于强一致\n- 特别重要，我们需要深入探索它\n\n2.VM-FT案例的学习\n\n**容错性**\n\n1.我们需要构建一个即使失败也能继续的服务\n\n2.高可用：在一些失败后仍然可用\n\n3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。\n\n4.非常困难！\n\n5.非常有用！\n\n**需要一个服务失败模型：我们将尝试处理什么？**\n\n1.独立的故障，停止计算机的故障\n\n- VM-FT假设一次只出现一个故障\n\n2.停电（最终重启）\n\n3.网络分区\n\n4.没有bugs，没有恶意攻击\n\n**核心的想法：复制**\n\n1.两台服务器\n\n2.每个副本保持着服务所需要的状态\n\n3.如果一个副本失效了，其他的可以继续提供服务\n\n**例子：MapReduce里面的matser模型**\n\n1.lab1里面的worker是高可用的，但是没有master\n\n- master是单点故障的\n\n2.我们可以有两个master吗，在一个失败的情况下？\n\n[架构图：M1, M2, workers]\n\n状态：\n\n- worker列表\n- 那些job做完了\n- 那些worker空闲\n- TCP连接的状态\n- 程序计数器\n\n**大的问题**\n\n1.要复制的状态是什么？\n\n2.副本如何获得状态？\n\n3.何时切换到副本服务器？\n\n4.切换的时候是否会表现出异常状态？\n\n5.如何修复，重新集成？\n\n**两个主要的方法**\n\n1.状态转换\n\n- 主服务器执行服务\n- 主服务器项备服务器发送新的状态\n\n2.副本的状态机\n\n- 所有的副本执行所有的操作\n- 如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态\n\n**状态转换更简单**\n\n1.但是状态空间可能比较大，转换起来很慢\n\n2.VM-FT使用复制状态机\n\n**复制状态机是很高效的**\n\n1.与数据相比，如果操作很小，但要正确执行则很复杂\n\n例如：多核心处理器执行操作的顺序，确定性\n\n2.实验使用了复制状态机\n\n**什么是复制状态机？**\n\n1.K/V对的put和get操作\n\n2.x86指令集\n\n3.影响性能和易于实现\n\n- 主/备之间需要多少交互\n- 高度抽象的机器可以交互更少的信息\n- 在x86级别上处理不确定性很难，但在Put/Get级别上更容易实现\n\n4.高级RSM仅适用于使用高级接口的程序\n\n- x86 RSM可以执行任意x86程序\n\n**一种实用的容错虚拟机系统设计**\n\nScales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010\n\n**非常健壮的系统**\n\n1.整个系统复制\n\n2.对应用程序和客户端完全透明\n\n3.任何现有软件的高可用性\n\n4.如果它效果好的话会很神奇的\n\n5.失效模型：\n\n- 独立硬件故障\n- 全站停电\n\n6.仅限于单处理器虚拟机\n\n问题：多核处理器有什么困难\n\n**概述**\n\n1.两种机器，主和备，以及其他机器\n\n2.两种网络连接：客户端到服务器，日志交换的通道\n\n3.用于持久化存储的共享磁盘\n\n4.在“锁定步骤”中备份主\n\n- 主服务器将所有的输入发送到备份\n- 备份输出将被丢弃\n\n5.主和备之间保持心跳\n\n- 如果主失败，开始备执行\n\n**输入是什么？**\n\n1.时钟中断\n\n2.网络中断\n\n3.磁盘中断\n\n**挑战:**\n\n1.使整个系统看起来像一台可靠的服务器\n\n如果主服务器发生故障，副本接管，系统外部会看到什么？\n\n如果主服务器在发送响应之前或之后宕机，客户端的请求会丢失吗？还是执行两次？\n\n什么时候主服务器发送响应给客户端？\n\n2.如何避免两次初筛？\n\n如果日志记录通道中断怎么办？\n\n3.如何保证backup称为primary的精确副本（完全一致）\n\n哪些操作必须发送到副本\n\n时钟中断？\n\n如何处理非决定论\n\n例如：中断必须以主中断相同的指令在备份时发送\n\n","source":"_posts/LEC4.md","raw":"---\ntitle: LEC4\ndate: 2019-02-07 08:52:12\ntags:\n---\n\n**今天的主题**\n\n1.主/从复制\n\n- 广泛使用，例如GFS的区块服务器\n- 但是今天被广泛应用于强一致\n- 特别重要，我们需要深入探索它\n\n2.VM-FT案例的学习\n\n**容错性**\n\n1.我们需要构建一个即使失败也能继续的服务\n\n2.高可用：在一些失败后仍然可用\n\n3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。\n\n4.非常困难！\n\n5.非常有用！\n\n**需要一个服务失败模型：我们将尝试处理什么？**\n\n1.独立的故障，停止计算机的故障\n\n- VM-FT假设一次只出现一个故障\n\n2.停电（最终重启）\n\n3.网络分区\n\n4.没有bugs，没有恶意攻击\n\n**核心的想法：复制**\n\n1.两台服务器\n\n2.每个副本保持着服务所需要的状态\n\n3.如果一个副本失效了，其他的可以继续提供服务\n\n**例子：MapReduce里面的matser模型**\n\n1.lab1里面的worker是高可用的，但是没有master\n\n- master是单点故障的\n\n2.我们可以有两个master吗，在一个失败的情况下？\n\n[架构图：M1, M2, workers]\n\n状态：\n\n- worker列表\n- 那些job做完了\n- 那些worker空闲\n- TCP连接的状态\n- 程序计数器\n\n**大的问题**\n\n1.要复制的状态是什么？\n\n2.副本如何获得状态？\n\n3.何时切换到副本服务器？\n\n4.切换的时候是否会表现出异常状态？\n\n5.如何修复，重新集成？\n\n**两个主要的方法**\n\n1.状态转换\n\n- 主服务器执行服务\n- 主服务器项备服务器发送新的状态\n\n2.副本的状态机\n\n- 所有的副本执行所有的操作\n- 如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态\n\n**状态转换更简单**\n\n1.但是状态空间可能比较大，转换起来很慢\n\n2.VM-FT使用复制状态机\n\n**复制状态机是很高效的**\n\n1.与数据相比，如果操作很小，但要正确执行则很复杂\n\n例如：多核心处理器执行操作的顺序，确定性\n\n2.实验使用了复制状态机\n\n**什么是复制状态机？**\n\n1.K/V对的put和get操作\n\n2.x86指令集\n\n3.影响性能和易于实现\n\n- 主/备之间需要多少交互\n- 高度抽象的机器可以交互更少的信息\n- 在x86级别上处理不确定性很难，但在Put/Get级别上更容易实现\n\n4.高级RSM仅适用于使用高级接口的程序\n\n- x86 RSM可以执行任意x86程序\n\n**一种实用的容错虚拟机系统设计**\n\nScales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010\n\n**非常健壮的系统**\n\n1.整个系统复制\n\n2.对应用程序和客户端完全透明\n\n3.任何现有软件的高可用性\n\n4.如果它效果好的话会很神奇的\n\n5.失效模型：\n\n- 独立硬件故障\n- 全站停电\n\n6.仅限于单处理器虚拟机\n\n问题：多核处理器有什么困难\n\n**概述**\n\n1.两种机器，主和备，以及其他机器\n\n2.两种网络连接：客户端到服务器，日志交换的通道\n\n3.用于持久化存储的共享磁盘\n\n4.在“锁定步骤”中备份主\n\n- 主服务器将所有的输入发送到备份\n- 备份输出将被丢弃\n\n5.主和备之间保持心跳\n\n- 如果主失败，开始备执行\n\n**输入是什么？**\n\n1.时钟中断\n\n2.网络中断\n\n3.磁盘中断\n\n**挑战:**\n\n1.使整个系统看起来像一台可靠的服务器\n\n如果主服务器发生故障，副本接管，系统外部会看到什么？\n\n如果主服务器在发送响应之前或之后宕机，客户端的请求会丢失吗？还是执行两次？\n\n什么时候主服务器发送响应给客户端？\n\n2.如何避免两次初筛？\n\n如果日志记录通道中断怎么办？\n\n3.如何保证backup称为primary的精确副本（完全一致）\n\n哪些操作必须发送到副本\n\n时钟中断？\n\n如何处理非决定论\n\n例如：中断必须以主中断相同的指令在备份时发送\n\n","slug":"LEC4","published":1,"updated":"2019-03-23T08:18:47.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw2h000zno3ymk6j5uux","content":"<p><strong>今天的主题</strong></p>\n<p>1.主/从复制</p>\n<ul>\n<li>广泛使用，例如GFS的区块服务器</li>\n<li>但是今天被广泛应用于强一致</li>\n<li>特别重要，我们需要深入探索它</li>\n</ul>\n<p>2.VM-FT案例的学习</p>\n<p><strong>容错性</strong></p>\n<p>1.我们需要构建一个即使失败也能继续的服务</p>\n<p>2.高可用：在一些失败后仍然可用</p>\n<p>3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。</p>\n<p>4.非常困难！</p>\n<p>5.非常有用！</p>\n<p><strong>需要一个服务失败模型：我们将尝试处理什么？</strong></p>\n<p>1.独立的故障，停止计算机的故障</p>\n<ul>\n<li>VM-FT假设一次只出现一个故障</li>\n</ul>\n<p>2.停电（最终重启）</p>\n<p>3.网络分区</p>\n<p>4.没有bugs，没有恶意攻击</p>\n<p><strong>核心的想法：复制</strong></p>\n<p>1.两台服务器</p>\n<p>2.每个副本保持着服务所需要的状态</p>\n<p>3.如果一个副本失效了，其他的可以继续提供服务</p>\n<p><strong>例子：MapReduce里面的matser模型</strong></p>\n<p>1.lab1里面的worker是高可用的，但是没有master</p>\n<ul>\n<li>master是单点故障的</li>\n</ul>\n<p>2.我们可以有两个master吗，在一个失败的情况下？</p>\n<p>[架构图：M1, M2, workers]</p>\n<p>状态：</p>\n<ul>\n<li>worker列表</li>\n<li>那些job做完了</li>\n<li>那些worker空闲</li>\n<li>TCP连接的状态</li>\n<li>程序计数器</li>\n</ul>\n<p><strong>大的问题</strong></p>\n<p>1.要复制的状态是什么？</p>\n<p>2.副本如何获得状态？</p>\n<p>3.何时切换到副本服务器？</p>\n<p>4.切换的时候是否会表现出异常状态？</p>\n<p>5.如何修复，重新集成？</p>\n<p><strong>两个主要的方法</strong></p>\n<p>1.状态转换</p>\n<ul>\n<li>主服务器执行服务</li>\n<li>主服务器项备服务器发送新的状态</li>\n</ul>\n<p>2.副本的状态机</p>\n<ul>\n<li>所有的副本执行所有的操作</li>\n<li>如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态</li>\n</ul>\n<p><strong>状态转换更简单</strong></p>\n<p>1.但是状态空间可能比较大，转换起来很慢</p>\n<p>2.VM-FT使用复制状态机</p>\n<p><strong>复制状态机是很高效的</strong></p>\n<p>1.与数据相比，如果操作很小，但要正确执行则很复杂</p>\n<p>例如：多核心处理器执行操作的顺序，确定性</p>\n<p>2.实验使用了复制状态机</p>\n<p><strong>什么是复制状态机？</strong></p>\n<p>1.K/V对的put和get操作</p>\n<p>2.x86指令集</p>\n<p>3.影响性能和易于实现</p>\n<ul>\n<li>主/备之间需要多少交互</li>\n<li>高度抽象的机器可以交互更少的信息</li>\n<li>在x86级别上处理不确定性很难，但在Put/Get级别上更容易实现</li>\n</ul>\n<p>4.高级RSM仅适用于使用高级接口的程序</p>\n<ul>\n<li>x86 RSM可以执行任意x86程序</li>\n</ul>\n<p><strong>一种实用的容错虚拟机系统设计</strong></p>\n<p>Scales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010</p>\n<p><strong>非常健壮的系统</strong></p>\n<p>1.整个系统复制</p>\n<p>2.对应用程序和客户端完全透明</p>\n<p>3.任何现有软件的高可用性</p>\n<p>4.如果它效果好的话会很神奇的</p>\n<p>5.失效模型：</p>\n<ul>\n<li>独立硬件故障</li>\n<li>全站停电</li>\n</ul>\n<p>6.仅限于单处理器虚拟机</p>\n<p>问题：多核处理器有什么困难</p>\n<p><strong>概述</strong></p>\n<p>1.两种机器，主和备，以及其他机器</p>\n<p>2.两种网络连接：客户端到服务器，日志交换的通道</p>\n<p>3.用于持久化存储的共享磁盘</p>\n<p>4.在“锁定步骤”中备份主</p>\n<ul>\n<li>主服务器将所有的输入发送到备份</li>\n<li>备份输出将被丢弃</li>\n</ul>\n<p>5.主和备之间保持心跳</p>\n<ul>\n<li>如果主失败，开始备执行</li>\n</ul>\n<p><strong>输入是什么？</strong></p>\n<p>1.时钟中断</p>\n<p>2.网络中断</p>\n<p>3.磁盘中断</p>\n<p><strong>挑战:</strong></p>\n<p>1.使整个系统看起来像一台可靠的服务器</p>\n<p>如果主服务器发生故障，副本接管，系统外部会看到什么？</p>\n<p>如果主服务器在发送响应之前或之后宕机，客户端的请求会丢失吗？还是执行两次？</p>\n<p>什么时候主服务器发送响应给客户端？</p>\n<p>2.如何避免两次初筛？</p>\n<p>如果日志记录通道中断怎么办？</p>\n<p>3.如何保证backup称为primary的精确副本（完全一致）</p>\n<p>哪些操作必须发送到副本</p>\n<p>时钟中断？</p>\n<p>如何处理非决定论</p>\n<p>例如：中断必须以主中断相同的指令在备份时发送</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>今天的主题</strong></p>\n<p>1.主/从复制</p>\n<ul>\n<li>广泛使用，例如GFS的区块服务器</li>\n<li>但是今天被广泛应用于强一致</li>\n<li>特别重要，我们需要深入探索它</li>\n</ul>\n<p>2.VM-FT案例的学习</p>\n<p><strong>容错性</strong></p>\n<p>1.我们需要构建一个即使失败也能继续的服务</p>\n<p>2.高可用：在一些失败后仍然可用</p>\n<p>3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。</p>\n<p>4.非常困难！</p>\n<p>5.非常有用！</p>\n<p><strong>需要一个服务失败模型：我们将尝试处理什么？</strong></p>\n<p>1.独立的故障，停止计算机的故障</p>\n<ul>\n<li>VM-FT假设一次只出现一个故障</li>\n</ul>\n<p>2.停电（最终重启）</p>\n<p>3.网络分区</p>\n<p>4.没有bugs，没有恶意攻击</p>\n<p><strong>核心的想法：复制</strong></p>\n<p>1.两台服务器</p>\n<p>2.每个副本保持着服务所需要的状态</p>\n<p>3.如果一个副本失效了，其他的可以继续提供服务</p>\n<p><strong>例子：MapReduce里面的matser模型</strong></p>\n<p>1.lab1里面的worker是高可用的，但是没有master</p>\n<ul>\n<li>master是单点故障的</li>\n</ul>\n<p>2.我们可以有两个master吗，在一个失败的情况下？</p>\n<p>[架构图：M1, M2, workers]</p>\n<p>状态：</p>\n<ul>\n<li>worker列表</li>\n<li>那些job做完了</li>\n<li>那些worker空闲</li>\n<li>TCP连接的状态</li>\n<li>程序计数器</li>\n</ul>\n<p><strong>大的问题</strong></p>\n<p>1.要复制的状态是什么？</p>\n<p>2.副本如何获得状态？</p>\n<p>3.何时切换到副本服务器？</p>\n<p>4.切换的时候是否会表现出异常状态？</p>\n<p>5.如何修复，重新集成？</p>\n<p><strong>两个主要的方法</strong></p>\n<p>1.状态转换</p>\n<ul>\n<li>主服务器执行服务</li>\n<li>主服务器项备服务器发送新的状态</li>\n</ul>\n<p>2.副本的状态机</p>\n<ul>\n<li>所有的副本执行所有的操作</li>\n<li>如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态</li>\n</ul>\n<p><strong>状态转换更简单</strong></p>\n<p>1.但是状态空间可能比较大，转换起来很慢</p>\n<p>2.VM-FT使用复制状态机</p>\n<p><strong>复制状态机是很高效的</strong></p>\n<p>1.与数据相比，如果操作很小，但要正确执行则很复杂</p>\n<p>例如：多核心处理器执行操作的顺序，确定性</p>\n<p>2.实验使用了复制状态机</p>\n<p><strong>什么是复制状态机？</strong></p>\n<p>1.K/V对的put和get操作</p>\n<p>2.x86指令集</p>\n<p>3.影响性能和易于实现</p>\n<ul>\n<li>主/备之间需要多少交互</li>\n<li>高度抽象的机器可以交互更少的信息</li>\n<li>在x86级别上处理不确定性很难，但在Put/Get级别上更容易实现</li>\n</ul>\n<p>4.高级RSM仅适用于使用高级接口的程序</p>\n<ul>\n<li>x86 RSM可以执行任意x86程序</li>\n</ul>\n<p><strong>一种实用的容错虚拟机系统设计</strong></p>\n<p>Scales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010</p>\n<p><strong>非常健壮的系统</strong></p>\n<p>1.整个系统复制</p>\n<p>2.对应用程序和客户端完全透明</p>\n<p>3.任何现有软件的高可用性</p>\n<p>4.如果它效果好的话会很神奇的</p>\n<p>5.失效模型：</p>\n<ul>\n<li>独立硬件故障</li>\n<li>全站停电</li>\n</ul>\n<p>6.仅限于单处理器虚拟机</p>\n<p>问题：多核处理器有什么困难</p>\n<p><strong>概述</strong></p>\n<p>1.两种机器，主和备，以及其他机器</p>\n<p>2.两种网络连接：客户端到服务器，日志交换的通道</p>\n<p>3.用于持久化存储的共享磁盘</p>\n<p>4.在“锁定步骤”中备份主</p>\n<ul>\n<li>主服务器将所有的输入发送到备份</li>\n<li>备份输出将被丢弃</li>\n</ul>\n<p>5.主和备之间保持心跳</p>\n<ul>\n<li>如果主失败，开始备执行</li>\n</ul>\n<p><strong>输入是什么？</strong></p>\n<p>1.时钟中断</p>\n<p>2.网络中断</p>\n<p>3.磁盘中断</p>\n<p><strong>挑战:</strong></p>\n<p>1.使整个系统看起来像一台可靠的服务器</p>\n<p>如果主服务器发生故障，副本接管，系统外部会看到什么？</p>\n<p>如果主服务器在发送响应之前或之后宕机，客户端的请求会丢失吗？还是执行两次？</p>\n<p>什么时候主服务器发送响应给客户端？</p>\n<p>2.如何避免两次初筛？</p>\n<p>如果日志记录通道中断怎么办？</p>\n<p>3.如何保证backup称为primary的精确副本（完全一致）</p>\n<p>哪些操作必须发送到副本</p>\n<p>时钟中断？</p>\n<p>如何处理非决定论</p>\n<p>例如：中断必须以主中断相同的指令在备份时发送</p>\n"},{"title":"LEC5-vedio","date":"2019-01-17T01:36:18.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC5-vedio.md","raw":"---\ntitle: LEC5-vedio\ndate: 2019-01-17 09:36:18\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC5-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw2j0011no3ygdoijitn","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC6-vedio","date":"2019-01-17T01:36:22.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC6-vedio.md","raw":"---\ntitle: LEC6-vedio\ndate: 2019-01-17 09:36:22\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC6-vedio","published":1,"updated":"2019-01-17T04:50:19.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw2l0013no3yhe3v7lru","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC7-vedio","date":"2019-01-17T01:36:27.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC7-vedio.md","raw":"---\ntitle: LEC7-vedio\ndate: 2019-01-17 09:36:27\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC7-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw2p0015no3y4hrinc6d","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC8-vedio","date":"2019-01-17T01:36:32.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC8-vedio.md","raw":"---\ntitle: LEC8-vedio\ndate: 2019-01-17 09:36:32\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC8-vedio","published":1,"updated":"2019-01-17T04:50:19.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw2r0017no3yr6mh486m","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC9-vedio","date":"2019-01-17T01:36:36.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC9-vedio.md","raw":"---\ntitle: LEC9-vedio\ndate: 2019-01-17 09:36:36\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC9-vedio","published":1,"updated":"2019-01-17T04:50:19.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw2u0019no3yiue0064d","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"迦百农","date":"2019-03-10T03:26:46.000Z","_content":"\n![迦百农](迦百农/迦百农.jpg)\n\n​\t电影还没有在国内上映，就用特殊手段提前看了。确实是一部分好片，等电影上映到影院补上电影票。\n\n​      《迦百农》是这样一部电影，一旦你看完它，你就想去帮助一个人，成为一个人，让人们生活的更好。卡百农是一部属于全世界的电影，它是如此的真实，把多个尺度，多个层次，多种感情展现的淋漓尽致，贯穿你的心灵。\n\n​\t![002](迦百农/002.jpg)\n\n​\t这部电影讲述了一个出生在贫困中的孩子，他有很多兄弟姐妹，他父母不工作，所以把他们所有的大兄弟姐妹派到街上去买果汁，搬煤气罐…任何能维持生计的东西，但这不应该是一个12岁的孩子应该承受的。父母甚至卖了他们11岁的女儿给房东当老婆，这样他们就可以过上更好的生活，小男孩拼命反抗却无能为力，最后他离家出走，逃离这令人绝望的原生家庭。离家路上，他有幸被非法移民拉希尔领养。虽然拉希尔同样贫困，还偷偷带了一个私生子尤纳斯，可她给予了扎因从未体会的家庭温暖。随着拉希尔被拘留，面临遣返，扎因失去了庇护所。扎因开始独自抚养尤纳斯，他拼尽全力，也无法终止悲剧的轮回。\n\n\n\n![003](迦百农/003.jpg)\n\n​\t这部电影的感情会把你切碎，让你想接触屏幕，去拥抱所有的孩子。\n\n​\t在现实生活中扮演扎恩的男孩子也叫扎恩，他的表演很有力量。很高兴查到一个消息，导演娜丁宣布了他的现状：\n\n> 他目前获得了挪威的护照，已经被安置在那里三、四个月了。他有生以来第一次去上学。他正在学习如何读写。他重新获得了童年。他在花园里玩耍；他不再玩刀子和垃圾了。\n\n![004](迦百农/004.jpg)\n\n​\t可是在嫩巴黎还有无数个案例，那些孩子们，他们的现状呢？","source":"_posts/迦百农.md","raw":"---\ntitle: 迦百农\ndate: 2019-03-10 11:26:46\ntags: movies\n---\n\n![迦百农](迦百农/迦百农.jpg)\n\n​\t电影还没有在国内上映，就用特殊手段提前看了。确实是一部分好片，等电影上映到影院补上电影票。\n\n​      《迦百农》是这样一部电影，一旦你看完它，你就想去帮助一个人，成为一个人，让人们生活的更好。卡百农是一部属于全世界的电影，它是如此的真实，把多个尺度，多个层次，多种感情展现的淋漓尽致，贯穿你的心灵。\n\n​\t![002](迦百农/002.jpg)\n\n​\t这部电影讲述了一个出生在贫困中的孩子，他有很多兄弟姐妹，他父母不工作，所以把他们所有的大兄弟姐妹派到街上去买果汁，搬煤气罐…任何能维持生计的东西，但这不应该是一个12岁的孩子应该承受的。父母甚至卖了他们11岁的女儿给房东当老婆，这样他们就可以过上更好的生活，小男孩拼命反抗却无能为力，最后他离家出走，逃离这令人绝望的原生家庭。离家路上，他有幸被非法移民拉希尔领养。虽然拉希尔同样贫困，还偷偷带了一个私生子尤纳斯，可她给予了扎因从未体会的家庭温暖。随着拉希尔被拘留，面临遣返，扎因失去了庇护所。扎因开始独自抚养尤纳斯，他拼尽全力，也无法终止悲剧的轮回。\n\n\n\n![003](迦百农/003.jpg)\n\n​\t这部电影的感情会把你切碎，让你想接触屏幕，去拥抱所有的孩子。\n\n​\t在现实生活中扮演扎恩的男孩子也叫扎恩，他的表演很有力量。很高兴查到一个消息，导演娜丁宣布了他的现状：\n\n> 他目前获得了挪威的护照，已经被安置在那里三、四个月了。他有生以来第一次去上学。他正在学习如何读写。他重新获得了童年。他在花园里玩耍；他不再玩刀子和垃圾了。\n\n![004](迦百农/004.jpg)\n\n​\t可是在嫩巴黎还有无数个案例，那些孩子们，他们的现状呢？","slug":"迦百农","published":1,"updated":"2019-03-10T06:16:14.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjtsdaw3h001bno3y4f13xmef","content":"<p><img src=\"/2019/03/10/迦百农/迦百农.jpg\" alt=\"迦百农\"></p>\n<p>​    电影还没有在国内上映，就用特殊手段提前看了。确实是一部分好片，等电影上映到影院补上电影票。</p>\n<p>​      《迦百农》是这样一部电影，一旦你看完它，你就想去帮助一个人，成为一个人，让人们生活的更好。卡百农是一部属于全世界的电影，它是如此的真实，把多个尺度，多个层次，多种感情展现的淋漓尽致，贯穿你的心灵。</p>\n<p>​    <img src=\"/2019/03/10/迦百农/002.jpg\" alt=\"002\"></p>\n<p>​    这部电影讲述了一个出生在贫困中的孩子，他有很多兄弟姐妹，他父母不工作，所以把他们所有的大兄弟姐妹派到街上去买果汁，搬煤气罐…任何能维持生计的东西，但这不应该是一个12岁的孩子应该承受的。父母甚至卖了他们11岁的女儿给房东当老婆，这样他们就可以过上更好的生活，小男孩拼命反抗却无能为力，最后他离家出走，逃离这令人绝望的原生家庭。离家路上，他有幸被非法移民拉希尔领养。虽然拉希尔同样贫困，还偷偷带了一个私生子尤纳斯，可她给予了扎因从未体会的家庭温暖。随着拉希尔被拘留，面临遣返，扎因失去了庇护所。扎因开始独自抚养尤纳斯，他拼尽全力，也无法终止悲剧的轮回。</p>\n<p><img src=\"/2019/03/10/迦百农/003.jpg\" alt=\"003\"></p>\n<p>​    这部电影的感情会把你切碎，让你想接触屏幕，去拥抱所有的孩子。</p>\n<p>​    在现实生活中扮演扎恩的男孩子也叫扎恩，他的表演很有力量。很高兴查到一个消息，导演娜丁宣布了他的现状：</p>\n<blockquote>\n<p>他目前获得了挪威的护照，已经被安置在那里三、四个月了。他有生以来第一次去上学。他正在学习如何读写。他重新获得了童年。他在花园里玩耍；他不再玩刀子和垃圾了。</p>\n</blockquote>\n<p><img src=\"/2019/03/10/迦百农/004.jpg\" alt=\"004\"></p>\n<p>​    可是在嫩巴黎还有无数个案例，那些孩子们，他们的现状呢？</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2019/03/10/迦百农/迦百农.jpg\" alt=\"迦百农\"></p>\n<p>​    电影还没有在国内上映，就用特殊手段提前看了。确实是一部分好片，等电影上映到影院补上电影票。</p>\n<p>​      《迦百农》是这样一部电影，一旦你看完它，你就想去帮助一个人，成为一个人，让人们生活的更好。卡百农是一部属于全世界的电影，它是如此的真实，把多个尺度，多个层次，多种感情展现的淋漓尽致，贯穿你的心灵。</p>\n<p>​    <img src=\"/2019/03/10/迦百农/002.jpg\" alt=\"002\"></p>\n<p>​    这部电影讲述了一个出生在贫困中的孩子，他有很多兄弟姐妹，他父母不工作，所以把他们所有的大兄弟姐妹派到街上去买果汁，搬煤气罐…任何能维持生计的东西，但这不应该是一个12岁的孩子应该承受的。父母甚至卖了他们11岁的女儿给房东当老婆，这样他们就可以过上更好的生活，小男孩拼命反抗却无能为力，最后他离家出走，逃离这令人绝望的原生家庭。离家路上，他有幸被非法移民拉希尔领养。虽然拉希尔同样贫困，还偷偷带了一个私生子尤纳斯，可她给予了扎因从未体会的家庭温暖。随着拉希尔被拘留，面临遣返，扎因失去了庇护所。扎因开始独自抚养尤纳斯，他拼尽全力，也无法终止悲剧的轮回。</p>\n<p><img src=\"/2019/03/10/迦百农/003.jpg\" alt=\"003\"></p>\n<p>​    这部电影的感情会把你切碎，让你想接触屏幕，去拥抱所有的孩子。</p>\n<p>​    在现实生活中扮演扎恩的男孩子也叫扎恩，他的表演很有力量。很高兴查到一个消息，导演娜丁宣布了他的现状：</p>\n<blockquote>\n<p>他目前获得了挪威的护照，已经被安置在那里三、四个月了。他有生以来第一次去上学。他正在学习如何读写。他重新获得了童年。他在花园里玩耍；他不再玩刀子和垃圾了。</p>\n</blockquote>\n<p><img src=\"/2019/03/10/迦百农/004.jpg\" alt=\"004\"></p>\n<p>​    可是在嫩巴黎还有无数个案例，那些孩子们，他们的现状呢？</p>\n"}],"PostAsset":[{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/StorageHierarchy.png","slug":"StorageHierarchy.png","post":"cjtsdaw1c0006no3y6kn18m2h","modified":1,"renderable":0},{"_id":"source/_posts/2018总结/2018.jpeg","post":"cjtsdaw0s0000no3y764v269n","slug":"2018.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/迦百农/001.jpg","post":"cjtsdaw3h001bno3y4f13xmef","slug":"001.jpg","modified":1,"renderable":1},{"_id":"source/_posts/迦百农/002.jpg","post":"cjtsdaw3h001bno3y4f13xmef","slug":"002.jpg","modified":1,"renderable":1},{"_id":"source/_posts/迦百农/003.jpg","post":"cjtsdaw3h001bno3y4f13xmef","slug":"003.jpg","modified":1,"renderable":1},{"_id":"source/_posts/迦百农/004.jpg","post":"cjtsdaw3h001bno3y4f13xmef","slug":"004.jpg","modified":1,"renderable":1},{"_id":"source/_posts/迦百农/迦百农.jpg","post":"cjtsdaw3h001bno3y4f13xmef","slug":"迦百农.jpg","modified":1,"renderable":1},{"_id":"source/_posts/LEC1/QQ20190309-231854@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","slug":"QQ20190309-231854@2x.png","modified":1,"renderable":1},{"_id":"source/_posts/LEC1/001.png","slug":"001.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/002.png","slug":"002.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/MapReduce.png","post":"cjtsdaw1l0009no3y8llg85sm","slug":"MapReduce.png","modified":1,"renderable":1},{"_id":"source/_posts/LEC1/MapReduceApi.png","post":"cjtsdaw1l0009no3y8llg85sm","slug":"MapReduceApi.png","modified":1,"renderable":1},{"_id":"source/_posts/LEC1/QQ20190309-230116@2x.png","slug":"QQ20190309-230116@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-230220@2x.png","slug":"QQ20190309-230220@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-230801@2x.png","slug":"QQ20190309-230801@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-231221@2x.png","slug":"QQ20190309-231221@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-231930@2x.png","slug":"QQ20190309-231930@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-233752@2x.png","slug":"QQ20190309-233752@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-234415@2x.png","slug":"QQ20190309-234415@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-234523@2x.png","slug":"QQ20190309-234523@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-234749@2x.png","slug":"QQ20190309-234749@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-235308@2x.png","slug":"QQ20190309-235308@2x.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-101849.png","slug":"QQ20190310-101849.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-102424.png","slug":"QQ20190310-102424.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-103037.png","slug":"QQ20190310-103037.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-103536.png","slug":"QQ20190310-103536.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-103722.png","slug":"QQ20190310-103722.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-104242.png","slug":"QQ20190310-104242.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-104738.png","slug":"QQ20190310-104738.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-104800.png","slug":"QQ20190310-104800.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-105207.png","slug":"QQ20190310-105207.png","post":"cjtsdaw1l0009no3y8llg85sm","modified":1,"renderable":0},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/ACCESSTIMES.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"ACCESSTIMES.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/DirPages.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"DirPages.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/PageLinkList.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"PageLinkList.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction1.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"compaction1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction2.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"compaction2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction3.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"compaction3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction4.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"compaction4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction5.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"compaction5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction6.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"compaction6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/compaction7.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"compaction7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/denormalized1.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"denormalized1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/denormalized2.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"denormalized2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/denormalized3.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"denormalized3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/log1.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"log1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/log2.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"log2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/log3.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"log3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/mmap1.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"mmap1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/mmap2.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"mmap2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/mmap3.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"mmap3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/mmap4.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"mmap4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/mmap5.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"mmap5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/page_header.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"page_header.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/pages.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"pages.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/record-ids.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"record-ids.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/slot-page1.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"slot-page1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/slot-page2.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"slot-page2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple-data.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"tuple-data.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple-header.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"tuple-header.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple1.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"tuple1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple2.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"tuple2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple3.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"tuple3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-Intro-to-Database-Systems-03-notes/tuple4.png","post":"cjtsdaw1c0006no3y6kn18m2h","slug":"tuple4.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cjtsdaw1s000cno3ytfgh6yw6","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw1w000fno3yk628uc17"},{"post_id":"cjtsdaw1i0008no3y04gvxug8","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw1x000hno3yz05464uv"},{"post_id":"cjtsdaw1u000dno3y1txepfuc","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw20000kno3y2v9srltt"},{"post_id":"cjtsdaw1w000gno3yvyxqtuio","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw23000mno3y453y79zh"},{"post_id":"cjtsdaw1l0009no3y8llg85sm","tag_id":"cjtsdaw1v000eno3y0bmf7ods","_id":"cjtsdaw25000ono3ylmnsnoa1"},{"post_id":"cjtsdaw1x000ino3ybb3a4sx6","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw28000qno3ymhw4zdvs"},{"post_id":"cjtsdaw21000lno3yaia8rmaw","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw2a000sno3y7eaeb5pa"},{"post_id":"cjtsdaw1q000bno3y785ydor0","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw2d000uno3y96s6ybkr"},{"post_id":"cjtsdaw23000nno3yx9t1nqzn","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw2f000wno3yc6bl350p"},{"post_id":"cjtsdaw26000pno3yuqczwj5t","tag_id":"cjtsdaw1v000eno3y0bmf7ods","_id":"cjtsdaw2g000yno3y7rxnal9l"},{"post_id":"cjtsdaw28000rno3yepi298ca","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw2i0010no3yg7njlwbc"},{"post_id":"cjtsdaw2a000tno3ygfjni5zk","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw2l0012no3ywa17lzoi"},{"post_id":"cjtsdaw2d000vno3yoxajm47n","tag_id":"cjtsdaw1v000eno3y0bmf7ods","_id":"cjtsdaw2o0014no3y8hy9lyn1"},{"post_id":"cjtsdaw2f000xno3yh52ab2zl","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw2r0016no3yb384btk5"},{"post_id":"cjtsdaw2j0011no3ygdoijitn","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw2t0018no3ysoo2ys9j"},{"post_id":"cjtsdaw2l0013no3yhe3v7lru","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw3h001ano3yco9vadmb"},{"post_id":"cjtsdaw2p0015no3y4hrinc6d","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw3k001cno3y7c35sc9x"},{"post_id":"cjtsdaw2r0017no3yr6mh486m","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw3l001eno3ybk3t28ee"},{"post_id":"cjtsdaw2u0019no3yiue0064d","tag_id":"cjtsdaw1m000ano3ybhu5u24l","_id":"cjtsdaw3l001fno3ycj8c0ogm"},{"post_id":"cjtsdaw3h001bno3y4f13xmef","tag_id":"cjtsdaw3k001dno3y9tof4cok","_id":"cjtsdaw3l001gno3ybk8vdbx1"}],"Tag":[{"name":"6.824视频","_id":"cjtsdaw1m000ano3ybhu5u24l"},{"name":"分布式系统6.824笔记","_id":"cjtsdaw1v000eno3y0bmf7ods"},{"name":"movies","_id":"cjtsdaw3k001dno3y9tof4cok"}]}}
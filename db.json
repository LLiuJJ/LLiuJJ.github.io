{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":1,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"source/MOVIES/index/迦百农.jpg","path":"MOVIES/index/迦百农.jpg","modified":1,"renderable":0},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"cd5aa7a1883ca4c920f0e596e362d606cab46862","modified":1561636639339},{"_id":"source/CNAME","hash":"3dfdb13f5c87fbc05e139def419d9c6cf3134d59","modified":1561550194323},{"_id":"source/favicon.ico","hash":"da48f1f7091f64d77ff8f79694381fb880f753d4","modified":1561550194623},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1561776641389},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1561776641390},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1561776641390},{"_id":"themes/maupassant/README.md","hash":"90032cb3a46f741a3d6198de9f83ce384505519e","modified":1561776641391},{"_id":"themes/maupassant/_config.yml","hash":"4b22faea8b9a00a57eafae48551b092ca4f7647c","modified":1561888128356},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1561776641404},{"_id":"source/LINUX/index.md","hash":"03f2489be3bcaca21452a9c3f3baf19cc25fbd53","modified":1561550194323},{"_id":"source/MOVIES/index.md","hash":"6fcc3dd9f1be20599d77808d6c7158159c07d6db","modified":1561550194324},{"_id":"source/MIT-6-824/index.md","hash":"773b2c248a27a84a7ac053fdc89c2f9bd8bc2e6e","modified":1561550194323},{"_id":"source/about/index.md","hash":"4eaf089e0626c3657ace852cb535dcac4527bb37","modified":1561550194623},{"_id":"source/_posts/.DS_Store","hash":"3871b9ea903894ecda5c6518f4ebd58069ea1375","modified":1561782232175},{"_id":"source/_posts/2018总结.md","hash":"0c7c3ad5febbdabcfd84d8a6fbc65ca7dce83a0a","modified":1561550194325},{"_id":"source/_posts/C-编程思想笔记.md","hash":"68bd25ce6e15d690731b3ba3142cc9aa2720034d","modified":1561550194326},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES.md","hash":"34eb82ad4552bebaa6421c5a0e82638c00cab18e","modified":1561550194326},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES.md","hash":"277c3ad10ae235bc2e882ed15dae0550ee9dde56","modified":1561550194342},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES.md","hash":"5272907413a1924f3344c698d75fd5337cb9723d","modified":1561550194351},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES.md","hash":"3dd7e6171b14ee277f09d1408c45df35a8b27a78","modified":1561550194384},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES.md","hash":"42e21c7e45930cce1f069f22b29449f177fdcf32","modified":1561550194409},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES.md","hash":"c4a1b8b5638e9aebac132bcc865e08b0365509a6","modified":1561550194422},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES.md","hash":"53fdbee475654b648221187230c95c567332f6e5","modified":1561550194446},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES.md","hash":"78ee710327be8280f0889dd29051d46c195ee88f","modified":1561550194483},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES.md","hash":"f12b0fe8a0f3ab8008ee716115f2faacfe9a9df6","modified":1561550194509},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES.md","hash":"97f89aab9ee169225a1b7f72a855499517299000","modified":1561550194530},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES.md","hash":"fc0ca71d480143e7613991730bde0caabab8530a","modified":1561550194553},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES.md","hash":"9c3ea8f0226644a33ac0f7f5047ceb687f4f92b0","modified":1561550194557},{"_id":"source/_posts/CMU-DBMS-COURSE-15-NOTES.md","hash":"36bf0cf3484338c927d3e7d46e2a6ea147d9a162","modified":1561550194572},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES.md","hash":"a4a5229b29c68c4914ff1f7d29165df3ca5da7d3","modified":1561788039595},{"_id":"source/_posts/CMU-DBMS-COURSE-17-NOTES.md","hash":"9f9dbfbcf1e5827f57733e2edad033820f5a88e4","modified":1561550194572},{"_id":"source/_posts/Google-Spanner-Paper.md","hash":"37515d8bd3be1fee2bf82b111ef2464774e28c9f","modified":1561550194573},{"_id":"source/_posts/LEC1-vedio.md","hash":"5b988aefc99504ae1bf2853e46dcc60eeb0bb819","modified":1561550194573},{"_id":"source/_posts/LEC1.md","hash":"8c282e5022d93f47bee1b49c62611c8134d0573b","modified":1561550194573},{"_id":"source/_posts/LEC10-vedio.md","hash":"5e940c9365c11cbcbd91919b5a54e95788b55ff6","modified":1561550194616},{"_id":"source/_posts/LEC12-vedio.md","hash":"b32068cd5bf06fd74b70d5426912be2801a82840","modified":1561550194617},{"_id":"source/_posts/LEC13-vedio.md","hash":"a60aeeba5ee4926cb2a0cbe7a1194946a583bdd4","modified":1561550194617},{"_id":"source/_posts/LEC15-vedio.md","hash":"9707bfaa85b1942eb4b252c733f7c55a69583176","modified":1561550194617},{"_id":"source/_posts/LEC16-vedio.md","hash":"de95a6d1dbd15815282f5acbda63bbf18d0dab98","modified":1561550194617},{"_id":"source/_posts/LEC17-vedio.md","hash":"e25d097a9245e12dce038b46dc42097a69ab23a5","modified":1561550194617},{"_id":"source/_posts/LEC2-vedio.md","hash":"b8aec07f91e03a3750290f75fe59383f46727c04","modified":1561550194617},{"_id":"source/_posts/LEC2.md","hash":"576e1fac0e2a6dbad9b30f293c369e92142727a7","modified":1561550194618},{"_id":"source/_posts/LEC20-vedio.md","hash":"9ce857803f18068fcb42b9d026c3e6ffe74071eb","modified":1561550194618},{"_id":"source/_posts/LEC3-vedio.md","hash":"666a51921fce83637e1131ef6e3a12f6e7618e21","modified":1561550194618},{"_id":"source/_posts/LEC3.md","hash":"8bd66310ee72d819aec75c88d48c8d58a10381d1","modified":1561550194618},{"_id":"source/_posts/LEC4-vedio.md","hash":"08b8550af4981b0a07a97d1918964c4f91fde50c","modified":1561550194618},{"_id":"source/_posts/LEC4.md","hash":"033ff1cb3d6fc576af7f8f0fccc60993d9b6eb94","modified":1561550194618},{"_id":"source/_posts/LEC5-vedio.md","hash":"f2de840e5bb5d921f4a2b8465720b55483e410cf","modified":1561550194619},{"_id":"source/_posts/LEC6-vedio.md","hash":"bc2cc920fedf6f2ecd121ff82855c3644afe1d8e","modified":1561550194619},{"_id":"source/_posts/LEC7-vedio.md","hash":"99cdac660d77588c2b5fa3e1bd37dbb1a8177faa","modified":1561550194619},{"_id":"source/_posts/LEC8-vedio.md","hash":"45d9e4ef1e510ffaad3c57ab69c2021862cbda68","modified":1561550194619},{"_id":"source/_posts/LEC9-vedio.md","hash":"7dc5ce2ddd6a6a106996bb156a0b8e17b17affac","modified":1561550194619},{"_id":"source/_posts/grpc使用.md","hash":"b5c143cc7a58f39965a9533c29fa1d481a763864","modified":1561550194620},{"_id":"source/_posts/一些管用的配置.md","hash":"76219d136923bf5d7b1a185e8fccb37f731b1977","modified":1561785107157},{"_id":"source/_posts/迦百农.md","hash":"42ebb29dce874601a94d31058943e9a9520da459","modified":1561550194620},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1561776641369},{"_id":"themes/maupassant/.git/config","hash":"037345b11c41abb3dbbbd6e0242ced24979a7097","modified":1561776641373},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1561776580276},{"_id":"themes/maupassant/.git/index","hash":"ce0f7c337a7fdd063e39061b93e675c8c49f9fa1","modified":1561776641426},{"_id":"themes/maupassant/.git/packed-refs","hash":"0650516a87bcb11b3dd4edf6bae34f458843447a","modified":1561776641366},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1561776641392},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1561776641392},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1561776641392},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1561776641393},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1561776641393},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1561776641394},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1561776641394},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1561776641395},{"_id":"themes/maupassant/layout/archive.pug","hash":"2fe2cff144c9b7b509b7b6cb1b3acba27aa1d132","modified":1561776641401},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1561776641401},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1561776641402},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1561776641402},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1561776641403},{"_id":"themes/maupassant/layout/post.pug","hash":"f4d17b1b2a590cc076e80d912591648f9e99aeaf","modified":1561776641403},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1561776641403},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1561776641404},{"_id":"source/_posts/2018总结/2018.jpeg","hash":"4b5535ac167a1817a0ead3a0e9b84804f8ed3552","modified":1561550194326},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/DirPages.png","hash":"1058d97b01ac0b38a2112f60adeb1ec85615f258","modified":1561550194328},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction1.png","hash":"ca3385d3e273e2da6b3144ea845f5354e91a66c8","modified":1561550194330},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/PageLinkList.png","hash":"d8663b6b9c840867f6fc168c36ed34f202ec0643","modified":1561550194328},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction2.png","hash":"30c601bd6c188816185e5b1a3f24642a4fbbc5ef","modified":1561550194331},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction3.png","hash":"d317379bcfe0191d8e230c3bdd49ec2560d54caa","modified":1561550194331},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction4.png","hash":"69066e890fafa752a202e33629d59a02ed5bd89f","modified":1561550194331},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction5.png","hash":"0d331d9bb908fe2c94ce2da6ada9cbf3c612de93","modified":1561550194332},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction6.png","hash":"590ccd291c42cf8d48e0506d4fcdc065e42572b8","modified":1561550194332},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/denormalized1.png","hash":"fbdb8c180c8688301fba50ef7ef20470dd000e0b","modified":1561550194333},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/denormalized2.png","hash":"56c063eef0e80da90d958355bb9a3abe05399d97","modified":1561550194333},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/denormalized3.png","hash":"0693c991f8cf4e273420074625247ee045abacf2","modified":1561550194334},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/log1.png","hash":"740d0ad9f81c8bfb854c63744e0235c2691ebae3","modified":1561550194334},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/log2.png","hash":"8d63a07a141cf3e37ee697f66b30cff79d907709","modified":1561550194335},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/log3.png","hash":"e4b102922b6f8c30d24dfba20d7b0b6bf8338a6b","modified":1561550194335},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/mmap1.png","hash":"5d58799183e16e00d8b9a18a282453f034b48a5e","modified":1561550194335},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/page_header.png","hash":"d8ad45b7ff6a58cf6f21e8d1e6f953f4ad31ca0a","modified":1561550194339},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/slot-page1.png","hash":"9081b4fd9b735e25b0834c53d53a741ac29f8339","modified":1561550194340},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/record-ids.png","hash":"86e86429eb2aa6602b9d24664f7b48e37b7cf440","modified":1561550194339},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/slot-page2.png","hash":"17b8b7ab0fb2e087b6acca7cceb235b63ea44c1e","modified":1561550194340},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple-data.png","hash":"28bb1490d69be6b3778798034a95369175dd9f13","modified":1561550194340},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple-header.png","hash":"7c93bb8a2cedd047e3ea43445293d5ffd684d4b0","modified":1561550194341},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple1.png","hash":"21a4bbdb6df922be5b3b2c173e5247965adedd06","modified":1561550194341},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple2.png","hash":"7ae4de0c593f4354b08f5e93d14c52c3232127a3","modified":1561550194341},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple3.png","hash":"3c4a71ab7aa884a8f62cba59e0c7760052e7e024","modified":1561550194342},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple4.png","hash":"fb5b6a7c1858f3fdebb840bbfe355e709e688226","modified":1561550194342},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/DSM.png","hash":"5fd56662c487b6ba83490d6e1e7495249442e711","modified":1561550194343},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/NSM-1.png","hash":"d81eb2aafc47e8f6c13e6417bed3e74a48b5f0fa","modified":1561550194344},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/NSM-2.png","hash":"f1f8f54ddb35c8a9dd1c31943082016208771455","modified":1561550194344},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/NSM-3.png","hash":"42241118f09ea3fbb8d3d3369b36f61ea1afbd44","modified":1561550194344},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/OLAP.png","hash":"f3adfe482a53b0d6a2fafcece699e70eaa943b8c","modified":1561550194346},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/OLTP.png","hash":"45960574dc3fb1bc1d974703191b71d072f91fe5","modified":1561550194346},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/external-f.png","hash":"4b0487eebfb927c09ffedee2be772804b5431fed","modified":1561550194347},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/lager_v.png","hash":"3a2836f26b501d439ec72abb36a22385c9a7bd53","modified":1561550194347},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/oriented1.png","hash":"332e0816a2f77badf14f83929cbfdf7cc9e3e45b","modified":1561550194348},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/oriented2.png","hash":"77fc128770cb15aa24c2840df90aa402af51b0ed","modified":1561550194348},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock1.png","hash":"a31cddc8a32f28b4bba5712301a581765e4ffbdd","modified":1561550194355},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock2.png","hash":"d1bd2f56d0f4ad4782a33fd49235d608cc6276a2","modified":1561550194356},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock3.png","hash":"3f42f923185db9a5d6adef788a5519abee7e2937","modified":1561550194356},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock4.png","hash":"341d92e47b1caecfa260a6757db43bb1d0d38da8","modified":1561550194357},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock5.png","hash":"5206e5d0a575e93adaf57e51641fe38a392f2ea1","modified":1561550194357},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock6.png","hash":"8610a243c1ba15e3090371645823c0a54e62d26b","modified":1561550194358},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock7.png","hash":"8decbb8ac1b3cf1b291dbf090d4c75a618a5206e","modified":1561550194360},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock8.png","hash":"06aa010e976f59d89366b869ce0b5e2452ef12ab","modified":1561550194360},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-page1.png","hash":"b8aa6a0b11f4a8950540b7e9536e7702359fbb25","modified":1561550194361},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-page2.png","hash":"0ddb107f8f60689c747b4aef2eaa61d7f6fcd9b4","modified":1561550194361},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-page3.png","hash":"918ad6e8f6bf56b68848f2db80bcea40927904f7","modified":1561550194362},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre4.png","hash":"01fda32a0873a082dbca2cc8b4bcf37517beba0f","modified":1561550194369},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre5.png","hash":"fd563cd8fe06aa59dd6c75ba4f27fdc57b203848","modified":1561550194370},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre6.png","hash":"39e593e29d49b055fec8793fb8e7e88860415f99","modified":1561550194371},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq1.png","hash":"919613434b187cee8d5df406a82bc9c2f9c02e73","modified":1561550194381},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq2.png","hash":"e3d2d1ddc752e2316cfb93e0e6bcfa1616120f53","modified":1561550194381},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq3.png","hash":"fdb2591284aee42d396fe6992507ec42507be703","modified":1561550194382},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq4.png","hash":"29c8d7aa439c437f46668d3bd01fbcfb97182833","modified":1561550194383},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq5.png","hash":"680715871e8b51f2ba7864990ce7c356dca95be9","modified":1561550194384},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq6.png","hash":"2f42202174292496963a6d41d3a162c0fe98dbe8","modified":1561550194384},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/chained-hash1.png","hash":"18ba178ec065ac1b500b2468e44c915ee843aac4","modified":1561550194385},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/chained-hash2.png","hash":"c9c6969943d0a8276ca688c58fbe5ce0700391c5","modified":1561550194385},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash1.png","hash":"82f1e79bd3cbe49812150920ecb5096cc5e63560","modified":1561550194386},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash2.png","hash":"43e48242b232b0a35aa000004ee8fe059a275445","modified":1561550194386},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash3.png","hash":"d089ab27dbfe9cfd88703a61908e6acac1b93f60","modified":1561550194386},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash4.png","hash":"8242ec1ab6b28a92e7807edf477a988fa6758b96","modified":1561550194387},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash5.png","hash":"c035dfbe1ad685e93a0796e2deccbb358e77fd7a","modified":1561550194387},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash6.png","hash":"d111afe26ee8209de44f55f7f22667b5c0bf31d6","modified":1561550194388},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash7.png","hash":"e20a5ceff05035e055a87e1a9c154913131870d4","modified":1561550194388},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash8.png","hash":"0af35f3b909feb351fbad03a6273038c46bb7441","modified":1561550194389},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash9.png","hash":"220a3e3cc9b8a6abd3de1569ec41d91d4994a640","modified":1561550194390},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash1.png","hash":"f2e9c7161be8e48d582b36354828d4dcac81a3bc","modified":1561550194390},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash2.png","hash":"915ae65b0487c302389188f8d9ec8eab3c2237f2","modified":1561550194390},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash3.png","hash":"ac2a7daeb714da9dfc277751ea078fc399e1c292","modified":1561550194391},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash1.png","hash":"0d29628d360736ded1e871a35f54184996085ca3","modified":1561550194396},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe1.png","hash":"f29331e0100d44aa2ff04826ba345f0b2d4ae2b9","modified":1561550194401},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe2.png","hash":"e51c6457edaef213a4a2929bdd76b918a7248415","modified":1561550194401},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe3.png","hash":"ed509e8fa6d4f0efea2cd300864d4f8e7a5b1e4a","modified":1561550194402},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe4.png","hash":"ddb323943006360ca6259612d15b1958e3acf525","modified":1561550194402},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe5.png","hash":"2f7ee93194b4069ddbeb6fa0ee609f57cc39c62b","modified":1561550194402},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe6.png","hash":"2daa5ce90cad98dd86d1ae065acafb5f28312a33","modified":1561550194403},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/probe-hash.png","hash":"bd178fac714eb7841533646223ebfb1260d22191","modified":1561550194403},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash1.png","hash":"727c5836cd7313c0ba49f842a0a45eb9431c343c","modified":1561550194403},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash2.png","hash":"4d520a50f8fb22416b8fdd894b6202cac0d4b6e7","modified":1561550194404},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash3.png","hash":"41ae8882a2f0eab6548cf0e7b31ad5323ff8e06d","modified":1561550194404},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash4.png","hash":"87faafd0f7ea069ebc3b606d065591b24fecef4e","modified":1561550194404},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash5.png","hash":"2f6e9a75a106f40e0900ddea085b554df0a5ade4","modified":1561550194405},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash6.png","hash":"fda8f33c3617ee7bedae7045e2f99d10c91dda12","modified":1561550194405},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash7.png","hash":"26baefb4e75f18bb3d472eeddcd502d34b4f2af0","modified":1561550194406},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash8.png","hash":"3f4346370a2e881a6ac2ef1ff4e133b20e3b2271","modified":1561550194407},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash9.png","hash":"8667bd7c936000d98909989b0750220283a1003b","modified":1561550194407},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/static-hash2.png","hash":"7bbf70a0b1440172974c6887991854603978b31a","modified":1561550194408},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/static-hash1.png","hash":"97ece76a044c22052e5cc394015ccdd245dc56f2","modified":1561550194408},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/status.png","hash":"5594360533e28654abe453b2d7ff43a942d0748c","modified":1561550194409},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes1.png","hash":"15ece3b1fc92796ad8b588e50d6c7e938f8db55d","modified":1561550194410},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes2.png","hash":"8d8449c4e657b65498b29cead3488daebd5f8bec","modified":1561550194410},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes3.png","hash":"69219525a352ce9d82a93f8b23e40ba6893859c2","modified":1561550194411},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes4.png","hash":"31b05f922a8b04dd1f93174aaa5d29c46ed14d06","modified":1561550194411},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search1.png","hash":"663da548f90b190b3633fd9179c081e6b58a09fb","modified":1561550194413},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search2.png","hash":"8d4d5d9b27ad9d064a7410737e593e310ac081e8","modified":1561550194413},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search3.png","hash":"140aabfde86c913f42d4b01500c5ca1db1546f7c","modified":1561550194414},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree1.png","hash":"6fea9c00b3d012c5a7ef4fac8bf88ab7641b777f","modified":1561550194414},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/bulk-insert1.png","hash":"0fc6e893da3f36061afc0e51de870cb2a4cd8794","modified":1561550194415},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree2.png","hash":"e60632c2b95bbf70ae79a74fdcb54b359405986e","modified":1561550194415},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/bulk-insert2.png","hash":"d860a096bdf7f1a3bdfefa84a3187906cc0f4c0a","modified":1561550194415},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/bulk-insert3.png","hash":"c14cbddc5d07ce85a9062111740329b6bb6b5420","modified":1561550194416},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/duplicate-keys.png","hash":"d51582cc644f4019a9bf8420943ca73a0a5694ce","modified":1561550194416},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling1.png","hash":"b277864d33b89f158c45dba8b1b4ce360d712b02","modified":1561550194416},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling2.png","hash":"0583c63a1ce7632d9183b7deb853b7047be6b832","modified":1561550194417},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling3.png","hash":"446c49201b16118f9909408085e8d31ba3a679d3","modified":1561550194417},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling4.png","hash":"cb937874665399ef77b2190bd18a789db1b552dd","modified":1561550194418},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/prefix-compression1.png","hash":"ae046e6383ccdb3f5c609618517e3c458e4411f6","modified":1561550194418},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling5.png","hash":"9cdc05c30a7cb2bc8f86af093345b65de35f0148","modified":1561550194418},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/prefix-compression2.png","hash":"876101731efd7d755d82fa7ddc1820699aee833d","modified":1561550194418},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search1.png","hash":"1971c725c2fc7cafd63e1f48fb02359334b06704","modified":1561550194419},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search2.png","hash":"cf75f336786d42e66680e5070f467de653892335","modified":1561550194419},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search3.png","hash":"2ec9e999a56fd7514147eda29408c711cabb3249","modified":1561550194419},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search4.png","hash":"5f15b86d5dcd534cc68a528298f130f0d475ff20","modified":1561550194419},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search5.png","hash":"0d1615c51eb69c28647b323ffb56114f9780f5fc","modified":1561550194420},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search6.png","hash":"b746dd510286782f2fb61ad8e52486e07a9d8178","modified":1561550194420},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search7.png","hash":"d078d32835be5fbcc43138476d8908708413f4a5","modified":1561550194420},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/suffix-trun1.png","hash":"6e6c2b8b20ea27c9685ee4eff70324eba6cbf12f","modified":1561550194421},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/suffix-trun2.png","hash":"f6f572fb75267f71dc8f5a54586eb2ad0db80e67","modified":1561550194421},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/value-list.png","hash":"d649d2af20387f859a62fed22b8bcbbb4a465c6e","modified":1561550194421},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/covering-index1.png","hash":"52e6de42d8c3d7acdbe94c5823ad42be3aee22e7","modified":1561550194422},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index1.png","hash":"4730f8d467a03e178d55e8df6a67775efb3893cb","modified":1561550194422},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index2.png","hash":"a89fd694625e9bd7e8f87052bbea6180290d2f38","modified":1561550194422},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index3.png","hash":"b0e02d748a951b2d0efa2a66b0c208313949ee1a","modified":1561550194423},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index4.png","hash":"c631a225338683c4012b75e1ea52a6fd4c6d83ec","modified":1561550194423},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/index-include1.png","hash":"7f4eaa783af9a5b7612ff8a2b550278b0d3c6bdd","modified":1561550194425},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/implicit-index1.png","hash":"50402dfb965512ee362119692b318cb6fa317221","modified":1561550194425},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/index-include2.png","hash":"c992eb3b615f92449ada2dd872931ed63fe4f62f","modified":1561550194426},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/index-include3.png","hash":"14477cf002fcaee8c837bda1e56da1e95ba4a5ec","modified":1561550194426},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index5.png","hash":"2581a0ca2098eac249457374f152922eeab13131","modified":1561550194424},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/observation1.png","hash":"82ba20a3eb26ff541426a06da79f55e4406b31bb","modified":1561550194426},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/observation2.png","hash":"d4a05030cdd5016d5bb98157ad72555c581ec211","modified":1561550194427},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/partial-index1.png","hash":"9b2ea1e92ed3f4c67e439ad976591041d387f8e3","modified":1561550194427},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree-bck1.png","hash":"9f6d91441f7539d12644991e3e3db48ae27edbcd","modified":1561550194428},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree1.png","hash":"34bf37b0543cd5d4daae0858b3074df54dc4ec38","modified":1561550194429},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree10.png","hash":"7492aeb483de6017c512b24979adec9ac29a88a4","modified":1561550194430},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree2.png","hash":"f5d5f16b30e32aab3c0cb63f2dbee4ee3de2488d","modified":1561550194430},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree3.png","hash":"46ab0a0af6e2fd16f311b8df3c8fdd6f806a933a","modified":1561550194431},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree11.png","hash":"4f98c6293636273e0517fda0d0c8648a970144a9","modified":1561550194430},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree5.png","hash":"401405dde29654161520898b316441f7d1220ff2","modified":1561550194432},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree6.png","hash":"50fd52e195633c0f232f6594774e1ec63bf2419c","modified":1561550194432},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree4.png","hash":"91031bd9f0b39b0e61febdf0821b8a14c00d070f","modified":1561550194431},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree7.png","hash":"e3f0afaa2204c92b9275d4d05d034a8feb5a31e0","modified":1561550194433},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree8.png","hash":"fcef685d07a9bbbde0677b2b1a409ead07450db2","modified":1561550194433},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree9.png","hash":"7ed5e30b43a5013d47a359a88e2bbddd4672437e","modified":1561550194433},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list1.png","hash":"29cccf90eee0e39e3649c91fc0a28fb917983464","modified":1561550194434},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list10.png","hash":"e3261788d283d5626aff3925e3de56c228bae8a0","modified":1561550194435},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list11.png","hash":"8b5c9700d752a5e98516c6207f7ac7742e6eb82a","modified":1561550194435},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list12.png","hash":"4043b002f49f840361d4d1ff29ea7885499ddb3e","modified":1561550194436},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list13.png","hash":"abab904c6ecac1fc20ef9aa10d7d11fb9c35044d","modified":1561550194437},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list17.png","hash":"69a7a18f1d95cc2d07acb10722eb9f6bc62bec9d","modified":1561550194439},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list19.png","hash":"a0ace9a5d983c3836740c0308d8b5d99c252a143","modified":1561550194439},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list20.png","hash":"b2cc9a0f5b34c4bb878a86d1868240d514af9738","modified":1561550194441},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list2.png","hash":"9fb51eae4f3d46989f40eaf7ecd26cada1190d84","modified":1561550194440},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list22.png","hash":"a42d9aa19524c0981e5294542a7854d2c864ddee","modified":1561550194442},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list3.png","hash":"3b8ec954f80cb454e044cae53748f6d53ff7584b","modified":1561550194442},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list4.png","hash":"ce43a5c59a56b740742f355317133818b60e03a0","modified":1561550194443},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list5.png","hash":"bbb060fb8b3ad9e90e77a3652f96f5b585bbcb58","modified":1561550194443},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list6.png","hash":"2c20c9af5b8e1e2e2de38545a4661db7d90a7db7","modified":1561550194444},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list7.png","hash":"43bf795d71823c58e14466c369b8b91b2af4cd13","modified":1561550194444},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list8.png","hash":"59b974e0d04d3a600eb789d49ac8cd718960cfad","modified":1561550194445},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list9.png","hash":"fb5b3f84b7edc1c9dc22c09223b16101581a436b","modified":1561550194445},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/wikipadia-example2.png","hash":"47bdef06ff3e6e4e03812f0841c5a4a3f105d067","modified":1561550194446},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better2.png","hash":"c353d12a5835c4e9636c593dbf0b8056fdecacc3","modified":1561550194447},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent3.png","hash":"ce94c33912db315249b049d6e109407ed776ed59","modified":1561550194452},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch13.png","hash":"bfa18ba82ef522eea924d1b756788727bfa6ba50","modified":1561550194459},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch3.png","hash":"df93a2492fccea8cbe07e4622c9b647d55bc3203","modified":1561550194466},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch7.png","hash":"f6b884e8e1537e39cb95940108419c8106f50211","modified":1561550194468},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch22.png","hash":"516239486690f0033b925df7cc4663fd9cb4f306","modified":1561550194464},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan1.png","hash":"ef1367cf27dc21da66d41468c71449c20199e2fc","modified":1561550194470},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan11.png","hash":"0db2f3b65c4cd8b8d6ebc1e11ad668493cece9a8","modified":1561550194471},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan2.png","hash":"6ca311e89dccf12b118897b69b5767f2e23759d1","modified":1561550194473},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan12.png","hash":"46359c9813a674e84394107c2fb5335294f3b270","modified":1561550194471},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan4.png","hash":"b13ea3b0d0cd7d1b9dca0768287517aee84b8ccc","modified":1561550194474},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan5.png","hash":"cd2f6357c2e4da65bb94c5cb7bb7f4298eeb3a94","modified":1561550194475},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan3.png","hash":"d91cc3a10fab1b169e12616e88ae2dd76d0c28fc","modified":1561550194474},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan6.png","hash":"6da67f702371ba3bb8b5b77be521f0dbf820f249","modified":1561550194476},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan8.png","hash":"834842362e998cbbecda013cc9585bcd6202ed0f","modified":1561550194477},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan7.png","hash":"53f4efd694a48dd645b92d4b02406babdc43508b","modified":1561550194476},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr1.png","hash":"fa847c39a52ea23f6599e727ab3914362772ccd9","modified":1561550194479},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr2.png","hash":"4d186442754917649b0b21239cc18b104975a41c","modified":1561550194480},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr3.png","hash":"5d9b693b52d671c937f9c0a4c13b5f23df29f82e","modified":1561550194480},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/observation1.png","hash":"405d22ba6ca28fa826146c8b7c14e4b0f9e63ee1","modified":1561550194483},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-1.png","hash":"7c45fc3ed968bb0f3010bd33dcae0e0ac7d63578","modified":1561550194483},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-2.png","hash":"75d5ef2b6e7cd312e1ceae69beafd7ff9a1ecacf","modified":1561550194484},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/heap-cluster1.png","hash":"5d1ff1fe26804eccec82e7ba069c46c030942537","modified":1561550194489},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/index-scan1.png","hash":"9d2f1f4ac8ede7e50a3230308dd141087292ffb4","modified":1561550194490},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/heap-cluster2.png","hash":"020c9b320df53a9f9bda58dab30fc027abf81a51","modified":1561550194490},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/index-scan2.png","hash":"35b585b78fec7122cc8a123a3a6c4a333836a371","modified":1561550194491},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/mate-model5.png","hash":"251b4d50dfb2ab29df0c09d33c145866c76fead7","modified":1561550194502},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/multi-index-scan1.png","hash":"7f0af9846683f73c9ecd9ee4847e511ed2603621","modified":1561550194503},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/multi-index-scan2.png","hash":"04daa54bbd8f5fbbeca12f1a368c7bd46dad4ee5","modified":1561550194503},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/query-plan.png","hash":"d47d16c781ecdde6dffed0ffddfba72fb3ed7616","modified":1561550194504},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/vect-model3.png","hash":"b38ae31099fe6dd5e5045b570b3790eb102db3a6","modified":1561550194507},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/zone-map3.png","hash":"01e0d2f6f4dfbfdd61442555ff20baf14bea59d4","modified":1561550194509},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-1.png","hash":"4b35a3ea0b8ef01c87c6746a48384835c29ea430","modified":1561550194511},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-2.png","hash":"5247b82d60a3b35088e65cbcf04fd97f5d5c10ca","modified":1561550194511},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/External-merge-sort1.png","hash":"829dc26590a0cb99e20a73439dc8226cbe5b7205","modified":1561550194514},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/External-merge-sort2.png","hash":"da28df603ca71fa5dceb10dc2055de5510fe5b0f","modified":1561550194514},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/External-merge-sort3.png","hash":"0e0acdca47a8d40556622cdd8374680eefdcc10b","modified":1561550194514},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/External-merge-sort4.png","hash":"87dcb1b3a7c5b42d9ae21f4e3a3207f237ffcd0f","modified":1561550194515},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/External-merge-sort5.png","hash":"1542d5c76045294c0ddfe3f730da92fee978ef33","modified":1561550194515},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-1.png","hash":"e9cc1f6e85ba0ef06e82aaf93b583548c3ced4c9","modified":1561550194516},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-2.png","hash":"3c0e406afc963f67cb963adf08701999b7f6367d","modified":1561550194516},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-3.png","hash":"1ac42cae5cf7908b77e30b81834036680ba95df1","modified":1561550194517},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-5.png","hash":"47989613aa951566aab83d76e473c1d9fb737b56","modified":1561550194520},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-6.png","hash":"f45b337728b7619a1ef8dcbf388ba6ba470dfcb0","modified":1561550194520},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-1.png","hash":"3ba47fafdf20aae79a95ab8ff3ae6f43975d44b9","modified":1561550194526},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-2.png","hash":"b7b6be65c3b8c9262c34eae03ee379cb9761c8d3","modified":1561550194527},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-3.png","hash":"328b847934a5e2da5d211d71d030164092051811","modified":1561550194528},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/BASIC-HASH-JOIN-ALGORITHM-1.png","hash":"8714d66e43804fb15520d6a99deb389da3f080c0","modified":1561550194531},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-1.png","hash":"53ac59c46be4d38e4bc19ef96f9c3abcdd56b231","modified":1561550194532},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-2.png","hash":"c5a4f4ad84cfa9cde3c32f026ee5fa7d184a52fb","modified":1561550194532},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-3.png","hash":"0bc78b23e74f766ce8cb6b8db05b02a01757f931","modified":1561550194535},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/Join-OPERATOR-1.png","hash":"ec5dd1d080c8f3b519776a5a7eac163c9fa5a780","modified":1561550194537},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-2.png","hash":"4a457c5f370473bda29e31f3f0ba1126658c1691","modified":1561550194538},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-3.png","hash":"ff06742a93a75bc5a03b2bf08b8269696d3d1afb","modified":1561550194538},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-4.png","hash":"1e130839738fb98b02aab7f8914352a4f01b282c","modified":1561550194539},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-5.png","hash":"812fda0fe1a1717266577ae3d884e334d980603c","modified":1561550194539},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-3.png","hash":"90bd39686fa7edd0e41858814f01c2e0e4124ce6","modified":1561550194537},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-1.png","hash":"16cad44af2ad8ec71608bc3e11684b6f829b300c","modified":1561550194538},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-6.png","hash":"3e6995c1ecfb926f28e52086e9d26d4b2a688d0a","modified":1561550194540},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/Conjunction.png","hash":"cbffc36d98a516297b625fc69bafb98040ab0eb5","modified":1561550194554},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/Disjunction.png","hash":"a142f38b665268009b58588a6cc490720c2f83d7","modified":1561550194554},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN-2.png","hash":"ff562144a0e159d2d901aa5323349606bc142398","modified":1561550194554},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN.png","hash":"16f84b56f7a04b1c1ec839461a83d653dffbf21d","modified":1561550194555},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/PROJECTION-PUSHDOWN-2.png","hash":"07460a300c72d3b78705d100d134dc5d402a7101","modified":1561550194555},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/SC-1.png","hash":"e57461655c58c1805a02483fc12df2662a79dc7e","modified":1561550194556},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/SC-2.png","hash":"07d598349df2a2b5b00f68226644899e8273d02b","modified":1561550194556},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/SC-3.png","hash":"a97370f8bb33ba1c0f1e256d033750a9228928d9","modified":1561550194557},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/SC-4.png","hash":"e0e12dc980735a5a67b50b22e1a1f64d89849b37","modified":1561550194557},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/关系代数等价.png","hash":"ac56262168ba8eae25d904d90d1fb2894879a705","modified":1561550194557},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-1.png","hash":"afa344bacac79644bc9abff52d925a7c34cdc2b2","modified":1561550194558},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-2.png","hash":"5af8ec5f70bf419708b2f4e8157a1e4a2d478565","modified":1561550194559},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/PROCESS-POOL.png","hash":"48209151334dadb9465f66a86821a2c559579ea3","modified":1561550194569},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/PROCESS-PER-WORKER.png","hash":"2e6b3be09ce72d80b622250b846b558410921bca","modified":1561550194569},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING.png","hash":"2e4ef6ac4559b33382650fd6054f5913e0112b5d","modified":1561550194571},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/THREAD-PER-WORKER.png","hash":"ddbf0864f36296c4582f44e6d4c403502a3a7498","modified":1561550194570},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING-2.png","hash":"1b64662ce9f9b696d7bc56a7cb3e94bfe95a30a5","modified":1561550194571},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-1.png","hash":"4c16e38659bdfd85ea5b847cc637a147aac5e13a","modified":1561637900832},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-4.png","hash":"848c7d893b933159103d3f12d8ad77c4350f06e3","modified":1561638000742},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-5.png","hash":"ec62daecc3e9abe894d51bbddf930b0568533df4","modified":1561638014213},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-6.png","hash":"a99356ec8602fde148368a1a8043f1175bbf6efb","modified":1561638023933},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-7.png","hash":"7c18c16e28fb371f123c7d7b7f20363107bd1a32","modified":1561638037147},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-2.png","hash":"d3ba580d91d95c92e6de2ef594bcc565de3a19f4","modified":1561637929468},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-3.png","hash":"661ef9898d90421eb746af16a588b370908d01b5","modified":1561637981321},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/Exmple.png","hash":"2dd3bdf8174bce57aaf2010d7209a3682f7b1974","modified":1561552038317},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/Overwriting-Uncommitted-Data.png","hash":"df6854c4a2111b140e86dcc33faea5bffe3f11f3","modified":1561637074526},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/Reading-Uncommitted-Data.png","hash":"1343b73b2a905a677b51b441602d2591603a5169","modified":1561637008121},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/Unrepeatable-Reads.png","hash":"e38d55b7c6944cf5bea0b78d133e2b90b5a3b729","modified":1561636631820},{"_id":"source/_posts/LEC1/MapReduce.png","hash":"4a0fbb1ac7fe41d83b669f5b465d104a5ad253d6","modified":1561550194581},{"_id":"source/_posts/LEC1/MapReduceApi.png","hash":"94de3afa77383512abd1791e90dfed0ef7dce162","modified":1561550194581},{"_id":"source/_posts/迦百农/002.jpg","hash":"61ec03a4abb8fb8d0b655278ffa59409844b173f","modified":1561550194621},{"_id":"source/_posts/迦百农/004.jpg","hash":"83d88c7b9d191b98417c56ccb9379798122dfcec","modified":1561550194622},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1561776580277},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1561776580276},{"_id":"themes/maupassant/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1561776580278},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1561776580279},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1561776580280},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1561776580277},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1561776580280},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1561776580277},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1561776580278},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1561776580279},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1561776580280},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1561776580275},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"a32031532da8a83d65480ea1eb9397f731ce5c72","modified":1561776641371},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"31bf35a57634ff8a796c71dd5246eba3a3db10ee","modified":1561776641396},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"507fd8d2fde98df6216ed7c8f60ebea7cf77bfb2","modified":1561776641396},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1561776641397},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"8af6e452ea2a56b110b5079f79bf743b643f7d6c","modified":1561776641397},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1561776641397},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1561776641397},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1561776641398},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1561776641398},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1561776641398},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1561776641398},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1561776641399},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1561776641399},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1561776641399},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1561776641400},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1561776641400},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1561776641400},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1561776641400},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1561776641401},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1561776641405},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1561776641405},{"_id":"themes/maupassant/source/css/style.scss","hash":"fa5dfd0867f95fe1708e6fda90e41db6364c01d9","modified":1561776641407},{"_id":"themes/maupassant/source/donate/index.html","hash":"c42428765d48c8674ce28100ad95fdf4c7806a85","modified":1561776641407},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1561776641408},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1561776641408},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1561776641409},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1561776641409},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1561776641409},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1561776641409},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1561776641410},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1561776641411},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1561776641411},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1561776641414},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1561776641418},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1561776641418},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1561776641421},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1561776641421},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1561776641421},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1561776641422},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/ACCESSTIMES.png","hash":"0566c55b3d13aba2a05590e44e43d49e526c1724","modified":1561550194327},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction7.png","hash":"a53bec2de34f72e3e3fa5d941b2a00cf31a6af7c","modified":1561550194333},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/mmap2.png","hash":"cd3c5006557df4359b7b94028bfe1ed53d957d0e","modified":1561550194336},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/mmap3.png","hash":"97e25ba072acf086c67282d512019c240264e348","modified":1561550194337},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/mmap4.png","hash":"4870d768c4955e37784b0c76080a744b2919a2b1","modified":1561550194338},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/mmap5.png","hash":"4cda996d9630f9aa98cebcc7efe337904d73e599","modified":1561550194338},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/pages.png","hash":"da6d4dfc55c1f083bae4190855c7318f3cf02d61","modified":1561550194339},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/OLAP-OLTP.png","hash":"8e7308d42753d5c2a6d4e3fa811ec0a3133a53b2","modified":1561550194345},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/oriented3.png","hash":"d1eff440ba7cff11dfa04d71e6d7140cff700bfc","modified":1561550194349},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/oriented4.png","hash":"8be07be3481c9ca5ffce3c514c295079ef83b9a2","modified":1561550194349},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/oriented5.png","hash":"1866f47b966d4abc19234248bbc8f61331564062","modified":1561550194350},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/var.png","hash":"3663380155465131a1798b26360b885a46fe435e","modified":1561550194351},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/Buffer-pool-meta-data.png","hash":"19f96eb657a3ae21a88156aca95505990e2f28e0","modified":1561550194352},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/Pin.png","hash":"fc045ec2fd4ed43451a86dd6b9cb5c0cc5cc4171","modified":1561550194355},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-pre1.png","hash":"7d3c5dfdf6adedac15803f3ad2b893328381dbdb","modified":1561550194363},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-pre2.png","hash":"c9e449ea15e7d679c322f13cca251764113b6cf4","modified":1561550194364},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-pre3.png","hash":"df631ed575806f419f9eebe9e560ae832979b30e","modified":1561550194364},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-pre4.png","hash":"7631000fade243c8e33d824b95dfd0f751d86d7e","modified":1561550194365},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre1.png","hash":"4f0c68bf73e1fa36e3543dfb9a58afff9a0fc2af","modified":1561550194366},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre2.png","hash":"c93a34842084cd3b4a9e7109c67823541e48defc","modified":1561550194367},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre3.png","hash":"18a523b7475af5bae7fc2cf9beb67e8a57451064","modified":1561550194369},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/read-disk1.png","hash":"5fcf1b310ea0f7f3543b957b255590eab940ee84","modified":1561550194371},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/read-disk2.png","hash":"ffaa09442d3fef9d45528a9e9466cf7311662ce8","modified":1561550194372},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/read-disk3.png","hash":"76c8e61e9e603ad72ec2d6523821c8f17841051e","modified":1561550194372},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan1.png","hash":"1a10823b335e15d7eedd4aba0c5dcfb03a36a618","modified":1561550194373},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan10.png","hash":"d7cc30717d424eac288904243292c7f53bb40e07","modified":1561550194374},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan2.png","hash":"2fc3654dc5f1624ff5badb419a9ccfcf2f5b13b4","modified":1561550194375},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan4.png","hash":"04c07e1d8f2ad902162234348befa1abba10e56f","modified":1561550194376},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan3.png","hash":"c2f96709badb4ff13431c805fc6fed17a229b21f","modified":1561550194376},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan7.png","hash":"19a859471aa9141beb8ac864acc6fb25e1e1c80a","modified":1561550194379},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan8.png","hash":"86edf23a689bbc0891bf58c8053c990ba54c56e3","modified":1561550194380},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan5.png","hash":"b2c63493b8a0801dc29f0daf507d9cac5da97757","modified":1561550194377},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan6.png","hash":"6143372b435bf942044576fa3e12f221b0867a85","modified":1561550194378},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan9.png","hash":"17fd21b28e37ac380a06211c1a8a7f8368a5beda","modified":1561550194380},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash4.png","hash":"18907f6fdd33f4286b4ab0fe6455cbea5a530efa","modified":1561550194391},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash5.png","hash":"e5cb7e75cd2393067c609ff2f63c069758fc8db1","modified":1561550194392},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash6.png","hash":"018d49e7f6418049054cec49f36a9bf256e211ef","modified":1561550194393},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash7.png","hash":"f0c08a13f2538ece9586434c133986d98942790d","modified":1561550194393},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash8.png","hash":"ce572b40d7b4da6306e8534c2346ecd94cc470a5","modified":1561550194394},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash9.png","hash":"c33159cb129b8df7404358f17007a44b16afa171","modified":1561550194395},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/hash-benchmark.png","hash":"a8371962551e1b50d91a35b0a54b1e44a9f6ef67","modified":1561550194396},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash10.png","hash":"586c77d71edef62bf56784752c9a854adf5d1af2","modified":1561550194397},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash2.png","hash":"4db8f1569ca916110583710cf5d8f72105d1dc35","modified":1561550194397},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash3.png","hash":"906e43b8c58c096e139e437d384537d6ee2c00a3","modified":1561550194398},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash4.png","hash":"a3c3c0ac060842e2e5f1fb7f735e0110bb4221c2","modified":1561550194398},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash6.png","hash":"7a1358840e7ac35e7d59172a9d1bf0d2038e1ddf","modified":1561550194399},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash7.png","hash":"be5830fbe47925cc62e3fd207c7a16b0c8522371","modified":1561550194400},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash8.png","hash":"88d777ec3865cc0de5f7dd98399b9bb0122ab6aa","modified":1561550194400},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash9.png","hash":"7e8c5e749215ac28c6a800881f8e5dcb5e792033","modified":1561550194401},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index6.png","hash":"099236c3a68e860d80db1891666559d767bfae3e","modified":1561550194424},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree-bck2.png","hash":"e9f406855f1e97bad536741c70e06ce30fdcb2e4","modified":1561550194428},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree-bck3.png","hash":"14f337692cddca9b10caa644844095f369f7ce9c","modified":1561550194429},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/in-mem-index1.png","hash":"def20d60961e37de599945b3a908e23908e380d2","modified":1561550194425},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list14.png","hash":"36742179c88ec89c586c4e08f523a6c28d393fec","modified":1561550194437},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list15.png","hash":"7dfb43a666d2540ff8cf28b4099c8fe2db54c2f5","modified":1561550194438},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list16.png","hash":"56dec8550c54d6530e59e9a1457bbdb147c4aa8c","modified":1561550194438},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list18.png","hash":"33024ca3b80650946a37dc1010496ae5e6b60fb0","modified":1561550194439},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list21.png","hash":"e13759ad07665000bcd300cdf1fbc7e32c1361ae","modified":1561550194441},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/wikipadia-example1.png","hash":"6f425f846c8013788866a7ad5604943fa00f562c","modified":1561550194446},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better1.png","hash":"d4a334ef12896ab90392da380cd4c76929ebc8fe","modified":1561550194447},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better3.png","hash":"f671b3fa819423e1a1fb7b81f7b47d46380495f8","modified":1561550194448},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better4.png","hash":"692e70bd8a29beb5f89f154c4baaaf72380b5485","modified":1561550194448},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better5.png","hash":"55c25a2d1e7ac69f918f9c496781348a6162fdb0","modified":1561550194449},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better6.png","hash":"4d2341a63e9ec8e386f017f7dedebfcf4172687c","modified":1561550194449},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better8.png","hash":"8fa81c40698835c252b211e52bafe02a748d0d89","modified":1561550194450},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better7.png","hash":"21ca2eb02a50feecee32e5e206f3373cc2fb7c92","modified":1561550194450},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent1.png","hash":"8d4daf3dfc2e25e2a57b0eb3958e519ce5c47b03","modified":1561550194451},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent10.png","hash":"4f0757b708a964c680edea0d732190e404fe8f49","modified":1561550194452},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent2.png","hash":"34bf25353a8352a9f7894048588e7e2b3106ac50","modified":1561550194452},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent4.png","hash":"044794347ee7ddf44bce65777991e18b53baf011","modified":1561550194453},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent5.png","hash":"331609995198036902b206495140e68a2d0eb038","modified":1561550194454},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent6.png","hash":"dd69f8ddb3d4dd1caa55c6ebb5ed4d7219ce66a1","modified":1561550194454},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent7.png","hash":"3036e18663852550e666cc95afd5b56efcdd9389","modified":1561550194455},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent8.png","hash":"1017b4e50a4c1030fbce525bd2c482fc20501f39","modified":1561550194455},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch1.png","hash":"a3f825c348e1442658c6a84b2a431c2129751eeb","modified":1561550194457},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent9.png","hash":"e2d2fdcb2d322f4336f3960d532f574463114952","modified":1561550194456},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch10.png","hash":"4049a8502990d3ef665e7e505da003e86af9cbb9","modified":1561550194457},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch11.png","hash":"6fa25838ab0633c084b0320786eb8806769576a6","modified":1561550194458},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch12.png","hash":"9b98900dcd9efbb60ed5fe299a8cc4b761602082","modified":1561550194458},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch14.png","hash":"0dccd90d4617e08702256501f745323bc20c59d7","modified":1561550194459},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch15.png","hash":"af792c96dc312733689d58770d6bcb247f179788","modified":1561550194460},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch16.png","hash":"03a0b0224bb3c491e212a30ff3d864084570f6fe","modified":1561550194460},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch17.png","hash":"7b58010450911f543a41e93e036afa556a2a7207","modified":1561550194461},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch18.png","hash":"cf039c10d79c35a5de98e87073c68cbe1b052e50","modified":1561550194461},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch19.png","hash":"a4e57793a3dfc4ffdb1d7b06a8e6ae74c3652a65","modified":1561550194462},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch20.png","hash":"b0fbb6d5be071c8944cd2d2014b42f64b86b7218","modified":1561550194463},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch2.png","hash":"9faf340a64bb8c766ae1ba003b7baabe8c0316f9","modified":1561550194462},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch24.png","hash":"336246ad958d2f8f35167e6e1e1e9a4a03afdc71","modified":1561550194465},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch23.png","hash":"86f2042fcd1c6a030d080839892d8681e796f031","modified":1561550194464},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch25.png","hash":"e655e43575db5fcf7992f0f87c3f7bdf563de96d","modified":1561550194465},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch4.png","hash":"985fec6523d7a0b46f7013acec75273e0a1062a9","modified":1561550194467},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch5.png","hash":"7ab9d33611e88d7224b491e5d72e621792875117","modified":1561550194467},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch6.png","hash":"3b7212dba5b57290cc33d192245c64809582ef9f","modified":1561550194468},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch8.png","hash":"4269be2b13cfda7124f2106f73a3e8da65c13bc4","modified":1561550194469},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch21.png","hash":"f1ec4339d5ddb9a22bf73672f063fdae78356000","modified":1561550194463},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan10.png","hash":"0a778bd9d4258bc1175ac634689cb93d2870df43","modified":1561550194470},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch9.png","hash":"4ab5d3bf137795f14cd527ff911d5677054f8fe4","modified":1561550194469},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan15.png","hash":"87e820da37df56203f0a26ccd9c883f8876024f0","modified":1561550194473},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan13.png","hash":"556c0aaa3c7654d681e2f37e55dfe9175bedcc95","modified":1561550194472},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan9.png","hash":"e5f91335a45de6e79c8067fa9c736a9edd678eb5","modified":1561550194478},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan14.png","hash":"9d7dab9309063ab586564f6bb9b24b4e9e7236b0","modified":1561550194472},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr4.png","hash":"35a9bedd6d1ae03b1923fd863b2311a4fb990683","modified":1561550194481},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr6.png","hash":"dd152b97fd5e4d21d631d7996ab18fc8156278da","modified":1561550194482},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr5.png","hash":"bfdf0fc07b4d6c7602afbdfcf9cae01e081573bb","modified":1561550194481},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr7.png","hash":"7bfaef7598898c06aa72889ce08a39986e249609","modified":1561550194482},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-4.png","hash":"c2191a94b9b7c11320a6f4822e2bdc95d21beba9","modified":1561550194485},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-3.png","hash":"ded7ab7eede04e5ff33ef997cfc71df072960617","modified":1561550194485},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-5.png","hash":"70eded831ae33b5f06c3d9cc30ee8418efcfda40","modified":1561550194486},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/index-scan3.png","hash":"a85f000114ee44cfaf88287da19e363d11a536b2","modified":1561550194492},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/iter-model1.png","hash":"7de0cd6430c1e36640ff0777255e652cd9cb4197","modified":1561550194494},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/iter-model2.png","hash":"1ef1062c3e64749939117accfdfd5cb68e04a4d5","modified":1561550194495},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/iter-model4.png","hash":"19104ebe125a1aef48e723fa553e88e48e48e1ae","modified":1561550194496},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/iter-model3.png","hash":"e7eeca921532ee260389a844d9896dafa30ffbae","modified":1561550194495},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/iter-model5.png","hash":"c3c728c862fa781cd073c6ad3dd8a09400733144","modified":1561550194496},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/late1.png","hash":"ae62f905d56ce48b14cd463b5e9441cc67f3052f","modified":1561550194497},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/late2.png","hash":"dd48e39124a86ed435749f52298723ecb710589d","modified":1561550194498},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/late3.png","hash":"3fde0192d0d57eaee15edb728b463fd3282f5b3e","modified":1561550194498},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/late4.png","hash":"7745925f7d6bb355ffa190865442d0a6efead390","modified":1561550194499},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/mate-model1.png","hash":"4204f40cc2e9c0b5108b8992c9d73fd7a2f59b1b","modified":1561550194500},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/mate-model2.png","hash":"f9a1e3478052fd7c782b4e37c30f16322554bbae","modified":1561550194500},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/mate-model3.png","hash":"c656f71ec6aaaab4943e189690f56e6022a13ea0","modified":1561550194501},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/mate-model4.png","hash":"3559d8f78f5f642d3171a5fbf94aa2fbc78fd8c4","modified":1561550194502},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/multi-index-scan3.png","hash":"86310605fe649a3f0bea62c8f8504b25ee00b42d","modified":1561550194504},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/vect-model1.png","hash":"974cc461c120846bb68417da7098d9cd9f19b4b8","modified":1561550194505},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/zone-map1.png","hash":"6f54eafcc199c93db1c40b1273b8f6cf1209b7ac","modified":1561550194508},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/zone-map2.png","hash":"bbd255b8dc9bc0f56c7d886009d4b5cde7687630","modified":1561550194509},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/Clustered-bplus-tree.png","hash":"7a3b8bea5a434b2a03365f748595047fd1fbc290","modified":1561550194510},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-3.png","hash":"d0a493aea176d0c96e8f22d5275f5ca82167ac55","modified":1561550194512},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-4.png","hash":"49e118383e7ea40c32296068a56f27a1877f081b","modified":1561550194513},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-4.png","hash":"5597afbadcff3899dc74731290596be66ca2b6ad","modified":1561550194518},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-7.png","hash":"ef01b4087b3886d763aa37932c29e25f07286df8","modified":1561550194521},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-1.png","hash":"ae3760e3b1a33a3e4cf2ab8b6d37365c68a6fd2a","modified":1561550194523},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-3.png","hash":"e69ad0202dca07fbe1e14c9576466433a712e1f4","modified":1561550194526},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-2.png","hash":"3214df94989bf90579143b4829e6bd96edac7fc1","modified":1561550194524},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-4.png","hash":"97a5cf9348f8c0d1ec8ea9e2c8183aa5787ce241","modified":1561550194528},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-5.png","hash":"a9175b5c8b6894187c97db43fc70f1ddd304251e","modified":1561550194529},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/Unclustered-bplus-tree.png","hash":"9ce766a6084e47d9704144abe5497ac266d3c491","modified":1561550194530},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/BLOCK-NESTED-LOOP-JOIN-1.png","hash":"617ad002627799c946bf2a94ab62bd059c237d0b","modified":1561550194531},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-3.png","hash":"64a0c678263adfb9e0d39326d1148a2cc8a41892","modified":1561550194533},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/INDEX-NESTED-LOOP-JOIN-1.png","hash":"0d0238063dd09d2da87143aed2b6cf3a26983538","modified":1561550194533},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-2.png","hash":"8c36aa781818396ec16d4069ffa8916b3a62e0d1","modified":1561550194535},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-1.png","hash":"e10e07362510351433f5aa03f2749cd606648207","modified":1561550194536},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-2.png","hash":"b5d9cc36c3bea6a6ad874c3e61da95f7dd8f6966","modified":1561550194536},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-1.png","hash":"2d38f0b371bc1bb86bb6b44992166281bbde94dd","modified":1561550194534},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/Normalized-tables.png","hash":"b8955f7abee6813d8c09369bcb07f667fba501cb","modified":1561550194538},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-10.png","hash":"288a20f173ca0f95c90c15dadb69810faf2fb45f","modified":1561550194542},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SIMPLE-NESTED-LOOP-JOIN-1.png","hash":"67e4815f90e981b24240b8cb4901b9bb80796b1f","modified":1561550194541},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-1.png","hash":"8b59d5154f596c4f13d509174b156c7b49febe58","modified":1561550194542},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-3.png","hash":"6900a63f1185c8b0493c5f0632b59752e67109bb","modified":1561550194546},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-4.png","hash":"945e7b21c8168a82545bdc1ab6f45a4704f8473d","modified":1561550194546},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-5.png","hash":"c992d085b29d932d3109c4538a06c0c7bb31cf45","modified":1561550194547},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-6.png","hash":"c52713aae7a9caf44f716e477ac8324e569d2c3a","modified":1561550194548},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-7.png","hash":"633b0b6ddc868cbd810c2088712edbbce0fbfaed","modified":1561550194549},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-8.png","hash":"72d6577d14359e8e1802c980125dc21ff231f49b","modified":1561550194550},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-2.png","hash":"84e7dde516c34540d71f5b6dde9a86eeda68d692","modified":1561550194545},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/QUERY-PLANNING-OVERVIEW.png","hash":"0aadac8c24534caa1e6eba37230150d31602e6dc","modified":1561550194556},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-11.png","hash":"6f971f06c4b146f397d79993a4c90e2cf4d57083","modified":1561550194543},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-9.png","hash":"d1574c2c33936911a489f3f75222b1bdc353072e","modified":1561550194552},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-1.png","hash":"743da519cff22bf7f53b315589e21e30f123c704","modified":1561550194560},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-2.png","hash":"d780bd27141ef8f8f6474486b0fa3e10de08ade9","modified":1561550194561},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-3.png","hash":"992eeced918413a628283495d56603f14e30e82b","modified":1561550194563},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-1.png","hash":"77de7232e6990e7a33784b096db1cd24b7f196da","modified":1561550194564},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-2.png","hash":"9a24af168facd18ae28d1ad132480f4f68f4bf32","modified":1561550194564},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-3.png","hash":"1f2e75f158cb534eff750b41980fcb09bc691e97","modified":1561550194565},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-4.png","hash":"dc49d0cdd6ee4746a39834eb5907699d9d877504","modified":1561550194565},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-5.png","hash":"252eaa94c3a732775b7dea05f1935ecc305089e8","modified":1561550194566},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-6.png","hash":"7c8d67f905f9972edba3d5b39c6ec05b9ccc1055","modified":1561550194568},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/MULTI-DISK-PARALLELISM.png","hash":"20eee1b9c90bf9a6cb430b1d508450d2c2e15355","modified":1561550194568},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/RAID-1-Mirroring.png","hash":"e0b5f7044ddc72377e15608bcca60dca56753d26","modified":1561550194570},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/stream.png","hash":"880d4398d5d2bc1020898421d32d18062810e49e","modified":1561550194572},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-9.png","hash":"bdc75e860cb3491f1fab31d678363c6e38f4213a","modified":1561638071860},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-8.png","hash":"160195fe83773bf4988f1fe17f3a3fb2b2d8f4ec","modified":1561638059923},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-1.png","hash":"a43e7821eec99f1f7e27094b70808260f6dc4228","modified":1561639049926},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-1.png","hash":"914be931f46dc1df7cc2d5cc67ccb1d77f7fe607","modified":1561639384912},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-1.png","hash":"f95b4ad3eab2b8f7e1407b63ad5079e9398d9ee0","modified":1561639803454},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-2.png","hash":"6891539f8a5108f586067a63f5b62f5e770a9a24","modified":1561639815360},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-2.png","hash":"90b049dbcd88ad7a7c0607a5e88215c34f987754","modified":1561639399727},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-1.png","hash":"1785251aecaa9b3c3316fefda0bba0a47259f946","modified":1561554010993},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-2.png","hash":"fcc6e2824f5b0020842365cb314dedef585b869b","modified":1561554044923},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-3.png","hash":"3557552760ddc84e789e0907ed8939a2fd47df7f","modified":1561554064505},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD)-1.png","hash":"65a29e2b016850fa66b1e10825ec93ea44c8af76","modified":1561553770420},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD)-2.png","hash":"54edbce30efd39eebf73d6f8c862f4815091b3e0","modified":1561553860560},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/SERIAL-EXECUTION-EXAMPLE.png","hash":"d15bda99dc1385693ae52a5953e3c3c0894f67a0","modified":1561553144556},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/Status.png","hash":"9f3b6ed567377a9e0102d6657ea25243629fe5a5","modified":1561550194572},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-1.png","hash":"7d2515e239557940404f891f57457177d619557f","modified":1561640200653},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-3.png","hash":"7796aace6b61bacb1691b3c864feb7615905ac50","modified":1561640241606},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-2.png","hash":"5929c497e8b8091b21d102d737e1199c3f569ebe","modified":1561640231273},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-4.png","hash":"c520a99eb9084e8de47bc1815ce46604980d9c32","modified":1561640256049},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-5.png","hash":"97482b5c34ff9d8d9eb94e1947f48791b45455aa","modified":1561640269043},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-6.png","hash":"a03a8778ba17902431bc523bb6ae7a8a14e12cf7","modified":1561640282656},{"_id":"source/_posts/迦百农/001.jpg","hash":"af60db4df8226a29b38e9b826644ce8b89971343","modified":1561550194620},{"_id":"source/_posts/迦百农/003.jpg","hash":"af60db4df8226a29b38e9b826644ce8b89971343","modified":1561550194621},{"_id":"source/MOVIES/index/迦百农.jpg","hash":"87549e1673b52ae94216199895f552f2fd4046c4","modified":1561550194325},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/DISK-ORIENTED.png","hash":"f7f5678721ebf2a998d8a81fcc657fe47e7587bf","modified":1561550194354},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-7.png","hash":"732c64115312500d591a1cd11117b42e1d641f51","modified":1561550194488},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-6.png","hash":"cb82837559d480d88699f62cbb1f6e5de29f75ad","modified":1561550194487},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/index-scan4.png","hash":"b0a78670b6cfea39dfd0114b518f17083a6d1d8b","modified":1561550194493},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/vect-model2.png","hash":"b4c4a9adb9b4dad3f6cde9a26699cc3c2dfda331","modified":1561550194506},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-5.png","hash":"4dc13379adf4eb4780e02a632543be0a59c33f78","modified":1561550194514},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-12.png","hash":"252c16264e1705c4048a38a7534aa768761d5a3f","modified":1561550194544},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-2.png","hash":"e163561bd6606c2bd7485a48b966b6d26bb966f4","modified":1561639064784},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-3.png","hash":"e11bdbdc8f5fed60512a410027d5d26220bf1d3c","modified":1561639415182},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-3.png","hash":"aca7f3516dfd63a765eafecc758d739beca79aea","modified":1561639825695},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-4.png","hash":"e0e65e1f6eb55a4c91b18b0eb96cd4a0b1f525e2","modified":1561639835866},{"_id":"source/_posts/迦百农/迦百农.jpg","hash":"87549e1673b52ae94216199895f552f2fd4046c4","modified":1561550194622},{"_id":"themes/maupassant/.git/objects/pack/pack-090d17b3c27313b82be6cf9c11585a1a86acb72f.idx","hash":"defa039e308bf62627d30a1ebe9ce22513846247","modified":1561776641320},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"4038440af2ee0106fac646477c3d97866ea52a2f","modified":1561776641371},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1561776641420},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/StorageHierarchy.png","hash":"f73dc9949198eb39616f96e92b7765423ff6bbb8","modified":1561550194330},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"a32031532da8a83d65480ea1eb9397f731ce5c72","modified":1561776641371},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1561776641368},{"_id":"source/_posts/LEC1/QQ20190309-231854@2x.png","hash":"cc14b689322c8a56c9e4074c2c33da4dfdaddf96","modified":1561550194591},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"a32031532da8a83d65480ea1eb9397f731ce5c72","modified":1561776641368},{"_id":"source/_posts/LEC1/QQ20190309-233752@2x.png","hash":"8702c20da4bd0bbbff64945349688ade47c49935","modified":1561550194594},{"_id":"source/_posts/LEC1/QQ20190309-234415@2x.png","hash":"12ce993145315aca31dc5b53923f442e97015570","modified":1561550194596},{"_id":"source/_posts/LEC1/QQ20190309-234523@2x.png","hash":"349fff79783985994b3d81a408955cd187f08d61","modified":1561550194597},{"_id":"source/_posts/LEC1/QQ20190310-105207.png","hash":"d56f9c214936e50402ff30909bfcf1041ac90098","modified":1561550194616},{"_id":"source/_posts/LEC1/QQ20190309-230116@2x.png","hash":"db9e814de79bc8296dbb7e14a5b9bebea5f551a5","modified":1561550194583},{"_id":"source/_posts/LEC1/QQ20190309-230220@2x.png","hash":"840eca36ff3c145693a1fe895ffa33e6fed4df6b","modified":1561550194586},{"_id":"source/_posts/LEC1/QQ20190309-234749@2x.png","hash":"381b5842a3be03aac68248a4b511eb503affadcc","modified":1561550194598},{"_id":"source/_posts/LEC1/QQ20190310-104242.png","hash":"c46888197248cee0a3904acbfbce0542658876a9","modified":1561550194610},{"_id":"source/_posts/LEC1/QQ20190309-231221@2x.png","hash":"8ec2b5c51dc5afd51b1d74be1aa0f09d1c2658a7","modified":1561550194590},{"_id":"source/_posts/LEC1/QQ20190310-104738.png","hash":"0af3d3caeede2c812efb40218fa4ccf9527b1c34","modified":1561550194611},{"_id":"source/_posts/LEC1/QQ20190310-103536.png","hash":"4819c3d59df9748af866f6af6db74a87d4e6557e","modified":1561550194607},{"_id":"themes/maupassant/.git/objects/pack/pack-090d17b3c27313b82be6cf9c11585a1a86acb72f.pack","hash":"33d4b455f69b5fa43067b25557c1ee0dfbe843cf","modified":1561776641318},{"_id":"source/_posts/LEC1/002.png","hash":"e57d5da6e2f5ce2ed05c81d76b11f2ca6ed0343c","modified":1561550194580},{"_id":"source/_posts/LEC1/QQ20190309-231930@2x.png","hash":"e54462e302404b005c1b010a2172f4a879f63d3c","modified":1561550194593},{"_id":"source/_posts/LEC1/QQ20190309-230801@2x.png","hash":"b59bce45fb5e012bd6010b98408a8451de642e84","modified":1561550194587},{"_id":"source/_posts/LEC1/QQ20190309-235308@2x.png","hash":"3cde76f72dba04e8f5de830fbc7154c518d4acb4","modified":1561550194600},{"_id":"source/_posts/LEC1/QQ20190310-103037.png","hash":"f70c97ca033b0799ac23b30747f854c01954b5b8","modified":1561550194604},{"_id":"source/_posts/LEC1/QQ20190310-102424.png","hash":"f5eb919878698ca3cb87b01cf79919d37f8c81fd","modified":1561550194603},{"_id":"source/_posts/LEC1/QQ20190310-104800.png","hash":"b7ed86c82edf92a6bf0016e41ea9bf07e5725a15","modified":1561550194613},{"_id":"source/_posts/LEC1/001.png","hash":"f46f449aa28c7f5ff5cd6db727e3605c931cedbf","modified":1561550194578},{"_id":"source/_posts/LEC1/QQ20190310-103722.png","hash":"13f23c2ee7ce929e9725cd399913ab67ca1f4fdf","modified":1561550194609},{"_id":"source/_posts/LEC1/QQ20190310-101849.png","hash":"c342dd8a5d887eff0f73ccedb2cd9719d33dcba2","modified":1561550194602}],"Category":[],"Data":[],"Page":[{"title":"LINUX","date":"2019-03-04T08:17:30.000Z","_content":"\nLINUX 官网 https://www.kernel.org\n\nLINUX 源码阅读网站 https://elixir.bootlin.com/linux/v4.20.13/source\n\nLINUX 内核参数解释 https://sysctl-explorer.net\n\n","source":"LINUX/index.md","raw":"---\ntitle: LINUX\ndate: 2019-03-04 16:17:30\n---\n\nLINUX 官网 https://www.kernel.org\n\nLINUX 源码阅读网站 https://elixir.bootlin.com/linux/v4.20.13/source\n\nLINUX 内核参数解释 https://sysctl-explorer.net\n\n","updated":"2019-06-26T11:56:34.323Z","path":"LINUX/index.html","comments":1,"layout":"page","_id":"cjxirvylz0000vkqpl7q4duw0","content":"<p>LINUX 官网 <a href=\"https://www.kernel.org\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org</a></p>\n<p>LINUX 源码阅读网站 <a href=\"https://elixir.bootlin.com/linux/v4.20.13/source\" target=\"_blank\" rel=\"noopener\">https://elixir.bootlin.com/linux/v4.20.13/source</a></p>\n<p>LINUX 内核参数解释 <a href=\"https://sysctl-explorer.net\" target=\"_blank\" rel=\"noopener\">https://sysctl-explorer.net</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>LINUX 官网 <a href=\"https://www.kernel.org\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org</a></p>\n<p>LINUX 源码阅读网站 <a href=\"https://elixir.bootlin.com/linux/v4.20.13/source\" target=\"_blank\" rel=\"noopener\">https://elixir.bootlin.com/linux/v4.20.13/source</a></p>\n<p>LINUX 内核参数解释 <a href=\"https://sysctl-explorer.net\" target=\"_blank\" rel=\"noopener\">https://sysctl-explorer.net</a></p>\n"},{"title":"MOVIES","date":"2019-03-10T03:06:37.000Z","_content":"\n**《[何以为家](https://turingturing.cn/2019/03/10/迦百农/)》**\n\n![迦百农](index/迦百农.jpg)\n\n","source":"MOVIES/index.md","raw":"---\ntitle: MOVIES\ndate: 2019-03-10 11:06:37\n---\n\n**《[何以为家](https://turingturing.cn/2019/03/10/迦百农/)》**\n\n![迦百农](index/迦百农.jpg)\n\n","updated":"2019-06-26T11:56:34.324Z","path":"MOVIES/index.html","comments":1,"layout":"page","_id":"cjxirvym50002vkqpokw9mgme","content":"<p><strong>《<a href=\"https://turingturing.cn/2019/03/10/迦百农/\">何以为家</a>》</strong></p>\n<p><img src=\"/MOVIES/index/迦百农.jpg\" alt=\"迦百农\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>《<a href=\"https://turingturing.cn/2019/03/10/迦百农/\">何以为家</a>》</strong></p>\n<p><img src=\"/MOVIES/index/迦百农.jpg\" alt=\"迦百农\"></p>\n"},{"title":"MIT-6.824","date":"2019-01-15T12:12:41.000Z","_content":"\n#### 翻译MIT Distributed-Systems 系列课程的资料\n| 课程视频                                                     | 课程笔记                                         | Paper阅读笔记                                   | Lab            |\n| ------------------------------------------------------------ | ------------------------------------------------ | ----------------------------------------------- | -------------- |\n| 1.[课程介绍](https://turingturing.cn/2019/01/16/LEC1-vedio/) | [LEC1](https://turingturing.cn/2019/01/15/LEC1/) | MapReduce                                       | MapReduceLab   |\n| 2.[RPC和多线程编程](https://turingturing.cn/2019/01/17/LEC2-vedio/) | [LEC2](https://turingturing.cn/2019/01/17/LEC2/) |                                                 | RpcLab         |\n| 3.GFS                                                        | [LEC3](https://turingturing.cn/2019/01/24/LEC3/) | GFS                                             |                |\n| 4.(Primary/Backup Replication)主/备 复制                     |                                                  | Fault Tolerance Virtual Machines - 容错的虚拟机 |                |\n| 5.Raft1                                                      |                                                  | Raft-extended                                   | RaftLab        |\n| 6.Raft2                                                      |                                                  | Raft-extended                                   | KVRaft Lab     |\n| 7.Go语言讲解-Guest lecturer                                  |                                                  | Go的内存模型                                    |                |\n| 8.Zookeeper                                                  |                                                  | ZooKeeper                                       |                |\n| 9.Distributed Transactions (分布式事务)                      |                                                  |                                                 |                |\n| 10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口) |                                                  |                                                 |                |\n| 11.FaRM                                                      |                                                  |                                                 |                |\n| 12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性) |                                                  | ThreadMarks                                     | Sharded KV Lab |\n| 13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性) |                                                  | Bayou                                           |                |\n| 14.Case Studies: Relaxed Consistency (案例研究：弱一致性)    |                                                  | PNUTS                                           |                |\n| 15.Case Studies:Dynamo (案例研究：Dynamo)                    |                                                  | Dynamo                                          |                |\n| 16.Wide-Area Publish/Subscribe (广域的发布和订阅)            |                                                  | Wormhole                                        |                |\n| 17.Measuring Consisitency (衡量一致性)                       |                                                  | Existential Consistency                         |                |\n| 18.Case Studies: Spark (案例学习：Spark)                     |                                                  | Spark                                           |                |\n| 19.Cluster Management (集群管理)                             |                                                  | Borg                                            |                |\n| 20.Peer-to-peer: Trackerless Bittrrent and DHTs              |                                                  | Trackerless Bittrrent                           |                |\n| 21.Peer-to-peer: Bitcoin （点对点 比特币）                   |                                                  | Bitcoin summary                                 |                |\n| 22: Guest lecturer: Frank Dabek of Google                    |                                                  | The Tail at Scale                               |                |\n| 23: Project Demos                                            |                                                  | Analogicfs                                      |                |\n\n**一些有用的链接**\n\n- 动画理解Raft http://thesecretlivesofdata.com/raft/\n\n","source":"MIT-6-824/index.md","raw":"---\ntitle: MIT-6.824\ndate: 2019-01-15 20:12:41\n---\n\n#### 翻译MIT Distributed-Systems 系列课程的资料\n| 课程视频                                                     | 课程笔记                                         | Paper阅读笔记                                   | Lab            |\n| ------------------------------------------------------------ | ------------------------------------------------ | ----------------------------------------------- | -------------- |\n| 1.[课程介绍](https://turingturing.cn/2019/01/16/LEC1-vedio/) | [LEC1](https://turingturing.cn/2019/01/15/LEC1/) | MapReduce                                       | MapReduceLab   |\n| 2.[RPC和多线程编程](https://turingturing.cn/2019/01/17/LEC2-vedio/) | [LEC2](https://turingturing.cn/2019/01/17/LEC2/) |                                                 | RpcLab         |\n| 3.GFS                                                        | [LEC3](https://turingturing.cn/2019/01/24/LEC3/) | GFS                                             |                |\n| 4.(Primary/Backup Replication)主/备 复制                     |                                                  | Fault Tolerance Virtual Machines - 容错的虚拟机 |                |\n| 5.Raft1                                                      |                                                  | Raft-extended                                   | RaftLab        |\n| 6.Raft2                                                      |                                                  | Raft-extended                                   | KVRaft Lab     |\n| 7.Go语言讲解-Guest lecturer                                  |                                                  | Go的内存模型                                    |                |\n| 8.Zookeeper                                                  |                                                  | ZooKeeper                                       |                |\n| 9.Distributed Transactions (分布式事务)                      |                                                  |                                                 |                |\n| 10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口) |                                                  |                                                 |                |\n| 11.FaRM                                                      |                                                  |                                                 |                |\n| 12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性) |                                                  | ThreadMarks                                     | Sharded KV Lab |\n| 13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性) |                                                  | Bayou                                           |                |\n| 14.Case Studies: Relaxed Consistency (案例研究：弱一致性)    |                                                  | PNUTS                                           |                |\n| 15.Case Studies:Dynamo (案例研究：Dynamo)                    |                                                  | Dynamo                                          |                |\n| 16.Wide-Area Publish/Subscribe (广域的发布和订阅)            |                                                  | Wormhole                                        |                |\n| 17.Measuring Consisitency (衡量一致性)                       |                                                  | Existential Consistency                         |                |\n| 18.Case Studies: Spark (案例学习：Spark)                     |                                                  | Spark                                           |                |\n| 19.Cluster Management (集群管理)                             |                                                  | Borg                                            |                |\n| 20.Peer-to-peer: Trackerless Bittrrent and DHTs              |                                                  | Trackerless Bittrrent                           |                |\n| 21.Peer-to-peer: Bitcoin （点对点 比特币）                   |                                                  | Bitcoin summary                                 |                |\n| 22: Guest lecturer: Frank Dabek of Google                    |                                                  | The Tail at Scale                               |                |\n| 23: Project Demos                                            |                                                  | Analogicfs                                      |                |\n\n**一些有用的链接**\n\n- 动画理解Raft http://thesecretlivesofdata.com/raft/\n\n","updated":"2019-06-26T11:56:34.323Z","path":"MIT-6-824/index.html","comments":1,"layout":"page","_id":"cjxirvym80004vkqprixdi2w0","content":"<h4 id=\"翻译MIT-Distributed-Systems-系列课程的资料\"><a href=\"#翻译MIT-Distributed-Systems-系列课程的资料\" class=\"headerlink\" title=\"翻译MIT Distributed-Systems 系列课程的资料\"></a>翻译MIT Distributed-Systems 系列课程的资料</h4><table>\n<thead>\n<tr>\n<th>课程视频</th>\n<th>课程笔记</th>\n<th>Paper阅读笔记</th>\n<th>Lab</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.<a href=\"https://turingturing.cn/2019/01/16/LEC1-vedio/\">课程介绍</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/15/LEC1/\">LEC1</a></td>\n<td>MapReduce</td>\n<td>MapReduceLab</td>\n</tr>\n<tr>\n<td>2.<a href=\"https://turingturing.cn/2019/01/17/LEC2-vedio/\">RPC和多线程编程</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/17/LEC2/\">LEC2</a></td>\n<td></td>\n<td>RpcLab</td>\n</tr>\n<tr>\n<td>3.GFS</td>\n<td><a href=\"https://turingturing.cn/2019/01/24/LEC3/\">LEC3</a></td>\n<td>GFS</td>\n<td></td>\n</tr>\n<tr>\n<td>4.(Primary/Backup Replication)主/备 复制</td>\n<td></td>\n<td>Fault Tolerance Virtual Machines - 容错的虚拟机</td>\n<td></td>\n</tr>\n<tr>\n<td>5.Raft1</td>\n<td></td>\n<td>Raft-extended</td>\n<td>RaftLab</td>\n</tr>\n<tr>\n<td>6.Raft2</td>\n<td></td>\n<td>Raft-extended</td>\n<td>KVRaft Lab</td>\n</tr>\n<tr>\n<td>7.Go语言讲解-Guest lecturer</td>\n<td></td>\n<td>Go的内存模型</td>\n<td></td>\n</tr>\n<tr>\n<td>8.Zookeeper</td>\n<td></td>\n<td>ZooKeeper</td>\n<td></td>\n</tr>\n<tr>\n<td>9.Distributed Transactions (分布式事务)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11.FaRM</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性)</td>\n<td></td>\n<td>ThreadMarks</td>\n<td>Sharded KV Lab</td>\n</tr>\n<tr>\n<td>13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性)</td>\n<td></td>\n<td>Bayou</td>\n<td></td>\n</tr>\n<tr>\n<td>14.Case Studies: Relaxed Consistency (案例研究：弱一致性)</td>\n<td></td>\n<td>PNUTS</td>\n<td></td>\n</tr>\n<tr>\n<td>15.Case Studies:Dynamo (案例研究：Dynamo)</td>\n<td></td>\n<td>Dynamo</td>\n<td></td>\n</tr>\n<tr>\n<td>16.Wide-Area Publish/Subscribe (广域的发布和订阅)</td>\n<td></td>\n<td>Wormhole</td>\n<td></td>\n</tr>\n<tr>\n<td>17.Measuring Consisitency (衡量一致性)</td>\n<td></td>\n<td>Existential Consistency</td>\n<td></td>\n</tr>\n<tr>\n<td>18.Case Studies: Spark (案例学习：Spark)</td>\n<td></td>\n<td>Spark</td>\n<td></td>\n</tr>\n<tr>\n<td>19.Cluster Management (集群管理)</td>\n<td></td>\n<td>Borg</td>\n<td></td>\n</tr>\n<tr>\n<td>20.Peer-to-peer: Trackerless Bittrrent and DHTs</td>\n<td></td>\n<td>Trackerless Bittrrent</td>\n<td></td>\n</tr>\n<tr>\n<td>21.Peer-to-peer: Bitcoin （点对点 比特币）</td>\n<td></td>\n<td>Bitcoin summary</td>\n<td></td>\n</tr>\n<tr>\n<td>22: Guest lecturer: Frank Dabek of Google</td>\n<td></td>\n<td>The Tail at Scale</td>\n<td></td>\n</tr>\n<tr>\n<td>23: Project Demos</td>\n<td></td>\n<td>Analogicfs</td>\n</tr>\n</tbody>\n</table>\n<p><strong>一些有用的链接</strong></p>\n<ul>\n<li>动画理解Raft <a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"noopener\">http://thesecretlivesofdata.com/raft/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"翻译MIT-Distributed-Systems-系列课程的资料\"><a href=\"#翻译MIT-Distributed-Systems-系列课程的资料\" class=\"headerlink\" title=\"翻译MIT Distributed-Systems 系列课程的资料\"></a>翻译MIT Distributed-Systems 系列课程的资料</h4><table>\n<thead>\n<tr>\n<th>课程视频</th>\n<th>课程笔记</th>\n<th>Paper阅读笔记</th>\n<th>Lab</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.<a href=\"https://turingturing.cn/2019/01/16/LEC1-vedio/\">课程介绍</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/15/LEC1/\">LEC1</a></td>\n<td>MapReduce</td>\n<td>MapReduceLab</td>\n</tr>\n<tr>\n<td>2.<a href=\"https://turingturing.cn/2019/01/17/LEC2-vedio/\">RPC和多线程编程</a></td>\n<td><a href=\"https://turingturing.cn/2019/01/17/LEC2/\">LEC2</a></td>\n<td></td>\n<td>RpcLab</td>\n</tr>\n<tr>\n<td>3.GFS</td>\n<td><a href=\"https://turingturing.cn/2019/01/24/LEC3/\">LEC3</a></td>\n<td>GFS</td>\n<td></td>\n</tr>\n<tr>\n<td>4.(Primary/Backup Replication)主/备 复制</td>\n<td></td>\n<td>Fault Tolerance Virtual Machines - 容错的虚拟机</td>\n<td></td>\n</tr>\n<tr>\n<td>5.Raft1</td>\n<td></td>\n<td>Raft-extended</td>\n<td>RaftLab</td>\n</tr>\n<tr>\n<td>6.Raft2</td>\n<td></td>\n<td>Raft-extended</td>\n<td>KVRaft Lab</td>\n</tr>\n<tr>\n<td>7.Go语言讲解-Guest lecturer</td>\n<td></td>\n<td>Go的内存模型</td>\n<td></td>\n</tr>\n<tr>\n<td>8.Zookeeper</td>\n<td></td>\n<td>ZooKeeper</td>\n<td></td>\n</tr>\n<tr>\n<td>9.Distributed Transactions (分布式事务)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>10.Optimistic Concurrency Control (乐观的并发控制 - 翻译有点拗口)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11.FaRM</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>12.Distributed Computing: Relaxed consistency (分布式计算-弱一致性)</td>\n<td></td>\n<td>ThreadMarks</td>\n<td>Sharded KV Lab</td>\n</tr>\n<tr>\n<td>13.Disconnected Operation: Eventual Consistency (断连接操作：最终一致性)</td>\n<td></td>\n<td>Bayou</td>\n<td></td>\n</tr>\n<tr>\n<td>14.Case Studies: Relaxed Consistency (案例研究：弱一致性)</td>\n<td></td>\n<td>PNUTS</td>\n<td></td>\n</tr>\n<tr>\n<td>15.Case Studies:Dynamo (案例研究：Dynamo)</td>\n<td></td>\n<td>Dynamo</td>\n<td></td>\n</tr>\n<tr>\n<td>16.Wide-Area Publish/Subscribe (广域的发布和订阅)</td>\n<td></td>\n<td>Wormhole</td>\n<td></td>\n</tr>\n<tr>\n<td>17.Measuring Consisitency (衡量一致性)</td>\n<td></td>\n<td>Existential Consistency</td>\n<td></td>\n</tr>\n<tr>\n<td>18.Case Studies: Spark (案例学习：Spark)</td>\n<td></td>\n<td>Spark</td>\n<td></td>\n</tr>\n<tr>\n<td>19.Cluster Management (集群管理)</td>\n<td></td>\n<td>Borg</td>\n<td></td>\n</tr>\n<tr>\n<td>20.Peer-to-peer: Trackerless Bittrrent and DHTs</td>\n<td></td>\n<td>Trackerless Bittrrent</td>\n<td></td>\n</tr>\n<tr>\n<td>21.Peer-to-peer: Bitcoin （点对点 比特币）</td>\n<td></td>\n<td>Bitcoin summary</td>\n<td></td>\n</tr>\n<tr>\n<td>22: Guest lecturer: Frank Dabek of Google</td>\n<td></td>\n<td>The Tail at Scale</td>\n<td></td>\n</tr>\n<tr>\n<td>23: Project Demos</td>\n<td></td>\n<td>Analogicfs</td>\n</tr>\n</tbody>\n</table>\n<p><strong>一些有用的链接</strong></p>\n<ul>\n<li>动画理解Raft <a href=\"http://thesecretlivesofdata.com/raft/\" target=\"_blank\" rel=\"noopener\">http://thesecretlivesofdata.com/raft/</a></li>\n</ul>\n"},{"title":"关于我","date":"2019-01-07T15:37:55.000Z","_content":"\n一个喜欢看各种书籍的书呆子！\n\n一个追求极致计算能力的疯子！\n\n一个追寻自由自在生活的浪子！\n\nemail: jay_jieliu@outlook.com\n\n知乎: [JAYL](https://www.zhihu.com/people/liu-jie-84-52/activities)\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2019-01-07 23:37:55\n---\n\n一个喜欢看各种书籍的书呆子！\n\n一个追求极致计算能力的疯子！\n\n一个追寻自由自在生活的浪子！\n\nemail: jay_jieliu@outlook.com\n\n知乎: [JAYL](https://www.zhihu.com/people/liu-jie-84-52/activities)\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n","updated":"2019-06-26T11:56:34.623Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjxirvymb0006vkqphxjn05ab","content":"<p>一个喜欢看各种书籍的书呆子！</p>\n<p>一个追求极致计算能力的疯子！</p>\n<p>一个追寻自由自在生活的浪子！</p>\n<p>email: <a href=\"mailto:jay_jieliu@outlook.com\" target=\"_blank\" rel=\"noopener\">jay_jieliu@outlook.com</a></p>\n<p>知乎: <a href=\"https://www.zhihu.com/people/liu-jie-84-52/activities\" target=\"_blank\" rel=\"noopener\">JAYL</a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<p>一个喜欢看各种书籍的书呆子！</p>\n<p>一个追求极致计算能力的疯子！</p>\n<p>一个追寻自由自在生活的浪子！</p>\n<p>email: <a href=\"mailto:jay_jieliu@outlook.com\" target=\"_blank\" rel=\"noopener\">jay_jieliu@outlook.com</a></p>\n<p>知乎: <a href=\"https://www.zhihu.com/people/liu-jie-84-52/activities\" target=\"_blank\" rel=\"noopener\">JAYL</a></p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=1&height=66\"></iframe>\n\n"}],"Post":[{"title":"2018总结","date":"2019-01-07T16:11:48.000Z","_content":"\n  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。\n  \n  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。\n  \n  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！\n  \n  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。\n  \n  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。\n  \n 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。\n \n 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。\n \n 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。\n \n<div style=\"width: 360px; margin: auto\">![2018](2018总结/2018.jpeg)</div>\n\n\n","source":"_posts/2018总结.md","raw":"---\ntitle: 2018总结\ndate: 2019-01-08 00:11:48\ntags:\n---\n\n  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。\n  \n  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。\n  \n  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！\n  \n  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。\n  \n  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。\n  \n 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。\n \n 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。\n \n 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。\n \n<div style=\"width: 360px; margin: auto\">![2018](2018总结/2018.jpeg)</div>\n\n\n","slug":"2018总结","published":1,"updated":"2019-06-26T11:56:34.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvym10001vkqpi03trtow","content":"<p>  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。</p>\n<p>  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。</p>\n<p>  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！</p>\n<p>  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。</p>\n<p>  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。</p>\n<p> 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。</p>\n<p> 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。</p>\n<p> 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。</p>\n<div style=\"width: 360px; margin: auto\"><img src=\"/2019/01/08/2018总结/2018.jpeg\" alt=\"2018\"></div>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>  2018年就要结束了，这一年起起伏伏，失去很多，也收获很多，想着马上要步入社会了，也该给自己做做总结了。</p>\n<p>  2018年3月10号。从你的世界路过，都是美好的回忆，愿你一直坚持着热爱的动画，快乐的创作，愿一切顺利。</p>\n<p>  2018年5月6号，ASC颁奖啦，初次入决赛，我们冲进了前八，紧随浙大，感谢所有的队友，大家都很努力。这算是大学做的最值得吹牛逼的事吧！还是感谢所有人的努力，一起在实验室睡觉的日子，一起抓狂跑程序，改论文的日志，比赛现场，现学现卖，突破难题。看过大家笑的最灿烂的样子，看过大家最认真努力的样子，哈哈，这就是青春最美的样子吧，谢谢有你们！</p>\n<p>  2018年7月10号，入职北京OTC Intel实习，来到魔都，在英特尔开源技术中心遇到一位位身怀绝技的大佬。导师老杜，一大把年纪了，还对技术那么热爱追求，哈哈，这大概是技术人活成了最美的样子吧。佛系的老板，头像都是佛像，刚加微信的时候都担心是不是进入传销组织了 ⌇●﹏●⌇ ，不过后来发现，老板确实是老板，技术牛逼，淡泊，懂得生活，能管理。哈哈，我不是在拍马屁，大佬就是大佬，没必要太多修饰。一起吃饭的徐core-一个很热心的小胖哥，nova core程序员 绝对的武林高手；张core 认真的写着代码，却又特别文艺，哈哈，那个文艺旅行的公众号我存着呢，工位在旁边，只能经常骚扰你啦；冰哥，让人看上去就是大佬；还有欣然小姐姐，海龟大佬，写的代码都是FPGA在开源云上的实现， 惭愧惭愧，虽然说的话不多，但是可以感觉到是一个认真，努力，真诚的女孩。这两个月，谢谢有你们，然我对未来有了一定的想法，真正的技术人，不浮躁，安心写代码，执着追求完美的技术。</p>\n<p>  2018年9月19日，回到学校，确定破格保研没有保到的消息，做点研究的梦想还是破灭了。迷茫了两个礼拜，秋招过了一半了，开始投简历。</p>\n<p> 2018年9月28日，来到杭州。准备孤注一掷，拼秋招，滴滴分布式NoSQL数据库团队，在这里的都是大佬，虽然经常加班，但是这段时间进步很快，希望自己能一点点慢慢沉淀吧。</p>\n<p> 2018年11月23日，签了三方，也算是确定了下一步的路了，为自己加油打CALL。</p>\n<p> 回看过去这一年，还是执着的追求的技术，虽然路走的那么不确定，但也许这就是生活吧。感情上还是问题一大堆，希望自己慢慢成长，用心去面对感受吧，谢谢每一个用心一起走过的人，青春里没有对错，我们都在见证对方最美最可爱的样子。时光漫长，不虚度，不悔恨，过好每一天。</p>\n<div style=\"width: 360px; margin: auto\"><img src=\"/2019/01/08/2018总结/2018.jpeg\" alt=\"2018\"></div>\n\n\n"},{"title":"C++编程思想笔记","date":"2019-03-15T09:39:38.000Z","_content":"\n1.改变已存在的基类函数的行为，称为重载这个函数？\n\n2.面向对象编程的宗旨\n\n- 系统中有哪些对象？\n- 它们之间的接口是什么？\n\n3.函数声明时参数标识符是可选的。函数定义时则要求要有标识符。(C++中允许不命名参数为了给程序员提供在参数列表中保留位置)\n\n4.关于#include ：永尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。用双引号时，预处理器以“由实现定义的方式”来寻找文件。它通常是从当前目录开始寻找，如果没有找到，那么include 命令按与尖括号同样的方式开始寻找。\n\n5.名字空间的作用：当程序达到一定规模后，通常分成许多块，每一块由不同的人或小组来构造和连接。不同模块中碰巧用到了相同的函数名和标识符会导致不必要的冲突，标准的C++中用namespace的机制防止这种冲突。\n\n6.string 具有动态特性，不必担心string的内存分配；只管添加新的内容进去就行了，string会自动扩展以保存新的输入。\n\n7.C++函数原型必须指明函数的返回值类型\n\n8.static变量的两层意义\n\n- 如果想使局部变量的值在程序整个生命期里仍然存在，我们可以定义函数的局部变量为static\n- static的第二层意思是“在某个作用域外不可访问”，函数名是局部于文件的，我们说它具有文件作用域\n\n9.extern关键字的意义\n\n- 它告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它。这个变量或函数可能在另一个文件中或者当前文件后面定义。\n\n10.C++中的显示转换\n\n| static_cast      | 用于“良性”和“适度良性”转换，包括不用强制转换                 |\n| ---------------- | ------------------------------------------------------------ |\n| const_cast       | 对\"const\"和/或\"volatile\"进行转换(从const转换为非const或从volatile转换为非volatile) |\n| reinterpret_cast | 重解释转换                                                   |\n| Dynamic_cast     | 用于类型安全的向下转换                                       |\n\n11.typedef 给struct定义别名\n\n```\ntypedef struct SelfReferential {\n \tint i;\n    SelfReferential* sr;\n}SelfReferential;\n\n//使用\nSelfReferential sr1, sr2;\n```\n\n12.使用预处理调试标记\n\n```\n#define DEBUG\n#ifdef DEBUG\n/*调试的代码*/\n#endif DEBUG\n```\n\n13.在写调试代码时，编写包含变量名后跟变量名是很无聊的，可以用字符串化运算符简化\n\n```\n#define P(A) cout << #A << \": \" << (A) << endl;\n```\n\n```\nint main() {\n    int a = 1, b = 2, c = 3;\n    P(a); P(b); P(c);\n    P(a + b);\n    P((c - b) / b);\n}\n```\n\n```\n[root@localhost CPPDemo]# ./cast1 \na: 1\nb: 2\nc: 3\na + b: 3\n(c - b) / b: 0\n```\n\n14.一旦定义了一个函数指针，在使用前必须给它赋一个函数的地址\n\n```\nvoid func() {\n    cout << \"func() called ...\" << endl;\n}\n\nvoid func2() {\n    cout << \"func2() called ..\" << endl;\n}\n\nint main() {\n    void (*fp)(); //定义一个函数指针\n    fp = func; //初始化它\n    (*fp)(); //调用它指向的函数\n    void (*fp2)() = func2; //定义并初始化一个函数指针\n    (*fp2)();\n}\n```\n\n```\n[root@localhost CPPDemo]# ./fun_ptr \nfunc() called ...\nfunc2() called ..\n```\n\n15.妙用函数指针数组\n\n```\n#include <iostream>\nusing namespace std;\n\n#define DF(N) void N() {\\ \n    cout << \"function \" #N \" called ... \" << endl; }\n\nDF(a); DF(b); DF(c); DF(d); DF(e); DF(f); DF(g);\n\nvoid (*func_table[])() = {a, b, c, d, e, f, g};\n\nint main() {\n    while(1) {\n        cout << \"press a key from 'a' to 'g'\"\n            \"or q to quit\" << endl;\n        char c, cr;\n        cin.get(c); cin.get(cr);\n        if (c == 'q')\n            break;\n        if (c < 'a' || c > 'g')\n            continue;\n        (*func_table[c - 'a'])();\n\n    }\n}\n\n[root@localhost CPPDemo]# ./fun_ptr_table \npress a key from 'a' to 'g'or q to quit\nb\nfunction b called ... \npress a key from 'a' to 'g'or q to quit\nc\nfunction c called ... \npress a key from 'a' to 'g'or q to quit\nq\n```\n\n16.C++允许将任何类型的指针赋值给void *，但不允许指针赋给任何其他类型的指针。\n\n17.C++中的访问控制\n\n| public    | 在其后声明的所有成员可以被所有的人访问                       |\n| --------- | ------------------------------------------------------------ |\n| private   | private关键字意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问 |\n| protected | 继承的结构可以访问protected成员，但不能访问private成员       |\n\n18.访问控制为类的创建者提供了很有价值的控制。类的客户程序员可以清楚的看到，什么可以用，什么应该忽略。更重要的是，它保证了使用类的客户程序员不会依赖类的实现细节，这样类库的开发者更改某些实现客户程序员不会因此受到影响。\n\n19.构造函数执行原理\n\n```\nclass X {\n    int i;\npublic:\n\tX();\n}\n\nvoid f() {\n    X a;\n    // ...\n}\n```\n\n当程序执行到a的序列点执行的点时，构造函数自动被调用，编译器悄悄的在a的定义点处拆入了一个X::X()的调用。就像其他成员函数被调用一样，传递到构造函数的第一个(秘密)参数是this指针，也就是调用这一个函数对象的内存地址，不过，对构造函数来说，this指针指向一个没有被初始化的内存块，构造函数的作用就是正确初始化该内存块\n\n20.当对象超出它的作用域的时候，编译器将自动调用析构函数。\n\n21.C++中禁止用返回值重载函数\n\n22.在C++中，struct和class唯一的不同之处在于，struct默认为public，而class默认为private。自然的，也可以让struct有构造啊函数和析构函数。另外，一个union（联合）也可以带有构造函数、析构函数、成员函数甚至访问控制。\n\n23.只有参数列表的后部参数才是可默认的；一旦在一个函数调用中开始使用默认参数，那么这个参数后面所有参数都必须是默认的。\n\n24.占位符参数:函数声明时，参数可以没有标识符\n\n```\nvoid f(int x, int, float flt);\n```\n\n如果开始用了一个函数参数，而后来发现不需要用它，可以将它去掉而不会产生警告错误，而且不需要改动那些调用该函数以前版本的程序代码。\n\n25.不能把默认参数作为一个标志去决定执行函数的哪一块，这是基本原则。在这种情况下，只要能够，就应该把函数分解成两个或多个重载的函数。\n\n26.关于const和指针\n\nu是一个指针，它指向一个const int，它所指的内容是不能被改变的\n\n```\nconst int* u;\n```\n\nw是一个指针，这个指针是指向int的const指针，指针本身不可改变\n\n```\nint d = 1;\nint* const w = &d;\n```\n\n指针的对象都不能改变\n\n```\nint d = 1;\nconst int* const x = &d\n```\n\n","source":"_posts/C-编程思想笔记.md","raw":"---\ntitle: C++编程思想笔记\ndate: 2019-03-15 17:39:38\ntags:\n---\n\n1.改变已存在的基类函数的行为，称为重载这个函数？\n\n2.面向对象编程的宗旨\n\n- 系统中有哪些对象？\n- 它们之间的接口是什么？\n\n3.函数声明时参数标识符是可选的。函数定义时则要求要有标识符。(C++中允许不命名参数为了给程序员提供在参数列表中保留位置)\n\n4.关于#include ：永尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。用双引号时，预处理器以“由实现定义的方式”来寻找文件。它通常是从当前目录开始寻找，如果没有找到，那么include 命令按与尖括号同样的方式开始寻找。\n\n5.名字空间的作用：当程序达到一定规模后，通常分成许多块，每一块由不同的人或小组来构造和连接。不同模块中碰巧用到了相同的函数名和标识符会导致不必要的冲突，标准的C++中用namespace的机制防止这种冲突。\n\n6.string 具有动态特性，不必担心string的内存分配；只管添加新的内容进去就行了，string会自动扩展以保存新的输入。\n\n7.C++函数原型必须指明函数的返回值类型\n\n8.static变量的两层意义\n\n- 如果想使局部变量的值在程序整个生命期里仍然存在，我们可以定义函数的局部变量为static\n- static的第二层意思是“在某个作用域外不可访问”，函数名是局部于文件的，我们说它具有文件作用域\n\n9.extern关键字的意义\n\n- 它告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它。这个变量或函数可能在另一个文件中或者当前文件后面定义。\n\n10.C++中的显示转换\n\n| static_cast      | 用于“良性”和“适度良性”转换，包括不用强制转换                 |\n| ---------------- | ------------------------------------------------------------ |\n| const_cast       | 对\"const\"和/或\"volatile\"进行转换(从const转换为非const或从volatile转换为非volatile) |\n| reinterpret_cast | 重解释转换                                                   |\n| Dynamic_cast     | 用于类型安全的向下转换                                       |\n\n11.typedef 给struct定义别名\n\n```\ntypedef struct SelfReferential {\n \tint i;\n    SelfReferential* sr;\n}SelfReferential;\n\n//使用\nSelfReferential sr1, sr2;\n```\n\n12.使用预处理调试标记\n\n```\n#define DEBUG\n#ifdef DEBUG\n/*调试的代码*/\n#endif DEBUG\n```\n\n13.在写调试代码时，编写包含变量名后跟变量名是很无聊的，可以用字符串化运算符简化\n\n```\n#define P(A) cout << #A << \": \" << (A) << endl;\n```\n\n```\nint main() {\n    int a = 1, b = 2, c = 3;\n    P(a); P(b); P(c);\n    P(a + b);\n    P((c - b) / b);\n}\n```\n\n```\n[root@localhost CPPDemo]# ./cast1 \na: 1\nb: 2\nc: 3\na + b: 3\n(c - b) / b: 0\n```\n\n14.一旦定义了一个函数指针，在使用前必须给它赋一个函数的地址\n\n```\nvoid func() {\n    cout << \"func() called ...\" << endl;\n}\n\nvoid func2() {\n    cout << \"func2() called ..\" << endl;\n}\n\nint main() {\n    void (*fp)(); //定义一个函数指针\n    fp = func; //初始化它\n    (*fp)(); //调用它指向的函数\n    void (*fp2)() = func2; //定义并初始化一个函数指针\n    (*fp2)();\n}\n```\n\n```\n[root@localhost CPPDemo]# ./fun_ptr \nfunc() called ...\nfunc2() called ..\n```\n\n15.妙用函数指针数组\n\n```\n#include <iostream>\nusing namespace std;\n\n#define DF(N) void N() {\\ \n    cout << \"function \" #N \" called ... \" << endl; }\n\nDF(a); DF(b); DF(c); DF(d); DF(e); DF(f); DF(g);\n\nvoid (*func_table[])() = {a, b, c, d, e, f, g};\n\nint main() {\n    while(1) {\n        cout << \"press a key from 'a' to 'g'\"\n            \"or q to quit\" << endl;\n        char c, cr;\n        cin.get(c); cin.get(cr);\n        if (c == 'q')\n            break;\n        if (c < 'a' || c > 'g')\n            continue;\n        (*func_table[c - 'a'])();\n\n    }\n}\n\n[root@localhost CPPDemo]# ./fun_ptr_table \npress a key from 'a' to 'g'or q to quit\nb\nfunction b called ... \npress a key from 'a' to 'g'or q to quit\nc\nfunction c called ... \npress a key from 'a' to 'g'or q to quit\nq\n```\n\n16.C++允许将任何类型的指针赋值给void *，但不允许指针赋给任何其他类型的指针。\n\n17.C++中的访问控制\n\n| public    | 在其后声明的所有成员可以被所有的人访问                       |\n| --------- | ------------------------------------------------------------ |\n| private   | private关键字意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问 |\n| protected | 继承的结构可以访问protected成员，但不能访问private成员       |\n\n18.访问控制为类的创建者提供了很有价值的控制。类的客户程序员可以清楚的看到，什么可以用，什么应该忽略。更重要的是，它保证了使用类的客户程序员不会依赖类的实现细节，这样类库的开发者更改某些实现客户程序员不会因此受到影响。\n\n19.构造函数执行原理\n\n```\nclass X {\n    int i;\npublic:\n\tX();\n}\n\nvoid f() {\n    X a;\n    // ...\n}\n```\n\n当程序执行到a的序列点执行的点时，构造函数自动被调用，编译器悄悄的在a的定义点处拆入了一个X::X()的调用。就像其他成员函数被调用一样，传递到构造函数的第一个(秘密)参数是this指针，也就是调用这一个函数对象的内存地址，不过，对构造函数来说，this指针指向一个没有被初始化的内存块，构造函数的作用就是正确初始化该内存块\n\n20.当对象超出它的作用域的时候，编译器将自动调用析构函数。\n\n21.C++中禁止用返回值重载函数\n\n22.在C++中，struct和class唯一的不同之处在于，struct默认为public，而class默认为private。自然的，也可以让struct有构造啊函数和析构函数。另外，一个union（联合）也可以带有构造函数、析构函数、成员函数甚至访问控制。\n\n23.只有参数列表的后部参数才是可默认的；一旦在一个函数调用中开始使用默认参数，那么这个参数后面所有参数都必须是默认的。\n\n24.占位符参数:函数声明时，参数可以没有标识符\n\n```\nvoid f(int x, int, float flt);\n```\n\n如果开始用了一个函数参数，而后来发现不需要用它，可以将它去掉而不会产生警告错误，而且不需要改动那些调用该函数以前版本的程序代码。\n\n25.不能把默认参数作为一个标志去决定执行函数的哪一块，这是基本原则。在这种情况下，只要能够，就应该把函数分解成两个或多个重载的函数。\n\n26.关于const和指针\n\nu是一个指针，它指向一个const int，它所指的内容是不能被改变的\n\n```\nconst int* u;\n```\n\nw是一个指针，这个指针是指向int的const指针，指针本身不可改变\n\n```\nint d = 1;\nint* const w = &d;\n```\n\n指针的对象都不能改变\n\n```\nint d = 1;\nconst int* const x = &d\n```\n\n","slug":"C-编程思想笔记","published":1,"updated":"2019-06-26T11:56:34.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvym60003vkqpb83q2vfx","content":"<p>1.改变已存在的基类函数的行为，称为重载这个函数？</p>\n<p>2.面向对象编程的宗旨</p>\n<ul>\n<li>系统中有哪些对象？</li>\n<li>它们之间的接口是什么？</li>\n</ul>\n<p>3.函数声明时参数标识符是可选的。函数定义时则要求要有标识符。(C++中允许不命名参数为了给程序员提供在参数列表中保留位置)</p>\n<p>4.关于#include ：永尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。用双引号时，预处理器以“由实现定义的方式”来寻找文件。它通常是从当前目录开始寻找，如果没有找到，那么include 命令按与尖括号同样的方式开始寻找。</p>\n<p>5.名字空间的作用：当程序达到一定规模后，通常分成许多块，每一块由不同的人或小组来构造和连接。不同模块中碰巧用到了相同的函数名和标识符会导致不必要的冲突，标准的C++中用namespace的机制防止这种冲突。</p>\n<p>6.string 具有动态特性，不必担心string的内存分配；只管添加新的内容进去就行了，string会自动扩展以保存新的输入。</p>\n<p>7.C++函数原型必须指明函数的返回值类型</p>\n<p>8.static变量的两层意义</p>\n<ul>\n<li>如果想使局部变量的值在程序整个生命期里仍然存在，我们可以定义函数的局部变量为static</li>\n<li>static的第二层意思是“在某个作用域外不可访问”，函数名是局部于文件的，我们说它具有文件作用域</li>\n</ul>\n<p>9.extern关键字的意义</p>\n<ul>\n<li>它告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它。这个变量或函数可能在另一个文件中或者当前文件后面定义。</li>\n</ul>\n<p>10.C++中的显示转换</p>\n<table>\n<thead>\n<tr>\n<th>static_cast</th>\n<th>用于“良性”和“适度良性”转换，包括不用强制转换</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>const_cast</td>\n<td>对”const”和/或”volatile”进行转换(从const转换为非const或从volatile转换为非volatile)</td>\n</tr>\n<tr>\n<td>reinterpret_cast</td>\n<td>重解释转换</td>\n</tr>\n<tr>\n<td>Dynamic_cast</td>\n<td>用于类型安全的向下转换</td>\n</tr>\n</tbody>\n</table>\n<p>11.typedef 给struct定义别名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct SelfReferential &#123;</span><br><span class=\"line\"> \tint i;</span><br><span class=\"line\">    SelfReferential* sr;</span><br><span class=\"line\">&#125;SelfReferential;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用</span><br><span class=\"line\">SelfReferential sr1, sr2;</span><br></pre></td></tr></table></figure>\n<p>12.使用预处理调试标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DEBUG</span><br><span class=\"line\">#ifdef DEBUG</span><br><span class=\"line\">/*调试的代码*/</span><br><span class=\"line\">#endif DEBUG</span><br></pre></td></tr></table></figure>\n<p>13.在写调试代码时，编写包含变量名后跟变量名是很无聊的，可以用字符串化运算符简化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define P(A) cout &lt;&lt; #A &lt;&lt; &quot;: &quot; &lt;&lt; (A) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int a = 1, b = 2, c = 3;</span><br><span class=\"line\">    P(a); P(b); P(c);</span><br><span class=\"line\">    P(a + b);</span><br><span class=\"line\">    P((c - b) / b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost CPPDemo]# ./cast1 </span><br><span class=\"line\">a: 1</span><br><span class=\"line\">b: 2</span><br><span class=\"line\">c: 3</span><br><span class=\"line\">a + b: 3</span><br><span class=\"line\">(c - b) / b: 0</span><br></pre></td></tr></table></figure>\n<p>14.一旦定义了一个函数指针，在使用前必须给它赋一个函数的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;func() called ...&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;func2() called ..&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    void (*fp)(); //定义一个函数指针</span><br><span class=\"line\">    fp = func; //初始化它</span><br><span class=\"line\">    (*fp)(); //调用它指向的函数</span><br><span class=\"line\">    void (*fp2)() = func2; //定义并初始化一个函数指针</span><br><span class=\"line\">    (*fp2)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost CPPDemo]# ./fun_ptr </span><br><span class=\"line\">func() called ...</span><br><span class=\"line\">func2() called ..</span><br></pre></td></tr></table></figure>\n<p>15.妙用函数指针数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">#define DF(N) void N() &#123;\\ </span><br><span class=\"line\">    cout &lt;&lt; &quot;function &quot; #N &quot; called ... &quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DF(a); DF(b); DF(c); DF(d); DF(e); DF(f); DF(g);</span><br><span class=\"line\"></span><br><span class=\"line\">void (*func_table[])() = &#123;a, b, c, d, e, f, g&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    while(1) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;press a key from &apos;a&apos; to &apos;g&apos;&quot;</span><br><span class=\"line\">            &quot;or q to quit&quot; &lt;&lt; endl;</span><br><span class=\"line\">        char c, cr;</span><br><span class=\"line\">        cin.get(c); cin.get(cr);</span><br><span class=\"line\">        if (c == &apos;q&apos;)</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        if (c &lt; &apos;a&apos; || c &gt; &apos;g&apos;)</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        (*func_table[c - &apos;a&apos;])();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost CPPDemo]# ./fun_ptr_table </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">b</span><br><span class=\"line\">function b called ... </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">c</span><br><span class=\"line\">function c called ... </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">q</span><br></pre></td></tr></table></figure>\n<p>16.C++允许将任何类型的指针赋值给void *，但不允许指针赋给任何其他类型的指针。</p>\n<p>17.C++中的访问控制</p>\n<table>\n<thead>\n<tr>\n<th>public</th>\n<th>在其后声明的所有成员可以被所有的人访问</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>private</td>\n<td>private关键字意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>继承的结构可以访问protected成员，但不能访问private成员</td>\n</tr>\n</tbody>\n</table>\n<p>18.访问控制为类的创建者提供了很有价值的控制。类的客户程序员可以清楚的看到，什么可以用，什么应该忽略。更重要的是，它保证了使用类的客户程序员不会依赖类的实现细节，这样类库的开发者更改某些实现客户程序员不会因此受到影响。</p>\n<p>19.构造函数执行原理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class X &#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tX();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void f() &#123;</span><br><span class=\"line\">    X a;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当程序执行到a的序列点执行的点时，构造函数自动被调用，编译器悄悄的在a的定义点处拆入了一个X::X()的调用。就像其他成员函数被调用一样，传递到构造函数的第一个(秘密)参数是this指针，也就是调用这一个函数对象的内存地址，不过，对构造函数来说，this指针指向一个没有被初始化的内存块，构造函数的作用就是正确初始化该内存块</p>\n<p>20.当对象超出它的作用域的时候，编译器将自动调用析构函数。</p>\n<p>21.C++中禁止用返回值重载函数</p>\n<p>22.在C++中，struct和class唯一的不同之处在于，struct默认为public，而class默认为private。自然的，也可以让struct有构造啊函数和析构函数。另外，一个union（联合）也可以带有构造函数、析构函数、成员函数甚至访问控制。</p>\n<p>23.只有参数列表的后部参数才是可默认的；一旦在一个函数调用中开始使用默认参数，那么这个参数后面所有参数都必须是默认的。</p>\n<p>24.占位符参数:函数声明时，参数可以没有标识符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void f(int x, int, float flt);</span><br></pre></td></tr></table></figure>\n<p>如果开始用了一个函数参数，而后来发现不需要用它，可以将它去掉而不会产生警告错误，而且不需要改动那些调用该函数以前版本的程序代码。</p>\n<p>25.不能把默认参数作为一个标志去决定执行函数的哪一块，这是基本原则。在这种情况下，只要能够，就应该把函数分解成两个或多个重载的函数。</p>\n<p>26.关于const和指针</p>\n<p>u是一个指针，它指向一个const int，它所指的内容是不能被改变的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int* u;</span><br></pre></td></tr></table></figure>\n<p>w是一个指针，这个指针是指向int的const指针，指针本身不可改变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int d = 1;</span><br><span class=\"line\">int* const w = &amp;d;</span><br></pre></td></tr></table></figure>\n<p>指针的对象都不能改变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int d = 1;</span><br><span class=\"line\">const int* const x = &amp;d</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>1.改变已存在的基类函数的行为，称为重载这个函数？</p>\n<p>2.面向对象编程的宗旨</p>\n<ul>\n<li>系统中有哪些对象？</li>\n<li>它们之间的接口是什么？</li>\n</ul>\n<p>3.函数声明时参数标识符是可选的。函数定义时则要求要有标识符。(C++中允许不命名参数为了给程序员提供在参数列表中保留位置)</p>\n<p>4.关于#include ：永尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。用双引号时，预处理器以“由实现定义的方式”来寻找文件。它通常是从当前目录开始寻找，如果没有找到，那么include 命令按与尖括号同样的方式开始寻找。</p>\n<p>5.名字空间的作用：当程序达到一定规模后，通常分成许多块，每一块由不同的人或小组来构造和连接。不同模块中碰巧用到了相同的函数名和标识符会导致不必要的冲突，标准的C++中用namespace的机制防止这种冲突。</p>\n<p>6.string 具有动态特性，不必担心string的内存分配；只管添加新的内容进去就行了，string会自动扩展以保存新的输入。</p>\n<p>7.C++函数原型必须指明函数的返回值类型</p>\n<p>8.static变量的两层意义</p>\n<ul>\n<li>如果想使局部变量的值在程序整个生命期里仍然存在，我们可以定义函数的局部变量为static</li>\n<li>static的第二层意思是“在某个作用域外不可访问”，函数名是局部于文件的，我们说它具有文件作用域</li>\n</ul>\n<p>9.extern关键字的意义</p>\n<ul>\n<li>它告诉编译器存在着一个变量和函数，即使编译器在当前编译的文件中没有看到它。这个变量或函数可能在另一个文件中或者当前文件后面定义。</li>\n</ul>\n<p>10.C++中的显示转换</p>\n<table>\n<thead>\n<tr>\n<th>static_cast</th>\n<th>用于“良性”和“适度良性”转换，包括不用强制转换</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>const_cast</td>\n<td>对”const”和/或”volatile”进行转换(从const转换为非const或从volatile转换为非volatile)</td>\n</tr>\n<tr>\n<td>reinterpret_cast</td>\n<td>重解释转换</td>\n</tr>\n<tr>\n<td>Dynamic_cast</td>\n<td>用于类型安全的向下转换</td>\n</tr>\n</tbody>\n</table>\n<p>11.typedef 给struct定义别名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct SelfReferential &#123;</span><br><span class=\"line\"> \tint i;</span><br><span class=\"line\">    SelfReferential* sr;</span><br><span class=\"line\">&#125;SelfReferential;</span><br><span class=\"line\"></span><br><span class=\"line\">//使用</span><br><span class=\"line\">SelfReferential sr1, sr2;</span><br></pre></td></tr></table></figure>\n<p>12.使用预处理调试标记</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define DEBUG</span><br><span class=\"line\">#ifdef DEBUG</span><br><span class=\"line\">/*调试的代码*/</span><br><span class=\"line\">#endif DEBUG</span><br></pre></td></tr></table></figure>\n<p>13.在写调试代码时，编写包含变量名后跟变量名是很无聊的，可以用字符串化运算符简化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define P(A) cout &lt;&lt; #A &lt;&lt; &quot;: &quot; &lt;&lt; (A) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    int a = 1, b = 2, c = 3;</span><br><span class=\"line\">    P(a); P(b); P(c);</span><br><span class=\"line\">    P(a + b);</span><br><span class=\"line\">    P((c - b) / b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost CPPDemo]# ./cast1 </span><br><span class=\"line\">a: 1</span><br><span class=\"line\">b: 2</span><br><span class=\"line\">c: 3</span><br><span class=\"line\">a + b: 3</span><br><span class=\"line\">(c - b) / b: 0</span><br></pre></td></tr></table></figure>\n<p>14.一旦定义了一个函数指针，在使用前必须给它赋一个函数的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void func() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;func() called ...&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void func2() &#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;func2() called ..&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    void (*fp)(); //定义一个函数指针</span><br><span class=\"line\">    fp = func; //初始化它</span><br><span class=\"line\">    (*fp)(); //调用它指向的函数</span><br><span class=\"line\">    void (*fp2)() = func2; //定义并初始化一个函数指针</span><br><span class=\"line\">    (*fp2)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost CPPDemo]# ./fun_ptr </span><br><span class=\"line\">func() called ...</span><br><span class=\"line\">func2() called ..</span><br></pre></td></tr></table></figure>\n<p>15.妙用函数指针数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">#define DF(N) void N() &#123;\\ </span><br><span class=\"line\">    cout &lt;&lt; &quot;function &quot; #N &quot; called ... &quot; &lt;&lt; endl; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DF(a); DF(b); DF(c); DF(d); DF(e); DF(f); DF(g);</span><br><span class=\"line\"></span><br><span class=\"line\">void (*func_table[])() = &#123;a, b, c, d, e, f, g&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    while(1) &#123;</span><br><span class=\"line\">        cout &lt;&lt; &quot;press a key from &apos;a&apos; to &apos;g&apos;&quot;</span><br><span class=\"line\">            &quot;or q to quit&quot; &lt;&lt; endl;</span><br><span class=\"line\">        char c, cr;</span><br><span class=\"line\">        cin.get(c); cin.get(cr);</span><br><span class=\"line\">        if (c == &apos;q&apos;)</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        if (c &lt; &apos;a&apos; || c &gt; &apos;g&apos;)</span><br><span class=\"line\">            continue;</span><br><span class=\"line\">        (*func_table[c - &apos;a&apos;])();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost CPPDemo]# ./fun_ptr_table </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">b</span><br><span class=\"line\">function b called ... </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">c</span><br><span class=\"line\">function c called ... </span><br><span class=\"line\">press a key from &apos;a&apos; to &apos;g&apos;or q to quit</span><br><span class=\"line\">q</span><br></pre></td></tr></table></figure>\n<p>16.C++允许将任何类型的指针赋值给void *，但不允许指针赋给任何其他类型的指针。</p>\n<p>17.C++中的访问控制</p>\n<table>\n<thead>\n<tr>\n<th>public</th>\n<th>在其后声明的所有成员可以被所有的人访问</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>private</td>\n<td>private关键字意味着，除了该类型的创建者和类的内部成员函数之外，任何人都不能访问</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>继承的结构可以访问protected成员，但不能访问private成员</td>\n</tr>\n</tbody>\n</table>\n<p>18.访问控制为类的创建者提供了很有价值的控制。类的客户程序员可以清楚的看到，什么可以用，什么应该忽略。更重要的是，它保证了使用类的客户程序员不会依赖类的实现细节，这样类库的开发者更改某些实现客户程序员不会因此受到影响。</p>\n<p>19.构造函数执行原理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class X &#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tX();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void f() &#123;</span><br><span class=\"line\">    X a;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当程序执行到a的序列点执行的点时，构造函数自动被调用，编译器悄悄的在a的定义点处拆入了一个X::X()的调用。就像其他成员函数被调用一样，传递到构造函数的第一个(秘密)参数是this指针，也就是调用这一个函数对象的内存地址，不过，对构造函数来说，this指针指向一个没有被初始化的内存块，构造函数的作用就是正确初始化该内存块</p>\n<p>20.当对象超出它的作用域的时候，编译器将自动调用析构函数。</p>\n<p>21.C++中禁止用返回值重载函数</p>\n<p>22.在C++中，struct和class唯一的不同之处在于，struct默认为public，而class默认为private。自然的，也可以让struct有构造啊函数和析构函数。另外，一个union（联合）也可以带有构造函数、析构函数、成员函数甚至访问控制。</p>\n<p>23.只有参数列表的后部参数才是可默认的；一旦在一个函数调用中开始使用默认参数，那么这个参数后面所有参数都必须是默认的。</p>\n<p>24.占位符参数:函数声明时，参数可以没有标识符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void f(int x, int, float flt);</span><br></pre></td></tr></table></figure>\n<p>如果开始用了一个函数参数，而后来发现不需要用它，可以将它去掉而不会产生警告错误，而且不需要改动那些调用该函数以前版本的程序代码。</p>\n<p>25.不能把默认参数作为一个标志去决定执行函数的哪一块，这是基本原则。在这种情况下，只要能够，就应该把函数分解成两个或多个重载的函数。</p>\n<p>26.关于const和指针</p>\n<p>u是一个指针，它指向一个const int，它所指的内容是不能被改变的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const int* u;</span><br></pre></td></tr></table></figure>\n<p>w是一个指针，这个指针是指向int的const指针，指针本身不可改变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int d = 1;</span><br><span class=\"line\">int* const w = &amp;d;</span><br></pre></td></tr></table></figure>\n<p>指针的对象都不能改变</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int d = 1;</span><br><span class=\"line\">const int* const x = &amp;d</span><br></pre></td></tr></table></figure>\n"},{"title":"CMU-DBMS-COURSE-03-NOTES","date":"2019-04-06T09:18:53.000Z","_content":"\n**存储器架构**\n\n![StorageHierarchy](CMU-DBMS-COURSE-03-NOTES/StorageHierarchy.png)\n\n- 存储器根据其存储特性可以分为多层，上层存储器容量小，运行速度快。\n- 寄存器，CPU缓存，DRAM是易失性存储，一旦断电，存储数据将丢失。\n- SSD，HDD等是非易失性存储，断电数据仍然保留。\n- Non-Volatile Memory(NVM) 是位于分界线上的一种存储，它有着比SSD更高的性能，并能提供持久化存储。\n\n**访问这些存储器的时延**\n\n![ACCESSTIMES](CMU-DBMS-COURSE-03-NOTES/ACCESSTIMES.png)\n\n**数据库设计的目标**\n\n- 允许DBMS去管理超过可用内存大小的存储量。\n- 读写磁盘的开销是很大的，所以必须要谨慎管理磁盘，避免出现性能下降。\n\n**顺序和随机访问的区别**\n\n- 随机访问HDD要比顺序访问慢很多。\n- 传统的数据库管理系统都是以最大化顺序访问为准则的。\n- 算法尝试减少写入随机页面的次数，将数据存在连续的块中。\n\n**mmap**\n\n- 可以使用mmap映射一个文件的内容到一个进程的地址空间\n- 操作系统的责任是将文件的页换入换出内存\n\n![mmap1](CMU-DBMS-COURSE-03-NOTES/mmap1.png)\n\n![mmap2](CMU-DBMS-COURSE-03-NOTES/mmap2.png)\n\n**为什么不使用操作系统的调用管理文件？**\n\n![mmap3](CMU-DBMS-COURSE-03-NOTES/mmap3.png)\n\n![mmap4](CMU-DBMS-COURSE-03-NOTES/mmap4.png)\n\n![mmap5](CMU-DBMS-COURSE-03-NOTES/mmap5.png)\n\n- 如果我们允许多个线程访问mmap文件去隐藏缺页错误呢？\n- 这对只读的请求是正常工作的，但是当面对多个写请求的时候情况就复杂了。\n- madvise：告诉操作系统，你期待怎么样去读某些页面？\n- mlock：告诉操作系统一定范围内的内存不能被还出\n- msync：告诉操作系统把内存的一定范围页面刷如磁盘\n\n**DBMS做的一些事情**\n\n- 以正确的顺序将脏页面写回磁盘\n- 专业的预读\n- 缓冲区的替换策略\n- 线程/进程调度\n\n**DBMS关注的两个问题**\n\n- DBMS如何在磁盘文件中表示数据库？\n- DBMS如何管理内存和磁盘之间来回的移动数据？\n\n**文件存储**\n\n- DBMS在一个或者多个磁盘文件中存储数据\n- 存储管理器(storage manager)的责任是管理数据库文件，它将文件组织成页集合的形式，跟踪读写到页面的数据，跟踪可用的存储空间\n\n**数据库页面**\n\n- 一个页面是固定大小的数据块，它可以包括元组(tuples)，元数据(meta-data)，索引(indexes)，日志记录(log records)\n- 大多数系统不回混合页面类型\n- 有些系统需要一个独立的页面\n- 每个页面都有一个唯一的标识符，DBMS使用一个间接层将页ID映射到实际的物理存储位置\n- 对于数据库系统中的页，有三种不同的概念：硬件页(Hardware Page)通常是4KB；操作系统页(OS Page)通常是4KB；数据库页面(Database Page)1-16KB\n\n**常见数据库页面大小**\n\n![pages](CMU-DBMS-COURSE-03-NOTES/pages.png)\n\n**页面存储架构**\n\n- 不同的DBMSs用不同的方式管理磁盘上面的页\n  - 堆文件组织(Heap File Organization)\n  - 顺序/排序文件组织(Sequential/Sorted File Organization)\n  - 哈希文件组织(Hash File Organization)\n\n**数据库Heap**\n\n- 堆文件(Heap file)是无序的页面集合，其中是按随机顺序存储的元组。作用：获取/删除页面；必须支持对所有页面进行迭代。\n- 需要元数据来跟踪存在的页面，以及哪些有空闲的空间\n- Heap file的形式有两种: LinkedList和Page Directory\n\n**LINKED LIST结构Heap file 特点**\n\n![PageLinkList](CMU-DBMS-COURSE-03-NOTES/PageLinkList.png)\n\n- 在文件开头存储了两个指针：空闲页list的头指针；数据页list的头指针\n- 每一页都跟踪它自己空闲slots的序号\n\n![DirPages](CMU-DBMS-COURSE-03-NOTES/DirPages.png)\n\n- DBMS维护了一个特殊的页面来跟踪数据页的位置在数据库文件中\n- 这个目录也记录了每个页面空闲slot序号\n- DBMS确保目录页与数据页同步\n\n**页面头部**\n\n![page_header](CMU-DBMS-COURSE-03-NOTES/page_header.png)\n\n- 每个页面都包含一个头部，里面包含了页面的元数据信息\n  - 页面大小\n  - 校验和\n  - DBMS的版本\n  - 事务的可见性\n  - 压缩信息\n- 有些系统需要页面变得独立，比如Oracle\n\n**页面的布局**\n\n- 对于任何页面存储架构来说，我们现在需要知道怎样在页面里面组织数据存储\n- 两种方法：\n  - 面向元组\n  - 日志结构\n\n**元组的存储**\n\n- 记录页面中远足的数量，然后往尾部增加新的元组\n\n![tuple1](CMU-DBMS-COURSE-03-NOTES/tuple1.png)\n\n![tuple2](CMU-DBMS-COURSE-03-NOTES/tuple2.png)\n\n![tuple3](CMU-DBMS-COURSE-03-NOTES/tuple3.png)\n\n![tuple4](CMU-DBMS-COURSE-03-NOTES/tuple4.png)\n\n**页面槽(Slotted pages)**\n\n- 最常见的页面部署方案称为槽页(slotted pages)\n- slot数组映射了slots到元组开始位置的偏移量、\n- header存储了使用了的slots，最后一个被使用slot的起始位置\n\n![slot-page1](CMU-DBMS-COURSE-03-NOTES/slot-page1.png)\n\n![slot-page2](CMU-DBMS-COURSE-03-NOTES/slot-page2.png)\n\n**日志文件型数据组织方式**\n\n![log1](CMU-DBMS-COURSE-03-NOTES/log1.png)\n\n- DBMS只存储日志记录，而不是将元组存储在页面中\n- 系统将数据库如何修改的日志追加到文件\n  - 插入存储整个元组\n  - 将元组标记为已删除\n  - 更新属性包含被修改的增量\n\n![log2](CMU-DBMS-COURSE-03-NOTES/log2.png)\n\n- 要读取记录，DBMS反向记录并重新创建元组，并找到它需要的东西\n- 建立索引允许跳到log的指定位置\n- 定期的压缩日志\n\n![log3](CMU-DBMS-COURSE-03-NOTES/log3.png)\n\n**日志的压缩**\n\n- 通过删除不必要的记录来将较大的日志文件合并成较小的文件\n- compaction的过程\n\n![compaction1](CMU-DBMS-COURSE-03-NOTES/compaction1.png)\n\n![compaction2](CMU-DBMS-COURSE-03-NOTES/compaction2.png)\n\n![compaction3](CMU-DBMS-COURSE-03-NOTES/compaction3.png)\n\n![compaction4](CMU-DBMS-COURSE-03-NOTES/compaction4.png)\n\n![compaction5](CMU-DBMS-COURSE-03-NOTES/compaction5.png)\n\n![compaction6](CMU-DBMS-COURSE-03-NOTES/compaction6.png)\n\n![compaction7](CMU-DBMS-COURSE-03-NOTES/compaction7.png)\n\n**元组布局**\n\n- 元组本质上是一个字节序列\n- DBMS的工作就是解释这些字节属性类型和值\n\n![tuple-header](CMU-DBMS-COURSE-03-NOTES/tuple-header.png)\n\n- 每个元组前面都有一个头包含有关它的元数据：可见性信息（用于并发控制）；为NULL值提供的BitMap\n- 我们为什么不需要存储schema的元数据信息呢？\n- 元组里面的数据按你创建表时候的命令组织\n- 组织这些数据是软件工程师要做的事情\n\n![tuple-data](CMU-DBMS-COURSE-03-NOTES/tuple-data.png)\n\n**非规范化元组数据(denormalized tuple data)**\n\n- 可以在物理上取消规范化相关元组并存储它们在同一页中\n  - 可以减少常见工作负载的I/O请求数量\n  - 可以使得update操作更高效\n\n![denormalized1](CMU-DBMS-COURSE-03-NOTES/denormalized1.png)\n\n![denormalized2](CMU-DBMS-COURSE-03-NOTES/denormalized2.png)\n\n![denormalized3](CMU-DBMS-COURSE-03-NOTES/denormalized3.png)\n\n**记录的ID**\n\n- DBMS需要一种跟踪单个元组的方法\n- 每个元组都被分配一个唯一的记录标识符\n  - 最常见：page_id + offset/slot\n  - 也可以包含文件的位置信息\n\n![record-ids](CMU-DBMS-COURSE-03-NOTES/record-ids.png)\n\n","source":"_posts/CMU-DBMS-COURSE-03-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-03-NOTES\ndate: 2019-04-06 17:18:53\ntags:\n---\n\n**存储器架构**\n\n![StorageHierarchy](CMU-DBMS-COURSE-03-NOTES/StorageHierarchy.png)\n\n- 存储器根据其存储特性可以分为多层，上层存储器容量小，运行速度快。\n- 寄存器，CPU缓存，DRAM是易失性存储，一旦断电，存储数据将丢失。\n- SSD，HDD等是非易失性存储，断电数据仍然保留。\n- Non-Volatile Memory(NVM) 是位于分界线上的一种存储，它有着比SSD更高的性能，并能提供持久化存储。\n\n**访问这些存储器的时延**\n\n![ACCESSTIMES](CMU-DBMS-COURSE-03-NOTES/ACCESSTIMES.png)\n\n**数据库设计的目标**\n\n- 允许DBMS去管理超过可用内存大小的存储量。\n- 读写磁盘的开销是很大的，所以必须要谨慎管理磁盘，避免出现性能下降。\n\n**顺序和随机访问的区别**\n\n- 随机访问HDD要比顺序访问慢很多。\n- 传统的数据库管理系统都是以最大化顺序访问为准则的。\n- 算法尝试减少写入随机页面的次数，将数据存在连续的块中。\n\n**mmap**\n\n- 可以使用mmap映射一个文件的内容到一个进程的地址空间\n- 操作系统的责任是将文件的页换入换出内存\n\n![mmap1](CMU-DBMS-COURSE-03-NOTES/mmap1.png)\n\n![mmap2](CMU-DBMS-COURSE-03-NOTES/mmap2.png)\n\n**为什么不使用操作系统的调用管理文件？**\n\n![mmap3](CMU-DBMS-COURSE-03-NOTES/mmap3.png)\n\n![mmap4](CMU-DBMS-COURSE-03-NOTES/mmap4.png)\n\n![mmap5](CMU-DBMS-COURSE-03-NOTES/mmap5.png)\n\n- 如果我们允许多个线程访问mmap文件去隐藏缺页错误呢？\n- 这对只读的请求是正常工作的，但是当面对多个写请求的时候情况就复杂了。\n- madvise：告诉操作系统，你期待怎么样去读某些页面？\n- mlock：告诉操作系统一定范围内的内存不能被还出\n- msync：告诉操作系统把内存的一定范围页面刷如磁盘\n\n**DBMS做的一些事情**\n\n- 以正确的顺序将脏页面写回磁盘\n- 专业的预读\n- 缓冲区的替换策略\n- 线程/进程调度\n\n**DBMS关注的两个问题**\n\n- DBMS如何在磁盘文件中表示数据库？\n- DBMS如何管理内存和磁盘之间来回的移动数据？\n\n**文件存储**\n\n- DBMS在一个或者多个磁盘文件中存储数据\n- 存储管理器(storage manager)的责任是管理数据库文件，它将文件组织成页集合的形式，跟踪读写到页面的数据，跟踪可用的存储空间\n\n**数据库页面**\n\n- 一个页面是固定大小的数据块，它可以包括元组(tuples)，元数据(meta-data)，索引(indexes)，日志记录(log records)\n- 大多数系统不回混合页面类型\n- 有些系统需要一个独立的页面\n- 每个页面都有一个唯一的标识符，DBMS使用一个间接层将页ID映射到实际的物理存储位置\n- 对于数据库系统中的页，有三种不同的概念：硬件页(Hardware Page)通常是4KB；操作系统页(OS Page)通常是4KB；数据库页面(Database Page)1-16KB\n\n**常见数据库页面大小**\n\n![pages](CMU-DBMS-COURSE-03-NOTES/pages.png)\n\n**页面存储架构**\n\n- 不同的DBMSs用不同的方式管理磁盘上面的页\n  - 堆文件组织(Heap File Organization)\n  - 顺序/排序文件组织(Sequential/Sorted File Organization)\n  - 哈希文件组织(Hash File Organization)\n\n**数据库Heap**\n\n- 堆文件(Heap file)是无序的页面集合，其中是按随机顺序存储的元组。作用：获取/删除页面；必须支持对所有页面进行迭代。\n- 需要元数据来跟踪存在的页面，以及哪些有空闲的空间\n- Heap file的形式有两种: LinkedList和Page Directory\n\n**LINKED LIST结构Heap file 特点**\n\n![PageLinkList](CMU-DBMS-COURSE-03-NOTES/PageLinkList.png)\n\n- 在文件开头存储了两个指针：空闲页list的头指针；数据页list的头指针\n- 每一页都跟踪它自己空闲slots的序号\n\n![DirPages](CMU-DBMS-COURSE-03-NOTES/DirPages.png)\n\n- DBMS维护了一个特殊的页面来跟踪数据页的位置在数据库文件中\n- 这个目录也记录了每个页面空闲slot序号\n- DBMS确保目录页与数据页同步\n\n**页面头部**\n\n![page_header](CMU-DBMS-COURSE-03-NOTES/page_header.png)\n\n- 每个页面都包含一个头部，里面包含了页面的元数据信息\n  - 页面大小\n  - 校验和\n  - DBMS的版本\n  - 事务的可见性\n  - 压缩信息\n- 有些系统需要页面变得独立，比如Oracle\n\n**页面的布局**\n\n- 对于任何页面存储架构来说，我们现在需要知道怎样在页面里面组织数据存储\n- 两种方法：\n  - 面向元组\n  - 日志结构\n\n**元组的存储**\n\n- 记录页面中远足的数量，然后往尾部增加新的元组\n\n![tuple1](CMU-DBMS-COURSE-03-NOTES/tuple1.png)\n\n![tuple2](CMU-DBMS-COURSE-03-NOTES/tuple2.png)\n\n![tuple3](CMU-DBMS-COURSE-03-NOTES/tuple3.png)\n\n![tuple4](CMU-DBMS-COURSE-03-NOTES/tuple4.png)\n\n**页面槽(Slotted pages)**\n\n- 最常见的页面部署方案称为槽页(slotted pages)\n- slot数组映射了slots到元组开始位置的偏移量、\n- header存储了使用了的slots，最后一个被使用slot的起始位置\n\n![slot-page1](CMU-DBMS-COURSE-03-NOTES/slot-page1.png)\n\n![slot-page2](CMU-DBMS-COURSE-03-NOTES/slot-page2.png)\n\n**日志文件型数据组织方式**\n\n![log1](CMU-DBMS-COURSE-03-NOTES/log1.png)\n\n- DBMS只存储日志记录，而不是将元组存储在页面中\n- 系统将数据库如何修改的日志追加到文件\n  - 插入存储整个元组\n  - 将元组标记为已删除\n  - 更新属性包含被修改的增量\n\n![log2](CMU-DBMS-COURSE-03-NOTES/log2.png)\n\n- 要读取记录，DBMS反向记录并重新创建元组，并找到它需要的东西\n- 建立索引允许跳到log的指定位置\n- 定期的压缩日志\n\n![log3](CMU-DBMS-COURSE-03-NOTES/log3.png)\n\n**日志的压缩**\n\n- 通过删除不必要的记录来将较大的日志文件合并成较小的文件\n- compaction的过程\n\n![compaction1](CMU-DBMS-COURSE-03-NOTES/compaction1.png)\n\n![compaction2](CMU-DBMS-COURSE-03-NOTES/compaction2.png)\n\n![compaction3](CMU-DBMS-COURSE-03-NOTES/compaction3.png)\n\n![compaction4](CMU-DBMS-COURSE-03-NOTES/compaction4.png)\n\n![compaction5](CMU-DBMS-COURSE-03-NOTES/compaction5.png)\n\n![compaction6](CMU-DBMS-COURSE-03-NOTES/compaction6.png)\n\n![compaction7](CMU-DBMS-COURSE-03-NOTES/compaction7.png)\n\n**元组布局**\n\n- 元组本质上是一个字节序列\n- DBMS的工作就是解释这些字节属性类型和值\n\n![tuple-header](CMU-DBMS-COURSE-03-NOTES/tuple-header.png)\n\n- 每个元组前面都有一个头包含有关它的元数据：可见性信息（用于并发控制）；为NULL值提供的BitMap\n- 我们为什么不需要存储schema的元数据信息呢？\n- 元组里面的数据按你创建表时候的命令组织\n- 组织这些数据是软件工程师要做的事情\n\n![tuple-data](CMU-DBMS-COURSE-03-NOTES/tuple-data.png)\n\n**非规范化元组数据(denormalized tuple data)**\n\n- 可以在物理上取消规范化相关元组并存储它们在同一页中\n  - 可以减少常见工作负载的I/O请求数量\n  - 可以使得update操作更高效\n\n![denormalized1](CMU-DBMS-COURSE-03-NOTES/denormalized1.png)\n\n![denormalized2](CMU-DBMS-COURSE-03-NOTES/denormalized2.png)\n\n![denormalized3](CMU-DBMS-COURSE-03-NOTES/denormalized3.png)\n\n**记录的ID**\n\n- DBMS需要一种跟踪单个元组的方法\n- 每个元组都被分配一个唯一的记录标识符\n  - 最常见：page_id + offset/slot\n  - 也可以包含文件的位置信息\n\n![record-ids](CMU-DBMS-COURSE-03-NOTES/record-ids.png)\n\n","slug":"CMU-DBMS-COURSE-03-NOTES","published":1,"updated":"2019-06-26T11:56:34.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvym90005vkqp6finyhmd","content":"<p><strong>存储器架构</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/StorageHierarchy.png\" alt=\"StorageHierarchy\"></p>\n<ul>\n<li>存储器根据其存储特性可以分为多层，上层存储器容量小，运行速度快。</li>\n<li>寄存器，CPU缓存，DRAM是易失性存储，一旦断电，存储数据将丢失。</li>\n<li>SSD，HDD等是非易失性存储，断电数据仍然保留。</li>\n<li>Non-Volatile Memory(NVM) 是位于分界线上的一种存储，它有着比SSD更高的性能，并能提供持久化存储。</li>\n</ul>\n<p><strong>访问这些存储器的时延</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/ACCESSTIMES.png\" alt=\"ACCESSTIMES\"></p>\n<p><strong>数据库设计的目标</strong></p>\n<ul>\n<li>允许DBMS去管理超过可用内存大小的存储量。</li>\n<li>读写磁盘的开销是很大的，所以必须要谨慎管理磁盘，避免出现性能下降。</li>\n</ul>\n<p><strong>顺序和随机访问的区别</strong></p>\n<ul>\n<li>随机访问HDD要比顺序访问慢很多。</li>\n<li>传统的数据库管理系统都是以最大化顺序访问为准则的。</li>\n<li>算法尝试减少写入随机页面的次数，将数据存在连续的块中。</li>\n</ul>\n<p><strong>mmap</strong></p>\n<ul>\n<li>可以使用mmap映射一个文件的内容到一个进程的地址空间</li>\n<li>操作系统的责任是将文件的页换入换出内存</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/mmap1.png\" alt=\"mmap1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/mmap2.png\" alt=\"mmap2\"></p>\n<p><strong>为什么不使用操作系统的调用管理文件？</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/mmap3.png\" alt=\"mmap3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/mmap4.png\" alt=\"mmap4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/mmap5.png\" alt=\"mmap5\"></p>\n<ul>\n<li>如果我们允许多个线程访问mmap文件去隐藏缺页错误呢？</li>\n<li>这对只读的请求是正常工作的，但是当面对多个写请求的时候情况就复杂了。</li>\n<li>madvise：告诉操作系统，你期待怎么样去读某些页面？</li>\n<li>mlock：告诉操作系统一定范围内的内存不能被还出</li>\n<li>msync：告诉操作系统把内存的一定范围页面刷如磁盘</li>\n</ul>\n<p><strong>DBMS做的一些事情</strong></p>\n<ul>\n<li>以正确的顺序将脏页面写回磁盘</li>\n<li>专业的预读</li>\n<li>缓冲区的替换策略</li>\n<li>线程/进程调度</li>\n</ul>\n<p><strong>DBMS关注的两个问题</strong></p>\n<ul>\n<li>DBMS如何在磁盘文件中表示数据库？</li>\n<li>DBMS如何管理内存和磁盘之间来回的移动数据？</li>\n</ul>\n<p><strong>文件存储</strong></p>\n<ul>\n<li>DBMS在一个或者多个磁盘文件中存储数据</li>\n<li>存储管理器(storage manager)的责任是管理数据库文件，它将文件组织成页集合的形式，跟踪读写到页面的数据，跟踪可用的存储空间</li>\n</ul>\n<p><strong>数据库页面</strong></p>\n<ul>\n<li>一个页面是固定大小的数据块，它可以包括元组(tuples)，元数据(meta-data)，索引(indexes)，日志记录(log records)</li>\n<li>大多数系统不回混合页面类型</li>\n<li>有些系统需要一个独立的页面</li>\n<li>每个页面都有一个唯一的标识符，DBMS使用一个间接层将页ID映射到实际的物理存储位置</li>\n<li>对于数据库系统中的页，有三种不同的概念：硬件页(Hardware Page)通常是4KB；操作系统页(OS Page)通常是4KB；数据库页面(Database Page)1-16KB</li>\n</ul>\n<p><strong>常见数据库页面大小</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/pages.png\" alt=\"pages\"></p>\n<p><strong>页面存储架构</strong></p>\n<ul>\n<li>不同的DBMSs用不同的方式管理磁盘上面的页<ul>\n<li>堆文件组织(Heap File Organization)</li>\n<li>顺序/排序文件组织(Sequential/Sorted File Organization)</li>\n<li>哈希文件组织(Hash File Organization)</li>\n</ul>\n</li>\n</ul>\n<p><strong>数据库Heap</strong></p>\n<ul>\n<li>堆文件(Heap file)是无序的页面集合，其中是按随机顺序存储的元组。作用：获取/删除页面；必须支持对所有页面进行迭代。</li>\n<li>需要元数据来跟踪存在的页面，以及哪些有空闲的空间</li>\n<li>Heap file的形式有两种: LinkedList和Page Directory</li>\n</ul>\n<p><strong>LINKED LIST结构Heap file 特点</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/PageLinkList.png\" alt=\"PageLinkList\"></p>\n<ul>\n<li>在文件开头存储了两个指针：空闲页list的头指针；数据页list的头指针</li>\n<li>每一页都跟踪它自己空闲slots的序号</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/DirPages.png\" alt=\"DirPages\"></p>\n<ul>\n<li>DBMS维护了一个特殊的页面来跟踪数据页的位置在数据库文件中</li>\n<li>这个目录也记录了每个页面空闲slot序号</li>\n<li>DBMS确保目录页与数据页同步</li>\n</ul>\n<p><strong>页面头部</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/page_header.png\" alt=\"page_header\"></p>\n<ul>\n<li>每个页面都包含一个头部，里面包含了页面的元数据信息<ul>\n<li>页面大小</li>\n<li>校验和</li>\n<li>DBMS的版本</li>\n<li>事务的可见性</li>\n<li>压缩信息</li>\n</ul>\n</li>\n<li>有些系统需要页面变得独立，比如Oracle</li>\n</ul>\n<p><strong>页面的布局</strong></p>\n<ul>\n<li>对于任何页面存储架构来说，我们现在需要知道怎样在页面里面组织数据存储</li>\n<li>两种方法：<ul>\n<li>面向元组</li>\n<li>日志结构</li>\n</ul>\n</li>\n</ul>\n<p><strong>元组的存储</strong></p>\n<ul>\n<li>记录页面中远足的数量，然后往尾部增加新的元组</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple1.png\" alt=\"tuple1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple2.png\" alt=\"tuple2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple3.png\" alt=\"tuple3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple4.png\" alt=\"tuple4\"></p>\n<p><strong>页面槽(Slotted pages)</strong></p>\n<ul>\n<li>最常见的页面部署方案称为槽页(slotted pages)</li>\n<li>slot数组映射了slots到元组开始位置的偏移量、</li>\n<li>header存储了使用了的slots，最后一个被使用slot的起始位置</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/slot-page1.png\" alt=\"slot-page1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/slot-page2.png\" alt=\"slot-page2\"></p>\n<p><strong>日志文件型数据组织方式</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/log1.png\" alt=\"log1\"></p>\n<ul>\n<li>DBMS只存储日志记录，而不是将元组存储在页面中</li>\n<li>系统将数据库如何修改的日志追加到文件<ul>\n<li>插入存储整个元组</li>\n<li>将元组标记为已删除</li>\n<li>更新属性包含被修改的增量</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/log2.png\" alt=\"log2\"></p>\n<ul>\n<li>要读取记录，DBMS反向记录并重新创建元组，并找到它需要的东西</li>\n<li>建立索引允许跳到log的指定位置</li>\n<li>定期的压缩日志</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/log3.png\" alt=\"log3\"></p>\n<p><strong>日志的压缩</strong></p>\n<ul>\n<li>通过删除不必要的记录来将较大的日志文件合并成较小的文件</li>\n<li>compaction的过程</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction1.png\" alt=\"compaction1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction2.png\" alt=\"compaction2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction3.png\" alt=\"compaction3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction4.png\" alt=\"compaction4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction5.png\" alt=\"compaction5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction6.png\" alt=\"compaction6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction7.png\" alt=\"compaction7\"></p>\n<p><strong>元组布局</strong></p>\n<ul>\n<li>元组本质上是一个字节序列</li>\n<li>DBMS的工作就是解释这些字节属性类型和值</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple-header.png\" alt=\"tuple-header\"></p>\n<ul>\n<li>每个元组前面都有一个头包含有关它的元数据：可见性信息（用于并发控制）；为NULL值提供的BitMap</li>\n<li>我们为什么不需要存储schema的元数据信息呢？</li>\n<li>元组里面的数据按你创建表时候的命令组织</li>\n<li>组织这些数据是软件工程师要做的事情</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple-data.png\" alt=\"tuple-data\"></p>\n<p><strong>非规范化元组数据(denormalized tuple data)</strong></p>\n<ul>\n<li>可以在物理上取消规范化相关元组并存储它们在同一页中<ul>\n<li>可以减少常见工作负载的I/O请求数量</li>\n<li>可以使得update操作更高效</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/denormalized1.png\" alt=\"denormalized1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/denormalized2.png\" alt=\"denormalized2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/denormalized3.png\" alt=\"denormalized3\"></p>\n<p><strong>记录的ID</strong></p>\n<ul>\n<li>DBMS需要一种跟踪单个元组的方法</li>\n<li>每个元组都被分配一个唯一的记录标识符<ul>\n<li>最常见：page_id + offset/slot</li>\n<li>也可以包含文件的位置信息</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/record-ids.png\" alt=\"record-ids\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>存储器架构</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/StorageHierarchy.png\" alt=\"StorageHierarchy\"></p>\n<ul>\n<li>存储器根据其存储特性可以分为多层，上层存储器容量小，运行速度快。</li>\n<li>寄存器，CPU缓存，DRAM是易失性存储，一旦断电，存储数据将丢失。</li>\n<li>SSD，HDD等是非易失性存储，断电数据仍然保留。</li>\n<li>Non-Volatile Memory(NVM) 是位于分界线上的一种存储，它有着比SSD更高的性能，并能提供持久化存储。</li>\n</ul>\n<p><strong>访问这些存储器的时延</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/ACCESSTIMES.png\" alt=\"ACCESSTIMES\"></p>\n<p><strong>数据库设计的目标</strong></p>\n<ul>\n<li>允许DBMS去管理超过可用内存大小的存储量。</li>\n<li>读写磁盘的开销是很大的，所以必须要谨慎管理磁盘，避免出现性能下降。</li>\n</ul>\n<p><strong>顺序和随机访问的区别</strong></p>\n<ul>\n<li>随机访问HDD要比顺序访问慢很多。</li>\n<li>传统的数据库管理系统都是以最大化顺序访问为准则的。</li>\n<li>算法尝试减少写入随机页面的次数，将数据存在连续的块中。</li>\n</ul>\n<p><strong>mmap</strong></p>\n<ul>\n<li>可以使用mmap映射一个文件的内容到一个进程的地址空间</li>\n<li>操作系统的责任是将文件的页换入换出内存</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/mmap1.png\" alt=\"mmap1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/mmap2.png\" alt=\"mmap2\"></p>\n<p><strong>为什么不使用操作系统的调用管理文件？</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/mmap3.png\" alt=\"mmap3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/mmap4.png\" alt=\"mmap4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/mmap5.png\" alt=\"mmap5\"></p>\n<ul>\n<li>如果我们允许多个线程访问mmap文件去隐藏缺页错误呢？</li>\n<li>这对只读的请求是正常工作的，但是当面对多个写请求的时候情况就复杂了。</li>\n<li>madvise：告诉操作系统，你期待怎么样去读某些页面？</li>\n<li>mlock：告诉操作系统一定范围内的内存不能被还出</li>\n<li>msync：告诉操作系统把内存的一定范围页面刷如磁盘</li>\n</ul>\n<p><strong>DBMS做的一些事情</strong></p>\n<ul>\n<li>以正确的顺序将脏页面写回磁盘</li>\n<li>专业的预读</li>\n<li>缓冲区的替换策略</li>\n<li>线程/进程调度</li>\n</ul>\n<p><strong>DBMS关注的两个问题</strong></p>\n<ul>\n<li>DBMS如何在磁盘文件中表示数据库？</li>\n<li>DBMS如何管理内存和磁盘之间来回的移动数据？</li>\n</ul>\n<p><strong>文件存储</strong></p>\n<ul>\n<li>DBMS在一个或者多个磁盘文件中存储数据</li>\n<li>存储管理器(storage manager)的责任是管理数据库文件，它将文件组织成页集合的形式，跟踪读写到页面的数据，跟踪可用的存储空间</li>\n</ul>\n<p><strong>数据库页面</strong></p>\n<ul>\n<li>一个页面是固定大小的数据块，它可以包括元组(tuples)，元数据(meta-data)，索引(indexes)，日志记录(log records)</li>\n<li>大多数系统不回混合页面类型</li>\n<li>有些系统需要一个独立的页面</li>\n<li>每个页面都有一个唯一的标识符，DBMS使用一个间接层将页ID映射到实际的物理存储位置</li>\n<li>对于数据库系统中的页，有三种不同的概念：硬件页(Hardware Page)通常是4KB；操作系统页(OS Page)通常是4KB；数据库页面(Database Page)1-16KB</li>\n</ul>\n<p><strong>常见数据库页面大小</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/pages.png\" alt=\"pages\"></p>\n<p><strong>页面存储架构</strong></p>\n<ul>\n<li>不同的DBMSs用不同的方式管理磁盘上面的页<ul>\n<li>堆文件组织(Heap File Organization)</li>\n<li>顺序/排序文件组织(Sequential/Sorted File Organization)</li>\n<li>哈希文件组织(Hash File Organization)</li>\n</ul>\n</li>\n</ul>\n<p><strong>数据库Heap</strong></p>\n<ul>\n<li>堆文件(Heap file)是无序的页面集合，其中是按随机顺序存储的元组。作用：获取/删除页面；必须支持对所有页面进行迭代。</li>\n<li>需要元数据来跟踪存在的页面，以及哪些有空闲的空间</li>\n<li>Heap file的形式有两种: LinkedList和Page Directory</li>\n</ul>\n<p><strong>LINKED LIST结构Heap file 特点</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/PageLinkList.png\" alt=\"PageLinkList\"></p>\n<ul>\n<li>在文件开头存储了两个指针：空闲页list的头指针；数据页list的头指针</li>\n<li>每一页都跟踪它自己空闲slots的序号</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/DirPages.png\" alt=\"DirPages\"></p>\n<ul>\n<li>DBMS维护了一个特殊的页面来跟踪数据页的位置在数据库文件中</li>\n<li>这个目录也记录了每个页面空闲slot序号</li>\n<li>DBMS确保目录页与数据页同步</li>\n</ul>\n<p><strong>页面头部</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/page_header.png\" alt=\"page_header\"></p>\n<ul>\n<li>每个页面都包含一个头部，里面包含了页面的元数据信息<ul>\n<li>页面大小</li>\n<li>校验和</li>\n<li>DBMS的版本</li>\n<li>事务的可见性</li>\n<li>压缩信息</li>\n</ul>\n</li>\n<li>有些系统需要页面变得独立，比如Oracle</li>\n</ul>\n<p><strong>页面的布局</strong></p>\n<ul>\n<li>对于任何页面存储架构来说，我们现在需要知道怎样在页面里面组织数据存储</li>\n<li>两种方法：<ul>\n<li>面向元组</li>\n<li>日志结构</li>\n</ul>\n</li>\n</ul>\n<p><strong>元组的存储</strong></p>\n<ul>\n<li>记录页面中远足的数量，然后往尾部增加新的元组</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple1.png\" alt=\"tuple1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple2.png\" alt=\"tuple2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple3.png\" alt=\"tuple3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple4.png\" alt=\"tuple4\"></p>\n<p><strong>页面槽(Slotted pages)</strong></p>\n<ul>\n<li>最常见的页面部署方案称为槽页(slotted pages)</li>\n<li>slot数组映射了slots到元组开始位置的偏移量、</li>\n<li>header存储了使用了的slots，最后一个被使用slot的起始位置</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/slot-page1.png\" alt=\"slot-page1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/slot-page2.png\" alt=\"slot-page2\"></p>\n<p><strong>日志文件型数据组织方式</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/log1.png\" alt=\"log1\"></p>\n<ul>\n<li>DBMS只存储日志记录，而不是将元组存储在页面中</li>\n<li>系统将数据库如何修改的日志追加到文件<ul>\n<li>插入存储整个元组</li>\n<li>将元组标记为已删除</li>\n<li>更新属性包含被修改的增量</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/log2.png\" alt=\"log2\"></p>\n<ul>\n<li>要读取记录，DBMS反向记录并重新创建元组，并找到它需要的东西</li>\n<li>建立索引允许跳到log的指定位置</li>\n<li>定期的压缩日志</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/log3.png\" alt=\"log3\"></p>\n<p><strong>日志的压缩</strong></p>\n<ul>\n<li>通过删除不必要的记录来将较大的日志文件合并成较小的文件</li>\n<li>compaction的过程</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction1.png\" alt=\"compaction1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction2.png\" alt=\"compaction2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction3.png\" alt=\"compaction3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction4.png\" alt=\"compaction4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction5.png\" alt=\"compaction5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction6.png\" alt=\"compaction6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/compaction7.png\" alt=\"compaction7\"></p>\n<p><strong>元组布局</strong></p>\n<ul>\n<li>元组本质上是一个字节序列</li>\n<li>DBMS的工作就是解释这些字节属性类型和值</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple-header.png\" alt=\"tuple-header\"></p>\n<ul>\n<li>每个元组前面都有一个头包含有关它的元数据：可见性信息（用于并发控制）；为NULL值提供的BitMap</li>\n<li>我们为什么不需要存储schema的元数据信息呢？</li>\n<li>元组里面的数据按你创建表时候的命令组织</li>\n<li>组织这些数据是软件工程师要做的事情</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/tuple-data.png\" alt=\"tuple-data\"></p>\n<p><strong>非规范化元组数据(denormalized tuple data)</strong></p>\n<ul>\n<li>可以在物理上取消规范化相关元组并存储它们在同一页中<ul>\n<li>可以减少常见工作负载的I/O请求数量</li>\n<li>可以使得update操作更高效</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/denormalized1.png\" alt=\"denormalized1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/denormalized2.png\" alt=\"denormalized2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/denormalized3.png\" alt=\"denormalized3\"></p>\n<p><strong>记录的ID</strong></p>\n<ul>\n<li>DBMS需要一种跟踪单个元组的方法</li>\n<li>每个元组都被分配一个唯一的记录标识符<ul>\n<li>最常见：page_id + offset/slot</li>\n<li>也可以包含文件的位置信息</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-03-NOTES/record-ids.png\" alt=\"record-ids\"></p>\n"},{"title":"CMU-DBMS-COURSE-04-NOTES","date":"2019-04-06T09:24:26.000Z","_content":"\n**磁盘式数据库存储架构**\n\n- DBMS假设数据库主要存储在非易失性设备上\n- DBMS的组建管理数据在非易失性存储和易失性存储之间的数据移动\n\n![disk-oriented1](CMU-DBMS-COURSE-04-NOTES/oriented1.png)\n\n![disk-oriented2](CMU-DBMS-COURSE-04-NOTES/oriented2.png)\n\n![disk-oriented3](CMU-DBMS-COURSE-04-NOTES/oriented3.png)\n\n![disk-oriented4](CMU-DBMS-COURSE-04-NOTES/oriented4.png)\n\n![disk-oriented5](CMU-DBMS-COURSE-04-NOTES/oriented5.png)\n\n**元组存储**\n\n- 元组本质上是一个字节序列，DBMS的工作就是解释这些字节属性类型和值\n- DBMS的catalogs包含了系统用来描述系统表的信息，以及描述元组的布局\n\n**数据表示**\n\n- INTEGER/BIGINT/SMALLINT/TINYINT，C/C++表示\n- FLOAT/REAL vs NUMERIC/DECIMAL，IEEE-754 标准，定点小数\n- VARCHAR/VARBINARY/TEXT/BLOB，头部以串长度开头，接着是具体的数据类型\n- TIME/DATE/TIMESTAMP，32/64位整数 Unix时间格式\n\n**可变精度的数字**\n\n- 不精确，可变精度的数据类型使用原声的C/C++类型\n- 按照IEEE-754的规定直接存储\n- 通常比任意精度的速度要快，例如：FLOAT, REAL/DOUBLE\n\n![var](CMU-DBMS-COURSE-04-NOTES/var.png)\n\n**固定精度的数字**\n\n- 具有任意精度和规模的数据类型，当误差不可接受时使用，如NUMERIC,DECIMAL\n- 通常存储在精确的可变长度二进制文件中并附加元数据表示\n\n**超大的值**\n\n- 大多数DBMS不允许元组超过单个页面大小\n- 存储大于一个页面的值，DBMS使用单独的溢出存储页(overflow page)存储\n  - Postgres：TOAST (> 2KB)\n  - MySQL：Overflow (> 1/2 size of page)\n\n![lager_v](CMU-DBMS-COURSE-04-NOTES/lager_v.png)\n\n**外部值存储（External value storage）**\n\n- 一些系统允许你在一个外部文件中存储一个很大的值\n- 作为BLOB类型处理\n  - Oracle：BFILE \n  - Microsoft：FILESTREAM\n\n![external-f](CMU-DBMS-COURSE-04-NOTES/external-f.png)\n\n- DBMS无法操作外部文件的内容\n  - 无持久化保护\n  - 没有事务保护\n\n**系统目录 (System catalogs)**\n\n- 一个数据库的元数据是存储在其数据库内部的catalogs\n  - Tables，columns，indexes，views\n  - Users，permissions\n  - Internal statistics（内部统计)\n- 几乎每个DBMS都存储其数据库的目录\n- 你可以查数据库内部的information_schema来获取数据库信息\n- ANSI的标准提供了一系列的视图包括表，视图，列，过程\n- DBMS也有非标准的快捷方式来检索这些信息\n\n**OLTP**\n\n- On-line Transaction Processing（在线事务处理）\n- 读取和更新数据库中的单个实体的小量数据\n\n![OLTP](CMU-DBMS-COURSE-04-NOTES/OLTP.png)\n\n**OLAP**\n\n- On-line Analytical Processing (在线分析处理)\n- 读取跨越多个实体的大量数据的复杂查询\n\n![OLAP](CMU-DBMS-COURSE-04-NOTES/OLAP.png)\n\n**数据存储模型**\n\n- 为了使OLTP或者OLAP性能更好，DBMS用不同的方式存储元组\n\n**N-ARY STORAGE MODEL (NSM)**\n\n- DBMS在一个页面中连续的存储单个元组，每个元组存储了所有的属性\n- 适用于OLTP的工作负载，尽在单个实体上操作，大量的插入工作负载\n\n![NSM-1](CMU-DBMS-COURSE-04-NOTES/NSM-1.png)\n\n![NSM-2](CMU-DBMS-COURSE-04-NOTES/NSM-2.png)\n\n![NSM-3](CMU-DBMS-COURSE-04-NOTES/NSM-3.png)\n\n- NSM优点：快速插入，更新，删除元组\n- NSM缺点：不适合表的部分属性扫描\n\n**DECOMPOSITION STORAGE MODEL (DSM)**\n\n- DBMS在页中相邻的所有元组中存储单个属性的值\n- 比较出名的是“列族存储”\n- 适用于只读的OLAP查询工作，比如scan某个属性的所有值\n\n![DSM](CMU-DBMS-COURSE-04-NOTES/DSM.png)\n\n- DSM优点：减少浪费的I/O请求量，因为DBMS只读区所需要的数据；更好的处理查询任务和数据压缩。\n- DSM缺点：单个元组的查询、插入、更新和删除速度慢，因为元组属性被分散在不同的页面中。","source":"_posts/CMU-DBMS-COURSE-04-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-04-NOTES\ndate: 2019-04-06 17:24:26\ntags:\n---\n\n**磁盘式数据库存储架构**\n\n- DBMS假设数据库主要存储在非易失性设备上\n- DBMS的组建管理数据在非易失性存储和易失性存储之间的数据移动\n\n![disk-oriented1](CMU-DBMS-COURSE-04-NOTES/oriented1.png)\n\n![disk-oriented2](CMU-DBMS-COURSE-04-NOTES/oriented2.png)\n\n![disk-oriented3](CMU-DBMS-COURSE-04-NOTES/oriented3.png)\n\n![disk-oriented4](CMU-DBMS-COURSE-04-NOTES/oriented4.png)\n\n![disk-oriented5](CMU-DBMS-COURSE-04-NOTES/oriented5.png)\n\n**元组存储**\n\n- 元组本质上是一个字节序列，DBMS的工作就是解释这些字节属性类型和值\n- DBMS的catalogs包含了系统用来描述系统表的信息，以及描述元组的布局\n\n**数据表示**\n\n- INTEGER/BIGINT/SMALLINT/TINYINT，C/C++表示\n- FLOAT/REAL vs NUMERIC/DECIMAL，IEEE-754 标准，定点小数\n- VARCHAR/VARBINARY/TEXT/BLOB，头部以串长度开头，接着是具体的数据类型\n- TIME/DATE/TIMESTAMP，32/64位整数 Unix时间格式\n\n**可变精度的数字**\n\n- 不精确，可变精度的数据类型使用原声的C/C++类型\n- 按照IEEE-754的规定直接存储\n- 通常比任意精度的速度要快，例如：FLOAT, REAL/DOUBLE\n\n![var](CMU-DBMS-COURSE-04-NOTES/var.png)\n\n**固定精度的数字**\n\n- 具有任意精度和规模的数据类型，当误差不可接受时使用，如NUMERIC,DECIMAL\n- 通常存储在精确的可变长度二进制文件中并附加元数据表示\n\n**超大的值**\n\n- 大多数DBMS不允许元组超过单个页面大小\n- 存储大于一个页面的值，DBMS使用单独的溢出存储页(overflow page)存储\n  - Postgres：TOAST (> 2KB)\n  - MySQL：Overflow (> 1/2 size of page)\n\n![lager_v](CMU-DBMS-COURSE-04-NOTES/lager_v.png)\n\n**外部值存储（External value storage）**\n\n- 一些系统允许你在一个外部文件中存储一个很大的值\n- 作为BLOB类型处理\n  - Oracle：BFILE \n  - Microsoft：FILESTREAM\n\n![external-f](CMU-DBMS-COURSE-04-NOTES/external-f.png)\n\n- DBMS无法操作外部文件的内容\n  - 无持久化保护\n  - 没有事务保护\n\n**系统目录 (System catalogs)**\n\n- 一个数据库的元数据是存储在其数据库内部的catalogs\n  - Tables，columns，indexes，views\n  - Users，permissions\n  - Internal statistics（内部统计)\n- 几乎每个DBMS都存储其数据库的目录\n- 你可以查数据库内部的information_schema来获取数据库信息\n- ANSI的标准提供了一系列的视图包括表，视图，列，过程\n- DBMS也有非标准的快捷方式来检索这些信息\n\n**OLTP**\n\n- On-line Transaction Processing（在线事务处理）\n- 读取和更新数据库中的单个实体的小量数据\n\n![OLTP](CMU-DBMS-COURSE-04-NOTES/OLTP.png)\n\n**OLAP**\n\n- On-line Analytical Processing (在线分析处理)\n- 读取跨越多个实体的大量数据的复杂查询\n\n![OLAP](CMU-DBMS-COURSE-04-NOTES/OLAP.png)\n\n**数据存储模型**\n\n- 为了使OLTP或者OLAP性能更好，DBMS用不同的方式存储元组\n\n**N-ARY STORAGE MODEL (NSM)**\n\n- DBMS在一个页面中连续的存储单个元组，每个元组存储了所有的属性\n- 适用于OLTP的工作负载，尽在单个实体上操作，大量的插入工作负载\n\n![NSM-1](CMU-DBMS-COURSE-04-NOTES/NSM-1.png)\n\n![NSM-2](CMU-DBMS-COURSE-04-NOTES/NSM-2.png)\n\n![NSM-3](CMU-DBMS-COURSE-04-NOTES/NSM-3.png)\n\n- NSM优点：快速插入，更新，删除元组\n- NSM缺点：不适合表的部分属性扫描\n\n**DECOMPOSITION STORAGE MODEL (DSM)**\n\n- DBMS在页中相邻的所有元组中存储单个属性的值\n- 比较出名的是“列族存储”\n- 适用于只读的OLAP查询工作，比如scan某个属性的所有值\n\n![DSM](CMU-DBMS-COURSE-04-NOTES/DSM.png)\n\n- DSM优点：减少浪费的I/O请求量，因为DBMS只读区所需要的数据；更好的处理查询任务和数据压缩。\n- DSM缺点：单个元组的查询、插入、更新和删除速度慢，因为元组属性被分散在不同的页面中。","slug":"CMU-DBMS-COURSE-04-NOTES","published":1,"updated":"2019-06-26T11:56:34.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvymb0007vkqpmf1cqy3q","content":"<p><strong>磁盘式数据库存储架构</strong></p>\n<ul>\n<li>DBMS假设数据库主要存储在非易失性设备上</li>\n<li>DBMS的组建管理数据在非易失性存储和易失性存储之间的数据移动</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/oriented1.png\" alt=\"disk-oriented1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/oriented2.png\" alt=\"disk-oriented2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/oriented3.png\" alt=\"disk-oriented3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/oriented4.png\" alt=\"disk-oriented4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/oriented5.png\" alt=\"disk-oriented5\"></p>\n<p><strong>元组存储</strong></p>\n<ul>\n<li>元组本质上是一个字节序列，DBMS的工作就是解释这些字节属性类型和值</li>\n<li>DBMS的catalogs包含了系统用来描述系统表的信息，以及描述元组的布局</li>\n</ul>\n<p><strong>数据表示</strong></p>\n<ul>\n<li>INTEGER/BIGINT/SMALLINT/TINYINT，C/C++表示</li>\n<li>FLOAT/REAL vs NUMERIC/DECIMAL，IEEE-754 标准，定点小数</li>\n<li>VARCHAR/VARBINARY/TEXT/BLOB，头部以串长度开头，接着是具体的数据类型</li>\n<li>TIME/DATE/TIMESTAMP，32/64位整数 Unix时间格式</li>\n</ul>\n<p><strong>可变精度的数字</strong></p>\n<ul>\n<li>不精确，可变精度的数据类型使用原声的C/C++类型</li>\n<li>按照IEEE-754的规定直接存储</li>\n<li>通常比任意精度的速度要快，例如：FLOAT, REAL/DOUBLE</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/var.png\" alt=\"var\"></p>\n<p><strong>固定精度的数字</strong></p>\n<ul>\n<li>具有任意精度和规模的数据类型，当误差不可接受时使用，如NUMERIC,DECIMAL</li>\n<li>通常存储在精确的可变长度二进制文件中并附加元数据表示</li>\n</ul>\n<p><strong>超大的值</strong></p>\n<ul>\n<li>大多数DBMS不允许元组超过单个页面大小</li>\n<li>存储大于一个页面的值，DBMS使用单独的溢出存储页(overflow page)存储<ul>\n<li>Postgres：TOAST (&gt; 2KB)</li>\n<li>MySQL：Overflow (&gt; 1/2 size of page)</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/lager_v.png\" alt=\"lager_v\"></p>\n<p><strong>外部值存储（External value storage）</strong></p>\n<ul>\n<li>一些系统允许你在一个外部文件中存储一个很大的值</li>\n<li>作为BLOB类型处理<ul>\n<li>Oracle：BFILE </li>\n<li>Microsoft：FILESTREAM</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/external-f.png\" alt=\"external-f\"></p>\n<ul>\n<li>DBMS无法操作外部文件的内容<ul>\n<li>无持久化保护</li>\n<li>没有事务保护</li>\n</ul>\n</li>\n</ul>\n<p><strong>系统目录 (System catalogs)</strong></p>\n<ul>\n<li>一个数据库的元数据是存储在其数据库内部的catalogs<ul>\n<li>Tables，columns，indexes，views</li>\n<li>Users，permissions</li>\n<li>Internal statistics（内部统计)</li>\n</ul>\n</li>\n<li>几乎每个DBMS都存储其数据库的目录</li>\n<li>你可以查数据库内部的information_schema来获取数据库信息</li>\n<li>ANSI的标准提供了一系列的视图包括表，视图，列，过程</li>\n<li>DBMS也有非标准的快捷方式来检索这些信息</li>\n</ul>\n<p><strong>OLTP</strong></p>\n<ul>\n<li>On-line Transaction Processing（在线事务处理）</li>\n<li>读取和更新数据库中的单个实体的小量数据</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/OLTP.png\" alt=\"OLTP\"></p>\n<p><strong>OLAP</strong></p>\n<ul>\n<li>On-line Analytical Processing (在线分析处理)</li>\n<li>读取跨越多个实体的大量数据的复杂查询</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/OLAP.png\" alt=\"OLAP\"></p>\n<p><strong>数据存储模型</strong></p>\n<ul>\n<li>为了使OLTP或者OLAP性能更好，DBMS用不同的方式存储元组</li>\n</ul>\n<p><strong>N-ARY STORAGE MODEL (NSM)</strong></p>\n<ul>\n<li>DBMS在一个页面中连续的存储单个元组，每个元组存储了所有的属性</li>\n<li>适用于OLTP的工作负载，尽在单个实体上操作，大量的插入工作负载</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/NSM-1.png\" alt=\"NSM-1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/NSM-2.png\" alt=\"NSM-2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/NSM-3.png\" alt=\"NSM-3\"></p>\n<ul>\n<li>NSM优点：快速插入，更新，删除元组</li>\n<li>NSM缺点：不适合表的部分属性扫描</li>\n</ul>\n<p><strong>DECOMPOSITION STORAGE MODEL (DSM)</strong></p>\n<ul>\n<li>DBMS在页中相邻的所有元组中存储单个属性的值</li>\n<li>比较出名的是“列族存储”</li>\n<li>适用于只读的OLAP查询工作，比如scan某个属性的所有值</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/DSM.png\" alt=\"DSM\"></p>\n<ul>\n<li>DSM优点：减少浪费的I/O请求量，因为DBMS只读区所需要的数据；更好的处理查询任务和数据压缩。</li>\n<li>DSM缺点：单个元组的查询、插入、更新和删除速度慢，因为元组属性被分散在不同的页面中。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>磁盘式数据库存储架构</strong></p>\n<ul>\n<li>DBMS假设数据库主要存储在非易失性设备上</li>\n<li>DBMS的组建管理数据在非易失性存储和易失性存储之间的数据移动</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/oriented1.png\" alt=\"disk-oriented1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/oriented2.png\" alt=\"disk-oriented2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/oriented3.png\" alt=\"disk-oriented3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/oriented4.png\" alt=\"disk-oriented4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/oriented5.png\" alt=\"disk-oriented5\"></p>\n<p><strong>元组存储</strong></p>\n<ul>\n<li>元组本质上是一个字节序列，DBMS的工作就是解释这些字节属性类型和值</li>\n<li>DBMS的catalogs包含了系统用来描述系统表的信息，以及描述元组的布局</li>\n</ul>\n<p><strong>数据表示</strong></p>\n<ul>\n<li>INTEGER/BIGINT/SMALLINT/TINYINT，C/C++表示</li>\n<li>FLOAT/REAL vs NUMERIC/DECIMAL，IEEE-754 标准，定点小数</li>\n<li>VARCHAR/VARBINARY/TEXT/BLOB，头部以串长度开头，接着是具体的数据类型</li>\n<li>TIME/DATE/TIMESTAMP，32/64位整数 Unix时间格式</li>\n</ul>\n<p><strong>可变精度的数字</strong></p>\n<ul>\n<li>不精确，可变精度的数据类型使用原声的C/C++类型</li>\n<li>按照IEEE-754的规定直接存储</li>\n<li>通常比任意精度的速度要快，例如：FLOAT, REAL/DOUBLE</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/var.png\" alt=\"var\"></p>\n<p><strong>固定精度的数字</strong></p>\n<ul>\n<li>具有任意精度和规模的数据类型，当误差不可接受时使用，如NUMERIC,DECIMAL</li>\n<li>通常存储在精确的可变长度二进制文件中并附加元数据表示</li>\n</ul>\n<p><strong>超大的值</strong></p>\n<ul>\n<li>大多数DBMS不允许元组超过单个页面大小</li>\n<li>存储大于一个页面的值，DBMS使用单独的溢出存储页(overflow page)存储<ul>\n<li>Postgres：TOAST (&gt; 2KB)</li>\n<li>MySQL：Overflow (&gt; 1/2 size of page)</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/lager_v.png\" alt=\"lager_v\"></p>\n<p><strong>外部值存储（External value storage）</strong></p>\n<ul>\n<li>一些系统允许你在一个外部文件中存储一个很大的值</li>\n<li>作为BLOB类型处理<ul>\n<li>Oracle：BFILE </li>\n<li>Microsoft：FILESTREAM</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/external-f.png\" alt=\"external-f\"></p>\n<ul>\n<li>DBMS无法操作外部文件的内容<ul>\n<li>无持久化保护</li>\n<li>没有事务保护</li>\n</ul>\n</li>\n</ul>\n<p><strong>系统目录 (System catalogs)</strong></p>\n<ul>\n<li>一个数据库的元数据是存储在其数据库内部的catalogs<ul>\n<li>Tables，columns，indexes，views</li>\n<li>Users，permissions</li>\n<li>Internal statistics（内部统计)</li>\n</ul>\n</li>\n<li>几乎每个DBMS都存储其数据库的目录</li>\n<li>你可以查数据库内部的information_schema来获取数据库信息</li>\n<li>ANSI的标准提供了一系列的视图包括表，视图，列，过程</li>\n<li>DBMS也有非标准的快捷方式来检索这些信息</li>\n</ul>\n<p><strong>OLTP</strong></p>\n<ul>\n<li>On-line Transaction Processing（在线事务处理）</li>\n<li>读取和更新数据库中的单个实体的小量数据</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/OLTP.png\" alt=\"OLTP\"></p>\n<p><strong>OLAP</strong></p>\n<ul>\n<li>On-line Analytical Processing (在线分析处理)</li>\n<li>读取跨越多个实体的大量数据的复杂查询</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/OLAP.png\" alt=\"OLAP\"></p>\n<p><strong>数据存储模型</strong></p>\n<ul>\n<li>为了使OLTP或者OLAP性能更好，DBMS用不同的方式存储元组</li>\n</ul>\n<p><strong>N-ARY STORAGE MODEL (NSM)</strong></p>\n<ul>\n<li>DBMS在一个页面中连续的存储单个元组，每个元组存储了所有的属性</li>\n<li>适用于OLTP的工作负载，尽在单个实体上操作，大量的插入工作负载</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/NSM-1.png\" alt=\"NSM-1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/NSM-2.png\" alt=\"NSM-2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/NSM-3.png\" alt=\"NSM-3\"></p>\n<ul>\n<li>NSM优点：快速插入，更新，删除元组</li>\n<li>NSM缺点：不适合表的部分属性扫描</li>\n</ul>\n<p><strong>DECOMPOSITION STORAGE MODEL (DSM)</strong></p>\n<ul>\n<li>DBMS在页中相邻的所有元组中存储单个属性的值</li>\n<li>比较出名的是“列族存储”</li>\n<li>适用于只读的OLAP查询工作，比如scan某个属性的所有值</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-04-NOTES/DSM.png\" alt=\"DSM\"></p>\n<ul>\n<li>DSM优点：减少浪费的I/O请求量，因为DBMS只读区所需要的数据；更好的处理查询任务和数据压缩。</li>\n<li>DSM缺点：单个元组的查询、插入、更新和删除速度慢，因为元组属性被分散在不同的页面中。</li>\n</ul>\n"},{"title":"CMU-DBMS-COURSE-07-NOTES","date":"2019-04-07T07:19:32.000Z","_content":"\n**表索引**\n\n- 表索引时表列子集的副本，这些列是使用这些列的字集进行组织排序以达到高效访问的目的。\n\n- DBMS确保表和索引的内容在逻辑上同步。\n- DBMS的工作是找出执行每个查询所使用的最佳索引。\n- 对于每个数据创建的索引数量有一个权衡。\n  - 存储开销\n  - 维护开销\n\n**B树家族**\n\n- 有一种特殊的数据结构称为B树，但人们也使用这个术语来泛指一类数据结构\n  - B-Tree\n  - B+Tree\n  - B link-Tree\n  - B*Tree\n\n**B+树**\n\n- B+树是一种自平衡的数据结构，它保持数据的排序，并允许在O (log n)中进行搜索、顺序访问、插入和删除\n- 而叉搜索树的推广，即一个节点可以有两个以上的子节点\n- 对读取和写入大量数据的系统进行了优化\n\n**B+树属性**\n\n- 一个B+树是一个M-way，它具有以下属性\n  - 它是完全平衡的（即每个叶节点在同一深度）\n  - 除了root节点外的任何内部节点，至少半满 (M/2 - 1 <= #keys <= M-1)\n  - 具有k个键的每个内部子节点都有 k+1个非空子节点\n\n![b-plus-tree1](CMU-DBMS-COURSE-07-NOTES/b-plus-tree1.png)\n\n![b-plus-tree2](CMU-DBMS-COURSE-07-NOTES/b-plus-tree2.png)\n\n- B+树中每个节点都包含一个键/值对数组\n\n- 键将始终是在其上构建索引的一列或多列\n- 这些值将根据节点属于内部节点还是叶节点而有所不同\n- 这些数组通常按照键排序保存\n\n**叶节点的值**\n\n- 一：记录ID，指向索引项所对应的元组位置的指针\n- 二：元组数据，元组的实际内容存储在叶节点中；二级索引必须将记录ID存储为其值\n\n![b-plus-tree-leaf-nodes1](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes1.png)\n\n![b-plus-tree-leaf-nodes2](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes2.png)\n\n![b-plus-tree-leaf-nodes3](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes3.png)\n\n![b-plus-tree-leaf-nodes4](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes4.png)\n\n**B树和B+树**\n\n- 1972年原始的B树中的所有节点中存储了key和value对\n- 更节省空间，因为每个键在树中只出现一次\n- B+树只在叶节点中存储值。内部节点只指导搜索过程\n\n**B+树插入**\n\n- 找到正确的叶L\n- 以顺序的方式将数据项插入L中\n- 如果 L 有足够的空间，操作完成\n- Else : 必须将L切分成 L 和一个新的节点 L2\n- 均匀的分配entry，复制中间键\n- 将指向L2的索引项插入L的父级节点中\n- 要拆分内部节点，请均匀地重新分布条目，但向上推中间键\n\n**B+树的可视化**\n\n- https://cmudb.io/btree\n\n**B+树的删除**\n\n- 从根开始，找到条目所属的叶L\n- 删除entry\n- 如果 L 至少半满，操作完成\n- 如果L只有M/2 - 1，\n  - 尝试重新分布，从兄弟节点借用空间\n  - 如果重新分发失败，合并L和兄弟节点\n- 如果发生合并，必须从L的父节点删除条目（指向L或同级节点）\n\n**实际中的B+树**\n\n- 典型的填充系数：67%\n- 平均扇出：2 * 100 * 0.67 = 134\n- 典型的容量值：\n  - 高4:1334 = 312,900,721个 元素\n  - 高3:1333 = 2,406,104个 元素\n\n- 每级的页数\n  - Level 1 = 1 page = 8 KB\n  - Level 2 = 134 pages = 1 MB\n  - Level 3 = 17,956 pages = 140 MB\n\n**聚集索引**\n\n- 表按主键指定的排序顺序存储\n- 可以是堆或者索引组织存储\n\n- 一些DBMS总是使用聚集索引\n- 如果一个表不包含一个主键，DBMS会自动的生成一个隐藏的row id主键\n\n**选择条件**\n\n- 如果查询提供搜索键的任何属性，DBMS可以使用B+树索引\n- 例如：<a, b, c>上的索引\n  - 支持搜索：（a = 5 AND b = 3）\n  - 支持：(b = 3)\n- 对于哈希索引，搜索键中必须包含所有属性\n\n![b-plus-tree-search1](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search1.png)\n\n![b-plus-tree-search2](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search2.png)\n\n![b-plus-tree-search3](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search3.png)\n\n**B+树设计的选择**\n\n- 节点大小\n- 合并阈值\n- 可变长度的键\n- 非唯一的索引\n- 节点内搜索\n\n**节点的大小**\n\n- 磁盘越慢，B+树的最佳节点大小越大\n  - HDD ～1MB\n  - SSD： ～10KB\n  - In-Memory：~512B\n- 根据workload的不同，最佳大小也会有所不同\n\n**合并阈值**\n\n- 一些DBMS不总是合并处于半满状态的节点\n- 推迟合并操作可能会减少重组的数量\n- 最好让下溢存在，然后定期重建整个树\n\n**可变长度的key**\n\n- 方法一、指针\n  - 以指针的方式存储keys指向元组属性\n- 方法二、可变长度的节点\n  - B+树中的每个节点大小可以变化\n  - 需要谨慎的内存管理\n- 方法三、Key Map\n  - 在节点内嵌入映射到键+值列表的指针数组\n\n**非唯一索引**\n\n- 方法一：复制键\n  - 使用相同的叶节点布局，但是多次存储重复的键\n\n![duplicate-keys](CMU-DBMS-COURSE-07-NOTES/duplicate-keys.png)\n\n- 方法二：值列表\n  - 只存储每个键一次，并维护唯一值的链接列表\n\n![value-list](CMU-DBMS-COURSE-07-NOTES/value-list.png)\n\n**节点内部搜索**\n\n- 方法一：线性搜索，从头到尾扫描键\n- 方法二：二分搜索，跳到中间key，根据比较向左/向右寻找\n- 方法三：基于已知key的分布估计所需key的近似位置\n\n![search1](CMU-DBMS-COURSE-07-NOTES/search1.png)\n\n![search2](CMU-DBMS-COURSE-07-NOTES/search2.png)\n\n![search3](CMU-DBMS-COURSE-07-NOTES/search3.png)\n\n![search4](CMU-DBMS-COURSE-07-NOTES/search4.png)\n\n![search5](CMU-DBMS-COURSE-07-NOTES/search5.png)\n\n![search6](CMU-DBMS-COURSE-07-NOTES/search6.png)\n\n![search7](CMU-DBMS-COURSE-07-NOTES/search7.png)\n\n**优化操作**\n\n- 前缀压缩\n- 后缀截断\n- 批量插入\n- 指针旋转\n\n**前缀压缩**\n\n- 同一叶节点的已排序键可能具有相同的前缀\n- 不是每次都存储整个key，而是提取公共前缀并只存储每个key的唯一后缀\n\n![prefix-compression1](CMU-DBMS-COURSE-07-NOTES/prefix-compression1.png)\n\n![prefix-compression2](CMU-DBMS-COURSE-07-NOTES/prefix-compression2.png)\n\n**后缀截断**\n\n- 内部节点中的键仅用于“引导通信”，我们并不需要存储整个key的值\n- 存储将探针正确路由到索引所需要的最小前缀\n\n![suffix-trun1](CMU-DBMS-COURSE-07-NOTES/suffix-trun1.png)\n\n![suffix-trun2](CMU-DBMS-COURSE-07-NOTES/suffix-trun2.png)\n\n**批量插入**\n\n- 构建B+树的最快/最好的方法是对键进行排序，然后自下而上构建索引\n\n![bulk-insert1](CMU-DBMS-COURSE-07-NOTES/bulk-insert1.png)\n\n![bulk-insert2](CMU-DBMS-COURSE-07-NOTES/bulk-insert2.png)\n\n![bulk-insert3](CMU-DBMS-COURSE-07-NOTES/bulk-insert3.png)\n\n**指针旋转**\n\n- 节点使用页面ID引用索引中的其他节点。在遍历期间，DBMS必须从页表中获取内存位置。\n- 如果页面固定在缓冲池中，那么我们可以存储原始指针而不是页面ID，从而消除了从页面表中获取地址的需要。\n\n![pointer-swizzling1](CMU-DBMS-COURSE-07-NOTES/pointer-swizzling1.png)\n\n![pointer-swizzling2](CMU-DBMS-COURSE-07-NOTES/pointer-swizzling2.png)\n\n![pointer-swizzling3](CMU-DBMS-COURSE-07-NOTES/pointer-swizzling3.png)\n\n![pointer-swizzling4](CMU-DBMS-COURSE-07-NOTES/pointer-swizzling4.png)\n\n![pointer-swizzling5](CMU-DBMS-COURSE-07-NOTES/pointer-swizzling5.png)\n\n","source":"_posts/CMU-DBMS-COURSE-07-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-07-NOTES\ndate: 2019-04-07 15:19:32\ntags:\n---\n\n**表索引**\n\n- 表索引时表列子集的副本，这些列是使用这些列的字集进行组织排序以达到高效访问的目的。\n\n- DBMS确保表和索引的内容在逻辑上同步。\n- DBMS的工作是找出执行每个查询所使用的最佳索引。\n- 对于每个数据创建的索引数量有一个权衡。\n  - 存储开销\n  - 维护开销\n\n**B树家族**\n\n- 有一种特殊的数据结构称为B树，但人们也使用这个术语来泛指一类数据结构\n  - B-Tree\n  - B+Tree\n  - B link-Tree\n  - B*Tree\n\n**B+树**\n\n- B+树是一种自平衡的数据结构，它保持数据的排序，并允许在O (log n)中进行搜索、顺序访问、插入和删除\n- 而叉搜索树的推广，即一个节点可以有两个以上的子节点\n- 对读取和写入大量数据的系统进行了优化\n\n**B+树属性**\n\n- 一个B+树是一个M-way，它具有以下属性\n  - 它是完全平衡的（即每个叶节点在同一深度）\n  - 除了root节点外的任何内部节点，至少半满 (M/2 - 1 <= #keys <= M-1)\n  - 具有k个键的每个内部子节点都有 k+1个非空子节点\n\n![b-plus-tree1](CMU-DBMS-COURSE-07-NOTES/b-plus-tree1.png)\n\n![b-plus-tree2](CMU-DBMS-COURSE-07-NOTES/b-plus-tree2.png)\n\n- B+树中每个节点都包含一个键/值对数组\n\n- 键将始终是在其上构建索引的一列或多列\n- 这些值将根据节点属于内部节点还是叶节点而有所不同\n- 这些数组通常按照键排序保存\n\n**叶节点的值**\n\n- 一：记录ID，指向索引项所对应的元组位置的指针\n- 二：元组数据，元组的实际内容存储在叶节点中；二级索引必须将记录ID存储为其值\n\n![b-plus-tree-leaf-nodes1](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes1.png)\n\n![b-plus-tree-leaf-nodes2](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes2.png)\n\n![b-plus-tree-leaf-nodes3](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes3.png)\n\n![b-plus-tree-leaf-nodes4](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes4.png)\n\n**B树和B+树**\n\n- 1972年原始的B树中的所有节点中存储了key和value对\n- 更节省空间，因为每个键在树中只出现一次\n- B+树只在叶节点中存储值。内部节点只指导搜索过程\n\n**B+树插入**\n\n- 找到正确的叶L\n- 以顺序的方式将数据项插入L中\n- 如果 L 有足够的空间，操作完成\n- Else : 必须将L切分成 L 和一个新的节点 L2\n- 均匀的分配entry，复制中间键\n- 将指向L2的索引项插入L的父级节点中\n- 要拆分内部节点，请均匀地重新分布条目，但向上推中间键\n\n**B+树的可视化**\n\n- https://cmudb.io/btree\n\n**B+树的删除**\n\n- 从根开始，找到条目所属的叶L\n- 删除entry\n- 如果 L 至少半满，操作完成\n- 如果L只有M/2 - 1，\n  - 尝试重新分布，从兄弟节点借用空间\n  - 如果重新分发失败，合并L和兄弟节点\n- 如果发生合并，必须从L的父节点删除条目（指向L或同级节点）\n\n**实际中的B+树**\n\n- 典型的填充系数：67%\n- 平均扇出：2 * 100 * 0.67 = 134\n- 典型的容量值：\n  - 高4:1334 = 312,900,721个 元素\n  - 高3:1333 = 2,406,104个 元素\n\n- 每级的页数\n  - Level 1 = 1 page = 8 KB\n  - Level 2 = 134 pages = 1 MB\n  - Level 3 = 17,956 pages = 140 MB\n\n**聚集索引**\n\n- 表按主键指定的排序顺序存储\n- 可以是堆或者索引组织存储\n\n- 一些DBMS总是使用聚集索引\n- 如果一个表不包含一个主键，DBMS会自动的生成一个隐藏的row id主键\n\n**选择条件**\n\n- 如果查询提供搜索键的任何属性，DBMS可以使用B+树索引\n- 例如：<a, b, c>上的索引\n  - 支持搜索：（a = 5 AND b = 3）\n  - 支持：(b = 3)\n- 对于哈希索引，搜索键中必须包含所有属性\n\n![b-plus-tree-search1](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search1.png)\n\n![b-plus-tree-search2](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search2.png)\n\n![b-plus-tree-search3](CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search3.png)\n\n**B+树设计的选择**\n\n- 节点大小\n- 合并阈值\n- 可变长度的键\n- 非唯一的索引\n- 节点内搜索\n\n**节点的大小**\n\n- 磁盘越慢，B+树的最佳节点大小越大\n  - HDD ～1MB\n  - SSD： ～10KB\n  - In-Memory：~512B\n- 根据workload的不同，最佳大小也会有所不同\n\n**合并阈值**\n\n- 一些DBMS不总是合并处于半满状态的节点\n- 推迟合并操作可能会减少重组的数量\n- 最好让下溢存在，然后定期重建整个树\n\n**可变长度的key**\n\n- 方法一、指针\n  - 以指针的方式存储keys指向元组属性\n- 方法二、可变长度的节点\n  - B+树中的每个节点大小可以变化\n  - 需要谨慎的内存管理\n- 方法三、Key Map\n  - 在节点内嵌入映射到键+值列表的指针数组\n\n**非唯一索引**\n\n- 方法一：复制键\n  - 使用相同的叶节点布局，但是多次存储重复的键\n\n![duplicate-keys](CMU-DBMS-COURSE-07-NOTES/duplicate-keys.png)\n\n- 方法二：值列表\n  - 只存储每个键一次，并维护唯一值的链接列表\n\n![value-list](CMU-DBMS-COURSE-07-NOTES/value-list.png)\n\n**节点内部搜索**\n\n- 方法一：线性搜索，从头到尾扫描键\n- 方法二：二分搜索，跳到中间key，根据比较向左/向右寻找\n- 方法三：基于已知key的分布估计所需key的近似位置\n\n![search1](CMU-DBMS-COURSE-07-NOTES/search1.png)\n\n![search2](CMU-DBMS-COURSE-07-NOTES/search2.png)\n\n![search3](CMU-DBMS-COURSE-07-NOTES/search3.png)\n\n![search4](CMU-DBMS-COURSE-07-NOTES/search4.png)\n\n![search5](CMU-DBMS-COURSE-07-NOTES/search5.png)\n\n![search6](CMU-DBMS-COURSE-07-NOTES/search6.png)\n\n![search7](CMU-DBMS-COURSE-07-NOTES/search7.png)\n\n**优化操作**\n\n- 前缀压缩\n- 后缀截断\n- 批量插入\n- 指针旋转\n\n**前缀压缩**\n\n- 同一叶节点的已排序键可能具有相同的前缀\n- 不是每次都存储整个key，而是提取公共前缀并只存储每个key的唯一后缀\n\n![prefix-compression1](CMU-DBMS-COURSE-07-NOTES/prefix-compression1.png)\n\n![prefix-compression2](CMU-DBMS-COURSE-07-NOTES/prefix-compression2.png)\n\n**后缀截断**\n\n- 内部节点中的键仅用于“引导通信”，我们并不需要存储整个key的值\n- 存储将探针正确路由到索引所需要的最小前缀\n\n![suffix-trun1](CMU-DBMS-COURSE-07-NOTES/suffix-trun1.png)\n\n![suffix-trun2](CMU-DBMS-COURSE-07-NOTES/suffix-trun2.png)\n\n**批量插入**\n\n- 构建B+树的最快/最好的方法是对键进行排序，然后自下而上构建索引\n\n![bulk-insert1](CMU-DBMS-COURSE-07-NOTES/bulk-insert1.png)\n\n![bulk-insert2](CMU-DBMS-COURSE-07-NOTES/bulk-insert2.png)\n\n![bulk-insert3](CMU-DBMS-COURSE-07-NOTES/bulk-insert3.png)\n\n**指针旋转**\n\n- 节点使用页面ID引用索引中的其他节点。在遍历期间，DBMS必须从页表中获取内存位置。\n- 如果页面固定在缓冲池中，那么我们可以存储原始指针而不是页面ID，从而消除了从页面表中获取地址的需要。\n\n![pointer-swizzling1](CMU-DBMS-COURSE-07-NOTES/pointer-swizzling1.png)\n\n![pointer-swizzling2](CMU-DBMS-COURSE-07-NOTES/pointer-swizzling2.png)\n\n![pointer-swizzling3](CMU-DBMS-COURSE-07-NOTES/pointer-swizzling3.png)\n\n![pointer-swizzling4](CMU-DBMS-COURSE-07-NOTES/pointer-swizzling4.png)\n\n![pointer-swizzling5](CMU-DBMS-COURSE-07-NOTES/pointer-swizzling5.png)\n\n","slug":"CMU-DBMS-COURSE-07-NOTES","published":1,"updated":"2019-06-26T11:56:34.409Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvymf0008vkqpi7x09hv7","content":"<p><strong>表索引</strong></p>\n<ul>\n<li><p>表索引时表列子集的副本，这些列是使用这些列的字集进行组织排序以达到高效访问的目的。</p>\n</li>\n<li><p>DBMS确保表和索引的内容在逻辑上同步。</p>\n</li>\n<li>DBMS的工作是找出执行每个查询所使用的最佳索引。</li>\n<li>对于每个数据创建的索引数量有一个权衡。<ul>\n<li>存储开销</li>\n<li>维护开销</li>\n</ul>\n</li>\n</ul>\n<p><strong>B树家族</strong></p>\n<ul>\n<li>有一种特殊的数据结构称为B树，但人们也使用这个术语来泛指一类数据结构<ul>\n<li>B-Tree</li>\n<li>B+Tree</li>\n<li>B link-Tree</li>\n<li>B*Tree</li>\n</ul>\n</li>\n</ul>\n<p><strong>B+树</strong></p>\n<ul>\n<li>B+树是一种自平衡的数据结构，它保持数据的排序，并允许在O (log n)中进行搜索、顺序访问、插入和删除</li>\n<li>而叉搜索树的推广，即一个节点可以有两个以上的子节点</li>\n<li>对读取和写入大量数据的系统进行了优化</li>\n</ul>\n<p><strong>B+树属性</strong></p>\n<ul>\n<li>一个B+树是一个M-way，它具有以下属性<ul>\n<li>它是完全平衡的（即每个叶节点在同一深度）</li>\n<li>除了root节点外的任何内部节点，至少半满 (M/2 - 1 &lt;= #keys &lt;= M-1)</li>\n<li>具有k个键的每个内部子节点都有 k+1个非空子节点</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree1.png\" alt=\"b-plus-tree1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree2.png\" alt=\"b-plus-tree2\"></p>\n<ul>\n<li><p>B+树中每个节点都包含一个键/值对数组</p>\n</li>\n<li><p>键将始终是在其上构建索引的一列或多列</p>\n</li>\n<li>这些值将根据节点属于内部节点还是叶节点而有所不同</li>\n<li>这些数组通常按照键排序保存</li>\n</ul>\n<p><strong>叶节点的值</strong></p>\n<ul>\n<li>一：记录ID，指向索引项所对应的元组位置的指针</li>\n<li>二：元组数据，元组的实际内容存储在叶节点中；二级索引必须将记录ID存储为其值</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes1.png\" alt=\"b-plus-tree-leaf-nodes1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes2.png\" alt=\"b-plus-tree-leaf-nodes2\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes3.png\" alt=\"b-plus-tree-leaf-nodes3\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes4.png\" alt=\"b-plus-tree-leaf-nodes4\"></p>\n<p><strong>B树和B+树</strong></p>\n<ul>\n<li>1972年原始的B树中的所有节点中存储了key和value对</li>\n<li>更节省空间，因为每个键在树中只出现一次</li>\n<li>B+树只在叶节点中存储值。内部节点只指导搜索过程</li>\n</ul>\n<p><strong>B+树插入</strong></p>\n<ul>\n<li>找到正确的叶L</li>\n<li>以顺序的方式将数据项插入L中</li>\n<li>如果 L 有足够的空间，操作完成</li>\n<li>Else : 必须将L切分成 L 和一个新的节点 L2</li>\n<li>均匀的分配entry，复制中间键</li>\n<li>将指向L2的索引项插入L的父级节点中</li>\n<li>要拆分内部节点，请均匀地重新分布条目，但向上推中间键</li>\n</ul>\n<p><strong>B+树的可视化</strong></p>\n<ul>\n<li><a href=\"https://cmudb.io/btree\" target=\"_blank\" rel=\"noopener\">https://cmudb.io/btree</a></li>\n</ul>\n<p><strong>B+树的删除</strong></p>\n<ul>\n<li>从根开始，找到条目所属的叶L</li>\n<li>删除entry</li>\n<li>如果 L 至少半满，操作完成</li>\n<li>如果L只有M/2 - 1，<ul>\n<li>尝试重新分布，从兄弟节点借用空间</li>\n<li>如果重新分发失败，合并L和兄弟节点</li>\n</ul>\n</li>\n<li>如果发生合并，必须从L的父节点删除条目（指向L或同级节点）</li>\n</ul>\n<p><strong>实际中的B+树</strong></p>\n<ul>\n<li>典型的填充系数：67%</li>\n<li>平均扇出：2 <em> 100 </em> 0.67 = 134</li>\n<li><p>典型的容量值：</p>\n<ul>\n<li>高4:1334 = 312,900,721个 元素</li>\n<li>高3:1333 = 2,406,104个 元素</li>\n</ul>\n</li>\n<li><p>每级的页数</p>\n<ul>\n<li>Level 1 = 1 page = 8 KB</li>\n<li>Level 2 = 134 pages = 1 MB</li>\n<li>Level 3 = 17,956 pages = 140 MB</li>\n</ul>\n</li>\n</ul>\n<p><strong>聚集索引</strong></p>\n<ul>\n<li>表按主键指定的排序顺序存储</li>\n<li><p>可以是堆或者索引组织存储</p>\n</li>\n<li><p>一些DBMS总是使用聚集索引</p>\n</li>\n<li>如果一个表不包含一个主键，DBMS会自动的生成一个隐藏的row id主键</li>\n</ul>\n<p><strong>选择条件</strong></p>\n<ul>\n<li>如果查询提供搜索键的任何属性，DBMS可以使用B+树索引</li>\n<li>例如：&lt;a, b, c&gt;上的索引<ul>\n<li>支持搜索：（a = 5 AND b = 3）</li>\n<li>支持：(b = 3)</li>\n</ul>\n</li>\n<li>对于哈希索引，搜索键中必须包含所有属性</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search1.png\" alt=\"b-plus-tree-search1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search2.png\" alt=\"b-plus-tree-search2\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search3.png\" alt=\"b-plus-tree-search3\"></p>\n<p><strong>B+树设计的选择</strong></p>\n<ul>\n<li>节点大小</li>\n<li>合并阈值</li>\n<li>可变长度的键</li>\n<li>非唯一的索引</li>\n<li>节点内搜索</li>\n</ul>\n<p><strong>节点的大小</strong></p>\n<ul>\n<li>磁盘越慢，B+树的最佳节点大小越大<ul>\n<li>HDD ～1MB</li>\n<li>SSD： ～10KB</li>\n<li>In-Memory：~512B</li>\n</ul>\n</li>\n<li>根据workload的不同，最佳大小也会有所不同</li>\n</ul>\n<p><strong>合并阈值</strong></p>\n<ul>\n<li>一些DBMS不总是合并处于半满状态的节点</li>\n<li>推迟合并操作可能会减少重组的数量</li>\n<li>最好让下溢存在，然后定期重建整个树</li>\n</ul>\n<p><strong>可变长度的key</strong></p>\n<ul>\n<li>方法一、指针<ul>\n<li>以指针的方式存储keys指向元组属性</li>\n</ul>\n</li>\n<li>方法二、可变长度的节点<ul>\n<li>B+树中的每个节点大小可以变化</li>\n<li>需要谨慎的内存管理</li>\n</ul>\n</li>\n<li>方法三、Key Map<ul>\n<li>在节点内嵌入映射到键+值列表的指针数组</li>\n</ul>\n</li>\n</ul>\n<p><strong>非唯一索引</strong></p>\n<ul>\n<li>方法一：复制键<ul>\n<li>使用相同的叶节点布局，但是多次存储重复的键</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/duplicate-keys.png\" alt=\"duplicate-keys\"></p>\n<ul>\n<li>方法二：值列表<ul>\n<li>只存储每个键一次，并维护唯一值的链接列表</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/value-list.png\" alt=\"value-list\"></p>\n<p><strong>节点内部搜索</strong></p>\n<ul>\n<li>方法一：线性搜索，从头到尾扫描键</li>\n<li>方法二：二分搜索，跳到中间key，根据比较向左/向右寻找</li>\n<li>方法三：基于已知key的分布估计所需key的近似位置</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search1.png\" alt=\"search1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search2.png\" alt=\"search2\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search3.png\" alt=\"search3\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search4.png\" alt=\"search4\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search5.png\" alt=\"search5\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search6.png\" alt=\"search6\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search7.png\" alt=\"search7\"></p>\n<p><strong>优化操作</strong></p>\n<ul>\n<li>前缀压缩</li>\n<li>后缀截断</li>\n<li>批量插入</li>\n<li>指针旋转</li>\n</ul>\n<p><strong>前缀压缩</strong></p>\n<ul>\n<li>同一叶节点的已排序键可能具有相同的前缀</li>\n<li>不是每次都存储整个key，而是提取公共前缀并只存储每个key的唯一后缀</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/prefix-compression1.png\" alt=\"prefix-compression1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/prefix-compression2.png\" alt=\"prefix-compression2\"></p>\n<p><strong>后缀截断</strong></p>\n<ul>\n<li>内部节点中的键仅用于“引导通信”，我们并不需要存储整个key的值</li>\n<li>存储将探针正确路由到索引所需要的最小前缀</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/suffix-trun1.png\" alt=\"suffix-trun1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/suffix-trun2.png\" alt=\"suffix-trun2\"></p>\n<p><strong>批量插入</strong></p>\n<ul>\n<li>构建B+树的最快/最好的方法是对键进行排序，然后自下而上构建索引</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/bulk-insert1.png\" alt=\"bulk-insert1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/bulk-insert2.png\" alt=\"bulk-insert2\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/bulk-insert3.png\" alt=\"bulk-insert3\"></p>\n<p><strong>指针旋转</strong></p>\n<ul>\n<li>节点使用页面ID引用索引中的其他节点。在遍历期间，DBMS必须从页表中获取内存位置。</li>\n<li>如果页面固定在缓冲池中，那么我们可以存储原始指针而不是页面ID，从而消除了从页面表中获取地址的需要。</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling1.png\" alt=\"pointer-swizzling1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling2.png\" alt=\"pointer-swizzling2\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling3.png\" alt=\"pointer-swizzling3\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling4.png\" alt=\"pointer-swizzling4\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling5.png\" alt=\"pointer-swizzling5\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>表索引</strong></p>\n<ul>\n<li><p>表索引时表列子集的副本，这些列是使用这些列的字集进行组织排序以达到高效访问的目的。</p>\n</li>\n<li><p>DBMS确保表和索引的内容在逻辑上同步。</p>\n</li>\n<li>DBMS的工作是找出执行每个查询所使用的最佳索引。</li>\n<li>对于每个数据创建的索引数量有一个权衡。<ul>\n<li>存储开销</li>\n<li>维护开销</li>\n</ul>\n</li>\n</ul>\n<p><strong>B树家族</strong></p>\n<ul>\n<li>有一种特殊的数据结构称为B树，但人们也使用这个术语来泛指一类数据结构<ul>\n<li>B-Tree</li>\n<li>B+Tree</li>\n<li>B link-Tree</li>\n<li>B*Tree</li>\n</ul>\n</li>\n</ul>\n<p><strong>B+树</strong></p>\n<ul>\n<li>B+树是一种自平衡的数据结构，它保持数据的排序，并允许在O (log n)中进行搜索、顺序访问、插入和删除</li>\n<li>而叉搜索树的推广，即一个节点可以有两个以上的子节点</li>\n<li>对读取和写入大量数据的系统进行了优化</li>\n</ul>\n<p><strong>B+树属性</strong></p>\n<ul>\n<li>一个B+树是一个M-way，它具有以下属性<ul>\n<li>它是完全平衡的（即每个叶节点在同一深度）</li>\n<li>除了root节点外的任何内部节点，至少半满 (M/2 - 1 &lt;= #keys &lt;= M-1)</li>\n<li>具有k个键的每个内部子节点都有 k+1个非空子节点</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree1.png\" alt=\"b-plus-tree1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree2.png\" alt=\"b-plus-tree2\"></p>\n<ul>\n<li><p>B+树中每个节点都包含一个键/值对数组</p>\n</li>\n<li><p>键将始终是在其上构建索引的一列或多列</p>\n</li>\n<li>这些值将根据节点属于内部节点还是叶节点而有所不同</li>\n<li>这些数组通常按照键排序保存</li>\n</ul>\n<p><strong>叶节点的值</strong></p>\n<ul>\n<li>一：记录ID，指向索引项所对应的元组位置的指针</li>\n<li>二：元组数据，元组的实际内容存储在叶节点中；二级索引必须将记录ID存储为其值</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes1.png\" alt=\"b-plus-tree-leaf-nodes1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes2.png\" alt=\"b-plus-tree-leaf-nodes2\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes3.png\" alt=\"b-plus-tree-leaf-nodes3\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes4.png\" alt=\"b-plus-tree-leaf-nodes4\"></p>\n<p><strong>B树和B+树</strong></p>\n<ul>\n<li>1972年原始的B树中的所有节点中存储了key和value对</li>\n<li>更节省空间，因为每个键在树中只出现一次</li>\n<li>B+树只在叶节点中存储值。内部节点只指导搜索过程</li>\n</ul>\n<p><strong>B+树插入</strong></p>\n<ul>\n<li>找到正确的叶L</li>\n<li>以顺序的方式将数据项插入L中</li>\n<li>如果 L 有足够的空间，操作完成</li>\n<li>Else : 必须将L切分成 L 和一个新的节点 L2</li>\n<li>均匀的分配entry，复制中间键</li>\n<li>将指向L2的索引项插入L的父级节点中</li>\n<li>要拆分内部节点，请均匀地重新分布条目，但向上推中间键</li>\n</ul>\n<p><strong>B+树的可视化</strong></p>\n<ul>\n<li><a href=\"https://cmudb.io/btree\" target=\"_blank\" rel=\"noopener\">https://cmudb.io/btree</a></li>\n</ul>\n<p><strong>B+树的删除</strong></p>\n<ul>\n<li>从根开始，找到条目所属的叶L</li>\n<li>删除entry</li>\n<li>如果 L 至少半满，操作完成</li>\n<li>如果L只有M/2 - 1，<ul>\n<li>尝试重新分布，从兄弟节点借用空间</li>\n<li>如果重新分发失败，合并L和兄弟节点</li>\n</ul>\n</li>\n<li>如果发生合并，必须从L的父节点删除条目（指向L或同级节点）</li>\n</ul>\n<p><strong>实际中的B+树</strong></p>\n<ul>\n<li>典型的填充系数：67%</li>\n<li>平均扇出：2 <em> 100 </em> 0.67 = 134</li>\n<li><p>典型的容量值：</p>\n<ul>\n<li>高4:1334 = 312,900,721个 元素</li>\n<li>高3:1333 = 2,406,104个 元素</li>\n</ul>\n</li>\n<li><p>每级的页数</p>\n<ul>\n<li>Level 1 = 1 page = 8 KB</li>\n<li>Level 2 = 134 pages = 1 MB</li>\n<li>Level 3 = 17,956 pages = 140 MB</li>\n</ul>\n</li>\n</ul>\n<p><strong>聚集索引</strong></p>\n<ul>\n<li>表按主键指定的排序顺序存储</li>\n<li><p>可以是堆或者索引组织存储</p>\n</li>\n<li><p>一些DBMS总是使用聚集索引</p>\n</li>\n<li>如果一个表不包含一个主键，DBMS会自动的生成一个隐藏的row id主键</li>\n</ul>\n<p><strong>选择条件</strong></p>\n<ul>\n<li>如果查询提供搜索键的任何属性，DBMS可以使用B+树索引</li>\n<li>例如：&lt;a, b, c&gt;上的索引<ul>\n<li>支持搜索：（a = 5 AND b = 3）</li>\n<li>支持：(b = 3)</li>\n</ul>\n</li>\n<li>对于哈希索引，搜索键中必须包含所有属性</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search1.png\" alt=\"b-plus-tree-search1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search2.png\" alt=\"b-plus-tree-search2\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search3.png\" alt=\"b-plus-tree-search3\"></p>\n<p><strong>B+树设计的选择</strong></p>\n<ul>\n<li>节点大小</li>\n<li>合并阈值</li>\n<li>可变长度的键</li>\n<li>非唯一的索引</li>\n<li>节点内搜索</li>\n</ul>\n<p><strong>节点的大小</strong></p>\n<ul>\n<li>磁盘越慢，B+树的最佳节点大小越大<ul>\n<li>HDD ～1MB</li>\n<li>SSD： ～10KB</li>\n<li>In-Memory：~512B</li>\n</ul>\n</li>\n<li>根据workload的不同，最佳大小也会有所不同</li>\n</ul>\n<p><strong>合并阈值</strong></p>\n<ul>\n<li>一些DBMS不总是合并处于半满状态的节点</li>\n<li>推迟合并操作可能会减少重组的数量</li>\n<li>最好让下溢存在，然后定期重建整个树</li>\n</ul>\n<p><strong>可变长度的key</strong></p>\n<ul>\n<li>方法一、指针<ul>\n<li>以指针的方式存储keys指向元组属性</li>\n</ul>\n</li>\n<li>方法二、可变长度的节点<ul>\n<li>B+树中的每个节点大小可以变化</li>\n<li>需要谨慎的内存管理</li>\n</ul>\n</li>\n<li>方法三、Key Map<ul>\n<li>在节点内嵌入映射到键+值列表的指针数组</li>\n</ul>\n</li>\n</ul>\n<p><strong>非唯一索引</strong></p>\n<ul>\n<li>方法一：复制键<ul>\n<li>使用相同的叶节点布局，但是多次存储重复的键</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/duplicate-keys.png\" alt=\"duplicate-keys\"></p>\n<ul>\n<li>方法二：值列表<ul>\n<li>只存储每个键一次，并维护唯一值的链接列表</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/value-list.png\" alt=\"value-list\"></p>\n<p><strong>节点内部搜索</strong></p>\n<ul>\n<li>方法一：线性搜索，从头到尾扫描键</li>\n<li>方法二：二分搜索，跳到中间key，根据比较向左/向右寻找</li>\n<li>方法三：基于已知key的分布估计所需key的近似位置</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search1.png\" alt=\"search1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search2.png\" alt=\"search2\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search3.png\" alt=\"search3\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search4.png\" alt=\"search4\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search5.png\" alt=\"search5\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search6.png\" alt=\"search6\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/search7.png\" alt=\"search7\"></p>\n<p><strong>优化操作</strong></p>\n<ul>\n<li>前缀压缩</li>\n<li>后缀截断</li>\n<li>批量插入</li>\n<li>指针旋转</li>\n</ul>\n<p><strong>前缀压缩</strong></p>\n<ul>\n<li>同一叶节点的已排序键可能具有相同的前缀</li>\n<li>不是每次都存储整个key，而是提取公共前缀并只存储每个key的唯一后缀</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/prefix-compression1.png\" alt=\"prefix-compression1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/prefix-compression2.png\" alt=\"prefix-compression2\"></p>\n<p><strong>后缀截断</strong></p>\n<ul>\n<li>内部节点中的键仅用于“引导通信”，我们并不需要存储整个key的值</li>\n<li>存储将探针正确路由到索引所需要的最小前缀</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/suffix-trun1.png\" alt=\"suffix-trun1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/suffix-trun2.png\" alt=\"suffix-trun2\"></p>\n<p><strong>批量插入</strong></p>\n<ul>\n<li>构建B+树的最快/最好的方法是对键进行排序，然后自下而上构建索引</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/bulk-insert1.png\" alt=\"bulk-insert1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/bulk-insert2.png\" alt=\"bulk-insert2\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/bulk-insert3.png\" alt=\"bulk-insert3\"></p>\n<p><strong>指针旋转</strong></p>\n<ul>\n<li>节点使用页面ID引用索引中的其他节点。在遍历期间，DBMS必须从页表中获取内存位置。</li>\n<li>如果页面固定在缓冲池中，那么我们可以存储原始指针而不是页面ID，从而消除了从页面表中获取地址的需要。</li>\n</ul>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling1.png\" alt=\"pointer-swizzling1\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling2.png\" alt=\"pointer-swizzling2\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling3.png\" alt=\"pointer-swizzling3\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling4.png\" alt=\"pointer-swizzling4\"></p>\n<p><img src=\"/2019/04/07/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling5.png\" alt=\"pointer-swizzling5\"></p>\n"},{"title":"CMU-DBMS-COURSE-05-NOTES","date":"2019-04-06T09:24:31.000Z","_content":"\n**DBMS如何管理内存，以及处理内存与磁盘间的数据交换**\n\n- 空间控制：在磁盘哪里写入页面；目标是将经常使用的页面在磁盘上尽可能的靠近。\n- 时间控制：什么时候将页面读入内存；什么时候将它们写入磁盘？目标是减少从磁盘读取数据导致的超长耗时。\n\n**磁盘式数据库系统的架构**\n\n![DISK-ORIENTED](CMU-DBMS-COURSE-05-NOTES/DISK-ORIENTED.png)\n\n**缓冲池组织**\n\n- 缓冲池是以固定大小的页以数组的形式组织成的存储区域，一个数组元素叫做帧(frame)。\n- 当DBMS请求一个页面进入内存的时候，缓冲池 (Buffer Pool) 中会出现页面的精确拷贝。\n\n**缓冲池元数据**\n\n- 页表(Page Table)记录了当前在内存中的页面\n- 同时也包括了每个页面附加的元数据：是否脏页的标志；Pin（别针）/Reference Counter（引用计数器）\n\n![Buffer-pool-meta-data](CMU-DBMS-COURSE-05-NOTES/Buffer-pool-meta-data.png)\n\n- 用Pin来标识页面被访问了\n\n![Pin](CMU-DBMS-COURSE-05-NOTES/Pin.png)\n\n**读页面的时候Page Table加锁**\n\n![read-disk1](CMU-DBMS-COURSE-05-NOTES/read-disk1.png)\n\n![read-disk2](CMU-DBMS-COURSE-05-NOTES/read-disk2.png)\n\n![read-disk3](CMU-DBMS-COURSE-05-NOTES/read-disk3.png)\n\n**锁 vs 插销 (LOCKS LATCHES)**\n\n- 锁：保护数据库的逻辑内容不受其他事务的影响；保证事务的持久化；需要能够支持回改变化\n- 插销：保护DBMS的内部数据结构的关键部分不受其他的线程影响；支持操作持久化；不需要支持回滚变化，用mutex实现\n\n**Page table vs page directory （页表和页目录）**\n\n- 页目录是页 id 到页在文件位置的映射，所有的更改必须记录在磁盘上，以便DBMS在重新启动时查找。\n- 页表是从页 id 到缓冲池中页副本位置的映射，这是一种不需要存储在磁盘上的数据结构。\n\n**多个缓冲池**\n\n- 在整个系统中，DBMS不总是只有一个缓冲池：多个缓冲池实例；每个数据库的缓冲池；每个页面类型的缓冲池\n- 有助于减少闩(latch)锁争用，并该静位置\n\n**预取(PRE-PETCHING)**\n\n- DBMS可以基于一个查询计划做预读，顺序扫描，索引扫描\n\n![pre1](CMU-DBMS-COURSE-05-NOTES/pre1.png)\n\n![pre2](CMU-DBMS-COURSE-05-NOTES/pre2.png)\n\n![pre3](CMU-DBMS-COURSE-05-NOTES/pre3.png)\n\n![pre4](CMU-DBMS-COURSE-05-NOTES/pre4.png)\n\n![pre5](CMU-DBMS-COURSE-05-NOTES/pre5.png)\n\n![pre6](CMU-DBMS-COURSE-05-NOTES/pre6.png)\n\n**索引预读**\n\n![index-pre1](CMU-DBMS-COURSE-05-NOTES/index-pre1.png)\n\n![index-pre2](CMU-DBMS-COURSE-05-NOTES/index-pre2.png)\n\n![index-pre3](CMU-DBMS-COURSE-05-NOTES/index-pre3.png)\n\n![index-pre4](CMU-DBMS-COURSE-05-NOTES/index-pre4.png)\n\n**扫描共享 (SCAN SHARING)**\n\n- 多个查询任务能够重用从存储或操作计算中检索到的数据：这个结果缓存不同\n- 允许将多个查询附加到扫描表的单个光标上：查询任务不必完全相同；中间结果也可以共享\n- 如果一个查询启动了一个扫描，并且已经有一个执行了扫描，那么DBMS将附加到第二个查询的光标上：DBMS跟踪第二个查询和第一个查询的连接位置，以便在到达数据结构末尾时完成扫描\n- IBMDB2 和 MSSQL完全支持\n- Oracle仅支持相同查询的光标共享\n\n![scan1](CMU-DBMS-COURSE-05-NOTES/scan1.png)\n\n![scan2](CMU-DBMS-COURSE-05-NOTES/scan2.png)\n\n![scan3](CMU-DBMS-COURSE-05-NOTES/scan3.png)\n\n![scan4](CMU-DBMS-COURSE-05-NOTES/scan4.png)\n\n![scan5](CMU-DBMS-COURSE-05-NOTES/scan5.png)\n\n![scan6](CMU-DBMS-COURSE-05-NOTES/scan6.png)\n\n![scan7](CMU-DBMS-COURSE-05-NOTES/scan7.png)\n\n![scan8](CMU-DBMS-COURSE-05-NOTES/scan8.png)\n\n![scan9](CMU-DBMS-COURSE-05-NOTES/scan9.png)\n\n![scan10](CMU-DBMS-COURSE-05-NOTES/scan10.png)\n\n**缓冲池旁路(Buffer pool bypass)**\n\n- 顺序扫描运算符不会将提取的页存储在缓冲池中，以避免开销：内存是本地运行查询的；如果操作需要读取磁盘上连续的大量页序列，可以以很好的性能工作\n- 在Informix中叫做\"Light Scans\"\n\n**操作系统页面缓存**\n\n- 大多数磁盘操作都是通过操作系统API进行的。除非你告诉它不要这样做，否则操作系统维护自己的文件系统缓存。\n- 大多数DBMS使用直接I/O (O_direct) 绕过操作系统缓存：避免页的荣誉副本；不同的页面回收策略\n\n**缓冲区替换策略**\n\n- 当DBMS需要释放一个页帧(frame)来为新页面腾出空间时，它必须决定从缓冲池中退出哪个页面\n- 策略目标：正确性；准确度；速度；元数据开销\n\n**LRU（least recently used）**\n\n- 维护每个页面上次访问的时间戳\n- 当DBMS需要回收一个页面时，选择时间戳最早的页面\n- 保持页面的排序顺序，以减少还出时的搜索时间\n\n**时钟 CLOCK**\n\n- 接近LRU但不需要每页单独的时间戳：每个页面有一个引用位；当页面被访问的时候，设置成1\n- 用\"时钟指针(clock hand)\"在圆形缓冲区中组织页面：扫描时检查页位是否设置为1，如果是，设置成0。不是的话，换出\n\n![clock1](CMU-DBMS-COURSE-05-NOTES/clock1.png)\n\n![clock2](CMU-DBMS-COURSE-05-NOTES/clock2.png)\n\n![clock3](CMU-DBMS-COURSE-05-NOTES/clock3.png)\n\n![clock4](CMU-DBMS-COURSE-05-NOTES/clock4.png)\n\n![clock5](CMU-DBMS-COURSE-05-NOTES/clock5.png)\n\n![clock6](CMU-DBMS-COURSE-05-NOTES/clock6.png)\n\n![clock7](CMU-DBMS-COURSE-05-NOTES/clock7.png)\n\n![clock8](CMU-DBMS-COURSE-05-NOTES/clock8.png)\n\n- 存在的问题：LRU和时钟替换策略容易受到缓冲区连续溢出的影响\n- 查询执行顺序扫描，读取每一页\n- 这会用一次又一次的读取的页污染缓冲池\n- 这种情况下最近使用的页面实际上是最不需要的页面\n\n**顺序溢出(Sequential flooding)**\n\n![seq1](CMU-DBMS-COURSE-05-NOTES/seq1.png)\n\n![seq2](CMU-DBMS-COURSE-05-NOTES/seq2.png)\n\n![seq3](CMU-DBMS-COURSE-05-NOTES/seq3.png)\n\n![seq4](CMU-DBMS-COURSE-05-NOTES/seq4.png)\n\n![seq5](CMU-DBMS-COURSE-05-NOTES/seq5.png)\n\n![seq6](CMU-DBMS-COURSE-05-NOTES/seq6.png)\n\n**更好的策略：LRU-K**\n\n- 考虑最后k个引用的历史作为时间戳，并计算后续访问之间的时间间隔\n- 然后，DBMS使用此历史记录来估计下一次访问该页的时间\n\n**更好的策略：本地化**\n\n- DBMS根据 txn/查询 选择要换出的页面。这样可以最大限度地减少每个查询对缓冲池的污染\n- 跟踪查询访问的页面\n\n**更好的策略：优先级提示**\n\n- 当查询执行的时候，DBMS知道每个页面的具体内容\n- 它可以在buffer pool中提供提示，辨别一个页面是不是重要的\n\n![index-page1](CMU-DBMS-COURSE-05-NOTES/index-page1.png)\n\n![index-page2](CMU-DBMS-COURSE-05-NOTES/index-page2.png))\n\n![index-page3](CMU-DBMS-COURSE-05-NOTES/index-page3.png))\n\n**脏页**\n\n- 快速：如果缓冲池中的一个页面不是脏的，那么DBMS可以简单地 “删除” 它\n- 慢速：如果一个页面脏了，那么DBMS必须写回磁盘以确保其更改被持久化\n- 我们需要在快速回收与将来不再读取的脏写页面之间进行权衡\n\n**后台写入**\n\n- DBMS可以周期性的遍历页表并将脏页写入磁盘\n- 当安全地写入脏页时，DBMS可以收回改页或只是取消设置脏页标志\n- 需要注意的是，在写入脏页的日志记录之前，我们不会写入它们\n\n**其他的内存池**\n\n- 除了元组和索引之外，DBMS还需要内存\n- 这些其他的内存池可能并不总是由磁盘支持，这取决于具体实现\n  - Sorting + Join Buffers\n  - Query Caches\n  - Maintenance Buffers\n  - Log Buffers\n  - Dictionary Caches","source":"_posts/CMU-DBMS-COURSE-05-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-05-NOTES\ndate: 2019-04-06 17:24:31\ntags:\n---\n\n**DBMS如何管理内存，以及处理内存与磁盘间的数据交换**\n\n- 空间控制：在磁盘哪里写入页面；目标是将经常使用的页面在磁盘上尽可能的靠近。\n- 时间控制：什么时候将页面读入内存；什么时候将它们写入磁盘？目标是减少从磁盘读取数据导致的超长耗时。\n\n**磁盘式数据库系统的架构**\n\n![DISK-ORIENTED](CMU-DBMS-COURSE-05-NOTES/DISK-ORIENTED.png)\n\n**缓冲池组织**\n\n- 缓冲池是以固定大小的页以数组的形式组织成的存储区域，一个数组元素叫做帧(frame)。\n- 当DBMS请求一个页面进入内存的时候，缓冲池 (Buffer Pool) 中会出现页面的精确拷贝。\n\n**缓冲池元数据**\n\n- 页表(Page Table)记录了当前在内存中的页面\n- 同时也包括了每个页面附加的元数据：是否脏页的标志；Pin（别针）/Reference Counter（引用计数器）\n\n![Buffer-pool-meta-data](CMU-DBMS-COURSE-05-NOTES/Buffer-pool-meta-data.png)\n\n- 用Pin来标识页面被访问了\n\n![Pin](CMU-DBMS-COURSE-05-NOTES/Pin.png)\n\n**读页面的时候Page Table加锁**\n\n![read-disk1](CMU-DBMS-COURSE-05-NOTES/read-disk1.png)\n\n![read-disk2](CMU-DBMS-COURSE-05-NOTES/read-disk2.png)\n\n![read-disk3](CMU-DBMS-COURSE-05-NOTES/read-disk3.png)\n\n**锁 vs 插销 (LOCKS LATCHES)**\n\n- 锁：保护数据库的逻辑内容不受其他事务的影响；保证事务的持久化；需要能够支持回改变化\n- 插销：保护DBMS的内部数据结构的关键部分不受其他的线程影响；支持操作持久化；不需要支持回滚变化，用mutex实现\n\n**Page table vs page directory （页表和页目录）**\n\n- 页目录是页 id 到页在文件位置的映射，所有的更改必须记录在磁盘上，以便DBMS在重新启动时查找。\n- 页表是从页 id 到缓冲池中页副本位置的映射，这是一种不需要存储在磁盘上的数据结构。\n\n**多个缓冲池**\n\n- 在整个系统中，DBMS不总是只有一个缓冲池：多个缓冲池实例；每个数据库的缓冲池；每个页面类型的缓冲池\n- 有助于减少闩(latch)锁争用，并该静位置\n\n**预取(PRE-PETCHING)**\n\n- DBMS可以基于一个查询计划做预读，顺序扫描，索引扫描\n\n![pre1](CMU-DBMS-COURSE-05-NOTES/pre1.png)\n\n![pre2](CMU-DBMS-COURSE-05-NOTES/pre2.png)\n\n![pre3](CMU-DBMS-COURSE-05-NOTES/pre3.png)\n\n![pre4](CMU-DBMS-COURSE-05-NOTES/pre4.png)\n\n![pre5](CMU-DBMS-COURSE-05-NOTES/pre5.png)\n\n![pre6](CMU-DBMS-COURSE-05-NOTES/pre6.png)\n\n**索引预读**\n\n![index-pre1](CMU-DBMS-COURSE-05-NOTES/index-pre1.png)\n\n![index-pre2](CMU-DBMS-COURSE-05-NOTES/index-pre2.png)\n\n![index-pre3](CMU-DBMS-COURSE-05-NOTES/index-pre3.png)\n\n![index-pre4](CMU-DBMS-COURSE-05-NOTES/index-pre4.png)\n\n**扫描共享 (SCAN SHARING)**\n\n- 多个查询任务能够重用从存储或操作计算中检索到的数据：这个结果缓存不同\n- 允许将多个查询附加到扫描表的单个光标上：查询任务不必完全相同；中间结果也可以共享\n- 如果一个查询启动了一个扫描，并且已经有一个执行了扫描，那么DBMS将附加到第二个查询的光标上：DBMS跟踪第二个查询和第一个查询的连接位置，以便在到达数据结构末尾时完成扫描\n- IBMDB2 和 MSSQL完全支持\n- Oracle仅支持相同查询的光标共享\n\n![scan1](CMU-DBMS-COURSE-05-NOTES/scan1.png)\n\n![scan2](CMU-DBMS-COURSE-05-NOTES/scan2.png)\n\n![scan3](CMU-DBMS-COURSE-05-NOTES/scan3.png)\n\n![scan4](CMU-DBMS-COURSE-05-NOTES/scan4.png)\n\n![scan5](CMU-DBMS-COURSE-05-NOTES/scan5.png)\n\n![scan6](CMU-DBMS-COURSE-05-NOTES/scan6.png)\n\n![scan7](CMU-DBMS-COURSE-05-NOTES/scan7.png)\n\n![scan8](CMU-DBMS-COURSE-05-NOTES/scan8.png)\n\n![scan9](CMU-DBMS-COURSE-05-NOTES/scan9.png)\n\n![scan10](CMU-DBMS-COURSE-05-NOTES/scan10.png)\n\n**缓冲池旁路(Buffer pool bypass)**\n\n- 顺序扫描运算符不会将提取的页存储在缓冲池中，以避免开销：内存是本地运行查询的；如果操作需要读取磁盘上连续的大量页序列，可以以很好的性能工作\n- 在Informix中叫做\"Light Scans\"\n\n**操作系统页面缓存**\n\n- 大多数磁盘操作都是通过操作系统API进行的。除非你告诉它不要这样做，否则操作系统维护自己的文件系统缓存。\n- 大多数DBMS使用直接I/O (O_direct) 绕过操作系统缓存：避免页的荣誉副本；不同的页面回收策略\n\n**缓冲区替换策略**\n\n- 当DBMS需要释放一个页帧(frame)来为新页面腾出空间时，它必须决定从缓冲池中退出哪个页面\n- 策略目标：正确性；准确度；速度；元数据开销\n\n**LRU（least recently used）**\n\n- 维护每个页面上次访问的时间戳\n- 当DBMS需要回收一个页面时，选择时间戳最早的页面\n- 保持页面的排序顺序，以减少还出时的搜索时间\n\n**时钟 CLOCK**\n\n- 接近LRU但不需要每页单独的时间戳：每个页面有一个引用位；当页面被访问的时候，设置成1\n- 用\"时钟指针(clock hand)\"在圆形缓冲区中组织页面：扫描时检查页位是否设置为1，如果是，设置成0。不是的话，换出\n\n![clock1](CMU-DBMS-COURSE-05-NOTES/clock1.png)\n\n![clock2](CMU-DBMS-COURSE-05-NOTES/clock2.png)\n\n![clock3](CMU-DBMS-COURSE-05-NOTES/clock3.png)\n\n![clock4](CMU-DBMS-COURSE-05-NOTES/clock4.png)\n\n![clock5](CMU-DBMS-COURSE-05-NOTES/clock5.png)\n\n![clock6](CMU-DBMS-COURSE-05-NOTES/clock6.png)\n\n![clock7](CMU-DBMS-COURSE-05-NOTES/clock7.png)\n\n![clock8](CMU-DBMS-COURSE-05-NOTES/clock8.png)\n\n- 存在的问题：LRU和时钟替换策略容易受到缓冲区连续溢出的影响\n- 查询执行顺序扫描，读取每一页\n- 这会用一次又一次的读取的页污染缓冲池\n- 这种情况下最近使用的页面实际上是最不需要的页面\n\n**顺序溢出(Sequential flooding)**\n\n![seq1](CMU-DBMS-COURSE-05-NOTES/seq1.png)\n\n![seq2](CMU-DBMS-COURSE-05-NOTES/seq2.png)\n\n![seq3](CMU-DBMS-COURSE-05-NOTES/seq3.png)\n\n![seq4](CMU-DBMS-COURSE-05-NOTES/seq4.png)\n\n![seq5](CMU-DBMS-COURSE-05-NOTES/seq5.png)\n\n![seq6](CMU-DBMS-COURSE-05-NOTES/seq6.png)\n\n**更好的策略：LRU-K**\n\n- 考虑最后k个引用的历史作为时间戳，并计算后续访问之间的时间间隔\n- 然后，DBMS使用此历史记录来估计下一次访问该页的时间\n\n**更好的策略：本地化**\n\n- DBMS根据 txn/查询 选择要换出的页面。这样可以最大限度地减少每个查询对缓冲池的污染\n- 跟踪查询访问的页面\n\n**更好的策略：优先级提示**\n\n- 当查询执行的时候，DBMS知道每个页面的具体内容\n- 它可以在buffer pool中提供提示，辨别一个页面是不是重要的\n\n![index-page1](CMU-DBMS-COURSE-05-NOTES/index-page1.png)\n\n![index-page2](CMU-DBMS-COURSE-05-NOTES/index-page2.png))\n\n![index-page3](CMU-DBMS-COURSE-05-NOTES/index-page3.png))\n\n**脏页**\n\n- 快速：如果缓冲池中的一个页面不是脏的，那么DBMS可以简单地 “删除” 它\n- 慢速：如果一个页面脏了，那么DBMS必须写回磁盘以确保其更改被持久化\n- 我们需要在快速回收与将来不再读取的脏写页面之间进行权衡\n\n**后台写入**\n\n- DBMS可以周期性的遍历页表并将脏页写入磁盘\n- 当安全地写入脏页时，DBMS可以收回改页或只是取消设置脏页标志\n- 需要注意的是，在写入脏页的日志记录之前，我们不会写入它们\n\n**其他的内存池**\n\n- 除了元组和索引之外，DBMS还需要内存\n- 这些其他的内存池可能并不总是由磁盘支持，这取决于具体实现\n  - Sorting + Join Buffers\n  - Query Caches\n  - Maintenance Buffers\n  - Log Buffers\n  - Dictionary Caches","slug":"CMU-DBMS-COURSE-05-NOTES","published":1,"updated":"2019-06-26T11:56:34.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvymj0009vkqp8h8fc2pd","content":"<p><strong>DBMS如何管理内存，以及处理内存与磁盘间的数据交换</strong></p>\n<ul>\n<li>空间控制：在磁盘哪里写入页面；目标是将经常使用的页面在磁盘上尽可能的靠近。</li>\n<li>时间控制：什么时候将页面读入内存；什么时候将它们写入磁盘？目标是减少从磁盘读取数据导致的超长耗时。</li>\n</ul>\n<p><strong>磁盘式数据库系统的架构</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/DISK-ORIENTED.png\" alt=\"DISK-ORIENTED\"></p>\n<p><strong>缓冲池组织</strong></p>\n<ul>\n<li>缓冲池是以固定大小的页以数组的形式组织成的存储区域，一个数组元素叫做帧(frame)。</li>\n<li>当DBMS请求一个页面进入内存的时候，缓冲池 (Buffer Pool) 中会出现页面的精确拷贝。</li>\n</ul>\n<p><strong>缓冲池元数据</strong></p>\n<ul>\n<li>页表(Page Table)记录了当前在内存中的页面</li>\n<li>同时也包括了每个页面附加的元数据：是否脏页的标志；Pin（别针）/Reference Counter（引用计数器）</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/Buffer-pool-meta-data.png\" alt=\"Buffer-pool-meta-data\"></p>\n<ul>\n<li>用Pin来标识页面被访问了</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/Pin.png\" alt=\"Pin\"></p>\n<p><strong>读页面的时候Page Table加锁</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/read-disk1.png\" alt=\"read-disk1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/read-disk2.png\" alt=\"read-disk2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/read-disk3.png\" alt=\"read-disk3\"></p>\n<p><strong>锁 vs 插销 (LOCKS LATCHES)</strong></p>\n<ul>\n<li>锁：保护数据库的逻辑内容不受其他事务的影响；保证事务的持久化；需要能够支持回改变化</li>\n<li>插销：保护DBMS的内部数据结构的关键部分不受其他的线程影响；支持操作持久化；不需要支持回滚变化，用mutex实现</li>\n</ul>\n<p><strong>Page table vs page directory （页表和页目录）</strong></p>\n<ul>\n<li>页目录是页 id 到页在文件位置的映射，所有的更改必须记录在磁盘上，以便DBMS在重新启动时查找。</li>\n<li>页表是从页 id 到缓冲池中页副本位置的映射，这是一种不需要存储在磁盘上的数据结构。</li>\n</ul>\n<p><strong>多个缓冲池</strong></p>\n<ul>\n<li>在整个系统中，DBMS不总是只有一个缓冲池：多个缓冲池实例；每个数据库的缓冲池；每个页面类型的缓冲池</li>\n<li>有助于减少闩(latch)锁争用，并该静位置</li>\n</ul>\n<p><strong>预取(PRE-PETCHING)</strong></p>\n<ul>\n<li>DBMS可以基于一个查询计划做预读，顺序扫描，索引扫描</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre1.png\" alt=\"pre1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre2.png\" alt=\"pre2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre3.png\" alt=\"pre3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre4.png\" alt=\"pre4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre5.png\" alt=\"pre5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre6.png\" alt=\"pre6\"></p>\n<p><strong>索引预读</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-pre1.png\" alt=\"index-pre1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-pre2.png\" alt=\"index-pre2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-pre3.png\" alt=\"index-pre3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-pre4.png\" alt=\"index-pre4\"></p>\n<p><strong>扫描共享 (SCAN SHARING)</strong></p>\n<ul>\n<li>多个查询任务能够重用从存储或操作计算中检索到的数据：这个结果缓存不同</li>\n<li>允许将多个查询附加到扫描表的单个光标上：查询任务不必完全相同；中间结果也可以共享</li>\n<li>如果一个查询启动了一个扫描，并且已经有一个执行了扫描，那么DBMS将附加到第二个查询的光标上：DBMS跟踪第二个查询和第一个查询的连接位置，以便在到达数据结构末尾时完成扫描</li>\n<li>IBMDB2 和 MSSQL完全支持</li>\n<li>Oracle仅支持相同查询的光标共享</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan1.png\" alt=\"scan1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan2.png\" alt=\"scan2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan3.png\" alt=\"scan3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan4.png\" alt=\"scan4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan5.png\" alt=\"scan5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan6.png\" alt=\"scan6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan7.png\" alt=\"scan7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan8.png\" alt=\"scan8\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan9.png\" alt=\"scan9\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan10.png\" alt=\"scan10\"></p>\n<p><strong>缓冲池旁路(Buffer pool bypass)</strong></p>\n<ul>\n<li>顺序扫描运算符不会将提取的页存储在缓冲池中，以避免开销：内存是本地运行查询的；如果操作需要读取磁盘上连续的大量页序列，可以以很好的性能工作</li>\n<li>在Informix中叫做”Light Scans”</li>\n</ul>\n<p><strong>操作系统页面缓存</strong></p>\n<ul>\n<li>大多数磁盘操作都是通过操作系统API进行的。除非你告诉它不要这样做，否则操作系统维护自己的文件系统缓存。</li>\n<li>大多数DBMS使用直接I/O (O_direct) 绕过操作系统缓存：避免页的荣誉副本；不同的页面回收策略</li>\n</ul>\n<p><strong>缓冲区替换策略</strong></p>\n<ul>\n<li>当DBMS需要释放一个页帧(frame)来为新页面腾出空间时，它必须决定从缓冲池中退出哪个页面</li>\n<li>策略目标：正确性；准确度；速度；元数据开销</li>\n</ul>\n<p><strong>LRU（least recently used）</strong></p>\n<ul>\n<li>维护每个页面上次访问的时间戳</li>\n<li>当DBMS需要回收一个页面时，选择时间戳最早的页面</li>\n<li>保持页面的排序顺序，以减少还出时的搜索时间</li>\n</ul>\n<p><strong>时钟 CLOCK</strong></p>\n<ul>\n<li>接近LRU但不需要每页单独的时间戳：每个页面有一个引用位；当页面被访问的时候，设置成1</li>\n<li>用”时钟指针(clock hand)”在圆形缓冲区中组织页面：扫描时检查页位是否设置为1，如果是，设置成0。不是的话，换出</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock1.png\" alt=\"clock1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock2.png\" alt=\"clock2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock3.png\" alt=\"clock3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock4.png\" alt=\"clock4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock5.png\" alt=\"clock5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock6.png\" alt=\"clock6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock7.png\" alt=\"clock7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock8.png\" alt=\"clock8\"></p>\n<ul>\n<li>存在的问题：LRU和时钟替换策略容易受到缓冲区连续溢出的影响</li>\n<li>查询执行顺序扫描，读取每一页</li>\n<li>这会用一次又一次的读取的页污染缓冲池</li>\n<li>这种情况下最近使用的页面实际上是最不需要的页面</li>\n</ul>\n<p><strong>顺序溢出(Sequential flooding)</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq1.png\" alt=\"seq1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq2.png\" alt=\"seq2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq3.png\" alt=\"seq3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq4.png\" alt=\"seq4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq5.png\" alt=\"seq5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq6.png\" alt=\"seq6\"></p>\n<p><strong>更好的策略：LRU-K</strong></p>\n<ul>\n<li>考虑最后k个引用的历史作为时间戳，并计算后续访问之间的时间间隔</li>\n<li>然后，DBMS使用此历史记录来估计下一次访问该页的时间</li>\n</ul>\n<p><strong>更好的策略：本地化</strong></p>\n<ul>\n<li>DBMS根据 txn/查询 选择要换出的页面。这样可以最大限度地减少每个查询对缓冲池的污染</li>\n<li>跟踪查询访问的页面</li>\n</ul>\n<p><strong>更好的策略：优先级提示</strong></p>\n<ul>\n<li>当查询执行的时候，DBMS知道每个页面的具体内容</li>\n<li>它可以在buffer pool中提供提示，辨别一个页面是不是重要的</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-page1.png\" alt=\"index-page1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-page2.png\" alt=\"index-page2\">)</p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-page3.png\" alt=\"index-page3\">)</p>\n<p><strong>脏页</strong></p>\n<ul>\n<li>快速：如果缓冲池中的一个页面不是脏的，那么DBMS可以简单地 “删除” 它</li>\n<li>慢速：如果一个页面脏了，那么DBMS必须写回磁盘以确保其更改被持久化</li>\n<li>我们需要在快速回收与将来不再读取的脏写页面之间进行权衡</li>\n</ul>\n<p><strong>后台写入</strong></p>\n<ul>\n<li>DBMS可以周期性的遍历页表并将脏页写入磁盘</li>\n<li>当安全地写入脏页时，DBMS可以收回改页或只是取消设置脏页标志</li>\n<li>需要注意的是，在写入脏页的日志记录之前，我们不会写入它们</li>\n</ul>\n<p><strong>其他的内存池</strong></p>\n<ul>\n<li>除了元组和索引之外，DBMS还需要内存</li>\n<li>这些其他的内存池可能并不总是由磁盘支持，这取决于具体实现<ul>\n<li>Sorting + Join Buffers</li>\n<li>Query Caches</li>\n<li>Maintenance Buffers</li>\n<li>Log Buffers</li>\n<li>Dictionary Caches</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>DBMS如何管理内存，以及处理内存与磁盘间的数据交换</strong></p>\n<ul>\n<li>空间控制：在磁盘哪里写入页面；目标是将经常使用的页面在磁盘上尽可能的靠近。</li>\n<li>时间控制：什么时候将页面读入内存；什么时候将它们写入磁盘？目标是减少从磁盘读取数据导致的超长耗时。</li>\n</ul>\n<p><strong>磁盘式数据库系统的架构</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/DISK-ORIENTED.png\" alt=\"DISK-ORIENTED\"></p>\n<p><strong>缓冲池组织</strong></p>\n<ul>\n<li>缓冲池是以固定大小的页以数组的形式组织成的存储区域，一个数组元素叫做帧(frame)。</li>\n<li>当DBMS请求一个页面进入内存的时候，缓冲池 (Buffer Pool) 中会出现页面的精确拷贝。</li>\n</ul>\n<p><strong>缓冲池元数据</strong></p>\n<ul>\n<li>页表(Page Table)记录了当前在内存中的页面</li>\n<li>同时也包括了每个页面附加的元数据：是否脏页的标志；Pin（别针）/Reference Counter（引用计数器）</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/Buffer-pool-meta-data.png\" alt=\"Buffer-pool-meta-data\"></p>\n<ul>\n<li>用Pin来标识页面被访问了</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/Pin.png\" alt=\"Pin\"></p>\n<p><strong>读页面的时候Page Table加锁</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/read-disk1.png\" alt=\"read-disk1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/read-disk2.png\" alt=\"read-disk2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/read-disk3.png\" alt=\"read-disk3\"></p>\n<p><strong>锁 vs 插销 (LOCKS LATCHES)</strong></p>\n<ul>\n<li>锁：保护数据库的逻辑内容不受其他事务的影响；保证事务的持久化；需要能够支持回改变化</li>\n<li>插销：保护DBMS的内部数据结构的关键部分不受其他的线程影响；支持操作持久化；不需要支持回滚变化，用mutex实现</li>\n</ul>\n<p><strong>Page table vs page directory （页表和页目录）</strong></p>\n<ul>\n<li>页目录是页 id 到页在文件位置的映射，所有的更改必须记录在磁盘上，以便DBMS在重新启动时查找。</li>\n<li>页表是从页 id 到缓冲池中页副本位置的映射，这是一种不需要存储在磁盘上的数据结构。</li>\n</ul>\n<p><strong>多个缓冲池</strong></p>\n<ul>\n<li>在整个系统中，DBMS不总是只有一个缓冲池：多个缓冲池实例；每个数据库的缓冲池；每个页面类型的缓冲池</li>\n<li>有助于减少闩(latch)锁争用，并该静位置</li>\n</ul>\n<p><strong>预取(PRE-PETCHING)</strong></p>\n<ul>\n<li>DBMS可以基于一个查询计划做预读，顺序扫描，索引扫描</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre1.png\" alt=\"pre1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre2.png\" alt=\"pre2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre3.png\" alt=\"pre3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre4.png\" alt=\"pre4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre5.png\" alt=\"pre5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/pre6.png\" alt=\"pre6\"></p>\n<p><strong>索引预读</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-pre1.png\" alt=\"index-pre1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-pre2.png\" alt=\"index-pre2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-pre3.png\" alt=\"index-pre3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-pre4.png\" alt=\"index-pre4\"></p>\n<p><strong>扫描共享 (SCAN SHARING)</strong></p>\n<ul>\n<li>多个查询任务能够重用从存储或操作计算中检索到的数据：这个结果缓存不同</li>\n<li>允许将多个查询附加到扫描表的单个光标上：查询任务不必完全相同；中间结果也可以共享</li>\n<li>如果一个查询启动了一个扫描，并且已经有一个执行了扫描，那么DBMS将附加到第二个查询的光标上：DBMS跟踪第二个查询和第一个查询的连接位置，以便在到达数据结构末尾时完成扫描</li>\n<li>IBMDB2 和 MSSQL完全支持</li>\n<li>Oracle仅支持相同查询的光标共享</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan1.png\" alt=\"scan1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan2.png\" alt=\"scan2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan3.png\" alt=\"scan3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan4.png\" alt=\"scan4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan5.png\" alt=\"scan5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan6.png\" alt=\"scan6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan7.png\" alt=\"scan7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan8.png\" alt=\"scan8\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan9.png\" alt=\"scan9\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/scan10.png\" alt=\"scan10\"></p>\n<p><strong>缓冲池旁路(Buffer pool bypass)</strong></p>\n<ul>\n<li>顺序扫描运算符不会将提取的页存储在缓冲池中，以避免开销：内存是本地运行查询的；如果操作需要读取磁盘上连续的大量页序列，可以以很好的性能工作</li>\n<li>在Informix中叫做”Light Scans”</li>\n</ul>\n<p><strong>操作系统页面缓存</strong></p>\n<ul>\n<li>大多数磁盘操作都是通过操作系统API进行的。除非你告诉它不要这样做，否则操作系统维护自己的文件系统缓存。</li>\n<li>大多数DBMS使用直接I/O (O_direct) 绕过操作系统缓存：避免页的荣誉副本；不同的页面回收策略</li>\n</ul>\n<p><strong>缓冲区替换策略</strong></p>\n<ul>\n<li>当DBMS需要释放一个页帧(frame)来为新页面腾出空间时，它必须决定从缓冲池中退出哪个页面</li>\n<li>策略目标：正确性；准确度；速度；元数据开销</li>\n</ul>\n<p><strong>LRU（least recently used）</strong></p>\n<ul>\n<li>维护每个页面上次访问的时间戳</li>\n<li>当DBMS需要回收一个页面时，选择时间戳最早的页面</li>\n<li>保持页面的排序顺序，以减少还出时的搜索时间</li>\n</ul>\n<p><strong>时钟 CLOCK</strong></p>\n<ul>\n<li>接近LRU但不需要每页单独的时间戳：每个页面有一个引用位；当页面被访问的时候，设置成1</li>\n<li>用”时钟指针(clock hand)”在圆形缓冲区中组织页面：扫描时检查页位是否设置为1，如果是，设置成0。不是的话，换出</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock1.png\" alt=\"clock1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock2.png\" alt=\"clock2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock3.png\" alt=\"clock3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock4.png\" alt=\"clock4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock5.png\" alt=\"clock5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock6.png\" alt=\"clock6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock7.png\" alt=\"clock7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/clock8.png\" alt=\"clock8\"></p>\n<ul>\n<li>存在的问题：LRU和时钟替换策略容易受到缓冲区连续溢出的影响</li>\n<li>查询执行顺序扫描，读取每一页</li>\n<li>这会用一次又一次的读取的页污染缓冲池</li>\n<li>这种情况下最近使用的页面实际上是最不需要的页面</li>\n</ul>\n<p><strong>顺序溢出(Sequential flooding)</strong></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq1.png\" alt=\"seq1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq2.png\" alt=\"seq2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq3.png\" alt=\"seq3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq4.png\" alt=\"seq4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq5.png\" alt=\"seq5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/seq6.png\" alt=\"seq6\"></p>\n<p><strong>更好的策略：LRU-K</strong></p>\n<ul>\n<li>考虑最后k个引用的历史作为时间戳，并计算后续访问之间的时间间隔</li>\n<li>然后，DBMS使用此历史记录来估计下一次访问该页的时间</li>\n</ul>\n<p><strong>更好的策略：本地化</strong></p>\n<ul>\n<li>DBMS根据 txn/查询 选择要换出的页面。这样可以最大限度地减少每个查询对缓冲池的污染</li>\n<li>跟踪查询访问的页面</li>\n</ul>\n<p><strong>更好的策略：优先级提示</strong></p>\n<ul>\n<li>当查询执行的时候，DBMS知道每个页面的具体内容</li>\n<li>它可以在buffer pool中提供提示，辨别一个页面是不是重要的</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-page1.png\" alt=\"index-page1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-page2.png\" alt=\"index-page2\">)</p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-05-NOTES/index-page3.png\" alt=\"index-page3\">)</p>\n<p><strong>脏页</strong></p>\n<ul>\n<li>快速：如果缓冲池中的一个页面不是脏的，那么DBMS可以简单地 “删除” 它</li>\n<li>慢速：如果一个页面脏了，那么DBMS必须写回磁盘以确保其更改被持久化</li>\n<li>我们需要在快速回收与将来不再读取的脏写页面之间进行权衡</li>\n</ul>\n<p><strong>后台写入</strong></p>\n<ul>\n<li>DBMS可以周期性的遍历页表并将脏页写入磁盘</li>\n<li>当安全地写入脏页时，DBMS可以收回改页或只是取消设置脏页标志</li>\n<li>需要注意的是，在写入脏页的日志记录之前，我们不会写入它们</li>\n</ul>\n<p><strong>其他的内存池</strong></p>\n<ul>\n<li>除了元组和索引之外，DBMS还需要内存</li>\n<li>这些其他的内存池可能并不总是由磁盘支持，这取决于具体实现<ul>\n<li>Sorting + Join Buffers</li>\n<li>Query Caches</li>\n<li>Maintenance Buffers</li>\n<li>Log Buffers</li>\n<li>Dictionary Caches</li>\n</ul>\n</li>\n</ul>\n"},{"title":"CMU-DBMS-COURSE-06-NOTES","date":"2019-04-06T09:24:36.000Z","_content":"\n**课程进度**\n\n- 前面我们讲了磁盘管理和缓冲池管理，现在我们将讨论如何支持DBMS的执行引擎从页面读取/写入数据。\n- 这涉及到两种重要的数据结构：哈希表（Hash Tables），树(Tree)\n\n![status](CMU-DBMS-COURSE-06-NOTES/status.png)\n\n- 数据库中用到这两种基础数据结构的组件：内部元数据；核心数据存储；临时数据存储；表索引\n\n**设计上的思考**\n\n- 数据组织：我们如何在内存/页面中布局数据结构，以及存储哪些信息以支持高效访问。\n- 并发控制：如何支持多线程同时访问数据结构而不出问题。\n\n**哈希表**\n\n- 哈希表实现了将键映射到值的关联数组抽象数据类型。\n- 它使用一个散列函数来计算数组中的偏移量，从中找到所需的值。\n\n**静态Hash表**\n\n- 为需要记录的每个元素分配一个槽的巨型数组。\n- 去找一个元素的时候，对key用数组元素的数量取模去找到它在数组中的偏移量。\n\n![static-hash1](CMU-DBMS-COURSE-06-NOTES/static-hash1.png)\n\n![static-hash2](CMU-DBMS-COURSE-06-NOTES/static-hash2.png)\n\n- 假设你事先知道元素的数量，每个key都是唯一的，有一个完美的hash函数，确保如果 key1 != key2，则 hash(key1) != hash(key2)。\n\n**哈希函数**\n\n- 我们不想在连接算法中使用加密哈希函数。\n- 我们希望实现的哈希算法，速度快，碰撞率足够低。\n- 一些有名的哈希函数\n  - MurmurHash（2008）：被设计成一个快速、通用的哈希函数。\n  - Google CityHash（2011）：基于MurmurHash2的设计思想；被设计成对小key(< 64 bytes)哈希速度很快。\n  - Google FarmHash（2014）：Cityhash的新版本，有更低的碰撞率。\n  - CLHash（2016）：基于无进位乘法的快速散列函数。\n- 这些哈希函数性能对比测试\n\n![hash-benchmark](CMU-DBMS-COURSE-06-NOTES/hash-benchmark.png)\n\n**静态哈希函数的方案**\n\n- 方法一：线性探针散列(Linear Probe Hashing)\n- 方法二：Robin Hood hashing\n- 方法三：Cuckoo Hashing\n\n**Linear Probe Hashing**\n\n- 一张巨大的充满了slot的表\n- 通过线性的去搜索表中的下一个空闲slot来解决冲突\n  - 要确定元素是否存在，请散列到索引重的某个位置并扫描它\n  - 必须将key存储在索引中才能知道何时停止扫描\n\n- 算法具体流程\n\n![probe-hash](CMU-DBMS-COURSE-06-NOTES/probe-hash.png)\n\n- 示例\n\n![liner-probe1](CMU-DBMS-COURSE-06-NOTES/liner-probe1.png)\n\n![liner-probe2](CMU-DBMS-COURSE-06-NOTES/liner-probe2.png)\n\n![liner-probe3](CMU-DBMS-COURSE-06-NOTES/liner-probe3.png)\n\n![liner-probe4](CMU-DBMS-COURSE-06-NOTES/liner-probe4.png)\n\n![liner-probe5](CMU-DBMS-COURSE-06-NOTES/liner-probe5.png)\n\n![liner-probe6](CMU-DBMS-COURSE-06-NOTES/liner-probe6.png)\n\n**Robin Hood Hashing**\n\n- Linear probe hashing的变种，从“富”键中窃取插槽，并将其提供给“差”键。\n- 每个键跟踪它们在表中最佳位置的位置的数量\n- 插入时，如果第一个key比第二个key离其最佳位置更远，则key会占用另一个key的槽\n- 示例\n\n![robin-hash1](CMU-DBMS-COURSE-06-NOTES/robin-hash1.png)\n\n![robin-hash2](CMU-DBMS-COURSE-06-NOTES/robin-hash2.png)\n\n![robin-hash3](CMU-DBMS-COURSE-06-NOTES/robin-hash3.png)\n\n![robin-hash4](CMU-DBMS-COURSE-06-NOTES/robin-hash4.png)\n\n![robin-hash5](CMU-DBMS-COURSE-06-NOTES/robin-hash5.png)\n\n![robin-hash6](CMU-DBMS-COURSE-06-NOTES/robin-hash6.png)\n\n![robin-hash7](CMU-DBMS-COURSE-06-NOTES/robin-hash7.png)\n\n![robin-hash8](CMU-DBMS-COURSE-06-NOTES/robin-hash8.png)\n\n![robin-hash9](CMU-DBMS-COURSE-06-NOTES/robin-hash9.png)\n\n**CUCKOO HASHING**\n\n- 使用具有不同哈希函数的多个哈希表\n- 在插入时，检查每一张表并挑选任何一个有空闲slot的\n- 如果没有表有空闲的slot，则其中一个表移出元素，然后重新散列以找到一个新的位置\n- 查找和删除都是O(1)，因为每个hash表只检查一个位置\n\n![cuckoo-hash1](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash1.png)\n\n![cuckoo-hash2](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash2.png)\n\n![cuckoo-hash3](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash3.png)\n\n![cuckoo-hash4](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash4.png)\n\n![cuckoo-hash5](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash5.png)\n\n![cuckoo-hash6](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash6.png)\n\n![cuckoo-hash7](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash7.png)\n\n![cuckoo-hash8](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash8.png)\n\n![cuckoo-hash9](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash9.png)\n\n- 确保移动键的时候不会陷入无限循环\n- 如果我们找到一个循环，那么我们可以用新的哈希函数来重建真个哈希表\n- 对于两个散列函数，我们（可能）不需要重建表，直到它满到50%\n- 对于三个哈希函数，我们（可能）不需要重新构建表，直到它达到大约90%的满值\n\n**总结**\n\n- 前面的哈希表要求知道要提前存储元素的数量\n- 如果需要增大/缩小，则需要重新生成整个表\n- 动态哈希表可以能够按需增长/收缩\n\n**链式散列**\n\n- 维护哈希表中每个槽的桶的链接列表\n- 通过将具有相同哈希键的所有元素放入同一个存储桶来解决冲突\n- 要确定元素是否存在，请散列到其bucket并扫描它\n\n![chained-hash1](CMU-DBMS-COURSE-06-NOTES/chained-hash1.png)\n\n![chained-hash2](CMU-DBMS-COURSE-06-NOTES/chained-hash2.png)\n\n- 哈希表可以无限增长，因为你只需不断向链接列表中添加新的存储桶\n- 你只需要在bucket上使用一个闩锁来存储一个新条目或扩展链接链表\n\n**可扩展散列**\n\n- 我们将桶拆分，而不是让链表永远增长。\n- 这要求拆分时重新调整条目，但是更改已经本地化\n\n![extendible-hash1](CMU-DBMS-COURSE-06-NOTES/extendible-hash1.png)\n\n![extendible-hash2](CMU-DBMS-COURSE-06-NOTES/extendible-hash2.png)\n\n![extendible-hash3](CMU-DBMS-COURSE-06-NOTES/extendible-hash3.png)\n\n![extendible-hash4](CMU-DBMS-COURSE-06-NOTES/extendible-hash4.png)\n\n![extendible-hash5](CMU-DBMS-COURSE-06-NOTES/extendible-hash5.png)\n\n![extendible-hash6](CMU-DBMS-COURSE-06-NOTES/extendible-hash6.png)\n\n![extendible-hash7](CMU-DBMS-COURSE-06-NOTES/extendible-hash7.png)\n\n![extendible-hash8](CMU-DBMS-COURSE-06-NOTES/extendible-hash8.png)\n\n![extendible-hash9](CMU-DBMS-COURSE-06-NOTES/extendible-hash9.png)\n\n**Linear Hashing**\n\n- 保持跟踪下一个要拆分的存储桶的指针\n- 在任何通溢出的时候，在指针位置拆分桶\n- 溢出条件由实际条件决定\n  - 空间利用\n  - 溢出链平均长度\n\n![linear-hash1](CMU-DBMS-COURSE-06-NOTES/linear-hash1.png)\n\n![linear-hash2](CMU-DBMS-COURSE-06-NOTES/linear-hash2.png)\n\n![linear-hash3](CMU-DBMS-COURSE-06-NOTES/linear-hash3.png)\n\n![linear-hash4](CMU-DBMS-COURSE-06-NOTES/linear-hash4.png)\n\n![linear-hash6](CMU-DBMS-COURSE-06-NOTES/linear-hash6.png)\n\n![linear-hash7](CMU-DBMS-COURSE-06-NOTES/linear-hash7.png)\n\n![linear-hash8](CMU-DBMS-COURSE-06-NOTES/linear-hash8.png)\n\n![linear-hash9](CMU-DBMS-COURSE-06-NOTES/linear-hash9.png)\n\n![linear-hash10](CMU-DBMS-COURSE-06-NOTES/linear-hash10.png)\n\n","source":"_posts/CMU-DBMS-COURSE-06-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-06-NOTES\ndate: 2019-04-06 17:24:36\ntags:\n---\n\n**课程进度**\n\n- 前面我们讲了磁盘管理和缓冲池管理，现在我们将讨论如何支持DBMS的执行引擎从页面读取/写入数据。\n- 这涉及到两种重要的数据结构：哈希表（Hash Tables），树(Tree)\n\n![status](CMU-DBMS-COURSE-06-NOTES/status.png)\n\n- 数据库中用到这两种基础数据结构的组件：内部元数据；核心数据存储；临时数据存储；表索引\n\n**设计上的思考**\n\n- 数据组织：我们如何在内存/页面中布局数据结构，以及存储哪些信息以支持高效访问。\n- 并发控制：如何支持多线程同时访问数据结构而不出问题。\n\n**哈希表**\n\n- 哈希表实现了将键映射到值的关联数组抽象数据类型。\n- 它使用一个散列函数来计算数组中的偏移量，从中找到所需的值。\n\n**静态Hash表**\n\n- 为需要记录的每个元素分配一个槽的巨型数组。\n- 去找一个元素的时候，对key用数组元素的数量取模去找到它在数组中的偏移量。\n\n![static-hash1](CMU-DBMS-COURSE-06-NOTES/static-hash1.png)\n\n![static-hash2](CMU-DBMS-COURSE-06-NOTES/static-hash2.png)\n\n- 假设你事先知道元素的数量，每个key都是唯一的，有一个完美的hash函数，确保如果 key1 != key2，则 hash(key1) != hash(key2)。\n\n**哈希函数**\n\n- 我们不想在连接算法中使用加密哈希函数。\n- 我们希望实现的哈希算法，速度快，碰撞率足够低。\n- 一些有名的哈希函数\n  - MurmurHash（2008）：被设计成一个快速、通用的哈希函数。\n  - Google CityHash（2011）：基于MurmurHash2的设计思想；被设计成对小key(< 64 bytes)哈希速度很快。\n  - Google FarmHash（2014）：Cityhash的新版本，有更低的碰撞率。\n  - CLHash（2016）：基于无进位乘法的快速散列函数。\n- 这些哈希函数性能对比测试\n\n![hash-benchmark](CMU-DBMS-COURSE-06-NOTES/hash-benchmark.png)\n\n**静态哈希函数的方案**\n\n- 方法一：线性探针散列(Linear Probe Hashing)\n- 方法二：Robin Hood hashing\n- 方法三：Cuckoo Hashing\n\n**Linear Probe Hashing**\n\n- 一张巨大的充满了slot的表\n- 通过线性的去搜索表中的下一个空闲slot来解决冲突\n  - 要确定元素是否存在，请散列到索引重的某个位置并扫描它\n  - 必须将key存储在索引中才能知道何时停止扫描\n\n- 算法具体流程\n\n![probe-hash](CMU-DBMS-COURSE-06-NOTES/probe-hash.png)\n\n- 示例\n\n![liner-probe1](CMU-DBMS-COURSE-06-NOTES/liner-probe1.png)\n\n![liner-probe2](CMU-DBMS-COURSE-06-NOTES/liner-probe2.png)\n\n![liner-probe3](CMU-DBMS-COURSE-06-NOTES/liner-probe3.png)\n\n![liner-probe4](CMU-DBMS-COURSE-06-NOTES/liner-probe4.png)\n\n![liner-probe5](CMU-DBMS-COURSE-06-NOTES/liner-probe5.png)\n\n![liner-probe6](CMU-DBMS-COURSE-06-NOTES/liner-probe6.png)\n\n**Robin Hood Hashing**\n\n- Linear probe hashing的变种，从“富”键中窃取插槽，并将其提供给“差”键。\n- 每个键跟踪它们在表中最佳位置的位置的数量\n- 插入时，如果第一个key比第二个key离其最佳位置更远，则key会占用另一个key的槽\n- 示例\n\n![robin-hash1](CMU-DBMS-COURSE-06-NOTES/robin-hash1.png)\n\n![robin-hash2](CMU-DBMS-COURSE-06-NOTES/robin-hash2.png)\n\n![robin-hash3](CMU-DBMS-COURSE-06-NOTES/robin-hash3.png)\n\n![robin-hash4](CMU-DBMS-COURSE-06-NOTES/robin-hash4.png)\n\n![robin-hash5](CMU-DBMS-COURSE-06-NOTES/robin-hash5.png)\n\n![robin-hash6](CMU-DBMS-COURSE-06-NOTES/robin-hash6.png)\n\n![robin-hash7](CMU-DBMS-COURSE-06-NOTES/robin-hash7.png)\n\n![robin-hash8](CMU-DBMS-COURSE-06-NOTES/robin-hash8.png)\n\n![robin-hash9](CMU-DBMS-COURSE-06-NOTES/robin-hash9.png)\n\n**CUCKOO HASHING**\n\n- 使用具有不同哈希函数的多个哈希表\n- 在插入时，检查每一张表并挑选任何一个有空闲slot的\n- 如果没有表有空闲的slot，则其中一个表移出元素，然后重新散列以找到一个新的位置\n- 查找和删除都是O(1)，因为每个hash表只检查一个位置\n\n![cuckoo-hash1](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash1.png)\n\n![cuckoo-hash2](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash2.png)\n\n![cuckoo-hash3](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash3.png)\n\n![cuckoo-hash4](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash4.png)\n\n![cuckoo-hash5](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash5.png)\n\n![cuckoo-hash6](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash6.png)\n\n![cuckoo-hash7](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash7.png)\n\n![cuckoo-hash8](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash8.png)\n\n![cuckoo-hash9](CMU-DBMS-COURSE-06-NOTES/cuckoo-hash9.png)\n\n- 确保移动键的时候不会陷入无限循环\n- 如果我们找到一个循环，那么我们可以用新的哈希函数来重建真个哈希表\n- 对于两个散列函数，我们（可能）不需要重建表，直到它满到50%\n- 对于三个哈希函数，我们（可能）不需要重新构建表，直到它达到大约90%的满值\n\n**总结**\n\n- 前面的哈希表要求知道要提前存储元素的数量\n- 如果需要增大/缩小，则需要重新生成整个表\n- 动态哈希表可以能够按需增长/收缩\n\n**链式散列**\n\n- 维护哈希表中每个槽的桶的链接列表\n- 通过将具有相同哈希键的所有元素放入同一个存储桶来解决冲突\n- 要确定元素是否存在，请散列到其bucket并扫描它\n\n![chained-hash1](CMU-DBMS-COURSE-06-NOTES/chained-hash1.png)\n\n![chained-hash2](CMU-DBMS-COURSE-06-NOTES/chained-hash2.png)\n\n- 哈希表可以无限增长，因为你只需不断向链接列表中添加新的存储桶\n- 你只需要在bucket上使用一个闩锁来存储一个新条目或扩展链接链表\n\n**可扩展散列**\n\n- 我们将桶拆分，而不是让链表永远增长。\n- 这要求拆分时重新调整条目，但是更改已经本地化\n\n![extendible-hash1](CMU-DBMS-COURSE-06-NOTES/extendible-hash1.png)\n\n![extendible-hash2](CMU-DBMS-COURSE-06-NOTES/extendible-hash2.png)\n\n![extendible-hash3](CMU-DBMS-COURSE-06-NOTES/extendible-hash3.png)\n\n![extendible-hash4](CMU-DBMS-COURSE-06-NOTES/extendible-hash4.png)\n\n![extendible-hash5](CMU-DBMS-COURSE-06-NOTES/extendible-hash5.png)\n\n![extendible-hash6](CMU-DBMS-COURSE-06-NOTES/extendible-hash6.png)\n\n![extendible-hash7](CMU-DBMS-COURSE-06-NOTES/extendible-hash7.png)\n\n![extendible-hash8](CMU-DBMS-COURSE-06-NOTES/extendible-hash8.png)\n\n![extendible-hash9](CMU-DBMS-COURSE-06-NOTES/extendible-hash9.png)\n\n**Linear Hashing**\n\n- 保持跟踪下一个要拆分的存储桶的指针\n- 在任何通溢出的时候，在指针位置拆分桶\n- 溢出条件由实际条件决定\n  - 空间利用\n  - 溢出链平均长度\n\n![linear-hash1](CMU-DBMS-COURSE-06-NOTES/linear-hash1.png)\n\n![linear-hash2](CMU-DBMS-COURSE-06-NOTES/linear-hash2.png)\n\n![linear-hash3](CMU-DBMS-COURSE-06-NOTES/linear-hash3.png)\n\n![linear-hash4](CMU-DBMS-COURSE-06-NOTES/linear-hash4.png)\n\n![linear-hash6](CMU-DBMS-COURSE-06-NOTES/linear-hash6.png)\n\n![linear-hash7](CMU-DBMS-COURSE-06-NOTES/linear-hash7.png)\n\n![linear-hash8](CMU-DBMS-COURSE-06-NOTES/linear-hash8.png)\n\n![linear-hash9](CMU-DBMS-COURSE-06-NOTES/linear-hash9.png)\n\n![linear-hash10](CMU-DBMS-COURSE-06-NOTES/linear-hash10.png)\n\n","slug":"CMU-DBMS-COURSE-06-NOTES","published":1,"updated":"2019-06-26T11:56:34.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvymm000avkqppiw366mg","content":"<p><strong>课程进度</strong></p>\n<ul>\n<li>前面我们讲了磁盘管理和缓冲池管理，现在我们将讨论如何支持DBMS的执行引擎从页面读取/写入数据。</li>\n<li>这涉及到两种重要的数据结构：哈希表（Hash Tables），树(Tree)</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/status.png\" alt=\"status\"></p>\n<ul>\n<li>数据库中用到这两种基础数据结构的组件：内部元数据；核心数据存储；临时数据存储；表索引</li>\n</ul>\n<p><strong>设计上的思考</strong></p>\n<ul>\n<li>数据组织：我们如何在内存/页面中布局数据结构，以及存储哪些信息以支持高效访问。</li>\n<li>并发控制：如何支持多线程同时访问数据结构而不出问题。</li>\n</ul>\n<p><strong>哈希表</strong></p>\n<ul>\n<li>哈希表实现了将键映射到值的关联数组抽象数据类型。</li>\n<li>它使用一个散列函数来计算数组中的偏移量，从中找到所需的值。</li>\n</ul>\n<p><strong>静态Hash表</strong></p>\n<ul>\n<li>为需要记录的每个元素分配一个槽的巨型数组。</li>\n<li>去找一个元素的时候，对key用数组元素的数量取模去找到它在数组中的偏移量。</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/static-hash1.png\" alt=\"static-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/static-hash2.png\" alt=\"static-hash2\"></p>\n<ul>\n<li>假设你事先知道元素的数量，每个key都是唯一的，有一个完美的hash函数，确保如果 key1 != key2，则 hash(key1) != hash(key2)。</li>\n</ul>\n<p><strong>哈希函数</strong></p>\n<ul>\n<li>我们不想在连接算法中使用加密哈希函数。</li>\n<li>我们希望实现的哈希算法，速度快，碰撞率足够低。</li>\n<li>一些有名的哈希函数<ul>\n<li>MurmurHash（2008）：被设计成一个快速、通用的哈希函数。</li>\n<li>Google CityHash（2011）：基于MurmurHash2的设计思想；被设计成对小key(&lt; 64 bytes)哈希速度很快。</li>\n<li>Google FarmHash（2014）：Cityhash的新版本，有更低的碰撞率。</li>\n<li>CLHash（2016）：基于无进位乘法的快速散列函数。</li>\n</ul>\n</li>\n<li>这些哈希函数性能对比测试</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/hash-benchmark.png\" alt=\"hash-benchmark\"></p>\n<p><strong>静态哈希函数的方案</strong></p>\n<ul>\n<li>方法一：线性探针散列(Linear Probe Hashing)</li>\n<li>方法二：Robin Hood hashing</li>\n<li>方法三：Cuckoo Hashing</li>\n</ul>\n<p><strong>Linear Probe Hashing</strong></p>\n<ul>\n<li>一张巨大的充满了slot的表</li>\n<li><p>通过线性的去搜索表中的下一个空闲slot来解决冲突</p>\n<ul>\n<li>要确定元素是否存在，请散列到索引重的某个位置并扫描它</li>\n<li>必须将key存储在索引中才能知道何时停止扫描</li>\n</ul>\n</li>\n<li><p>算法具体流程</p>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/probe-hash.png\" alt=\"probe-hash\"></p>\n<ul>\n<li>示例</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe1.png\" alt=\"liner-probe1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe2.png\" alt=\"liner-probe2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe3.png\" alt=\"liner-probe3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe4.png\" alt=\"liner-probe4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe5.png\" alt=\"liner-probe5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe6.png\" alt=\"liner-probe6\"></p>\n<p><strong>Robin Hood Hashing</strong></p>\n<ul>\n<li>Linear probe hashing的变种，从“富”键中窃取插槽，并将其提供给“差”键。</li>\n<li>每个键跟踪它们在表中最佳位置的位置的数量</li>\n<li>插入时，如果第一个key比第二个key离其最佳位置更远，则key会占用另一个key的槽</li>\n<li>示例</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash1.png\" alt=\"robin-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash2.png\" alt=\"robin-hash2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash3.png\" alt=\"robin-hash3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash4.png\" alt=\"robin-hash4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash5.png\" alt=\"robin-hash5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash6.png\" alt=\"robin-hash6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash7.png\" alt=\"robin-hash7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash8.png\" alt=\"robin-hash8\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash9.png\" alt=\"robin-hash9\"></p>\n<p><strong>CUCKOO HASHING</strong></p>\n<ul>\n<li>使用具有不同哈希函数的多个哈希表</li>\n<li>在插入时，检查每一张表并挑选任何一个有空闲slot的</li>\n<li>如果没有表有空闲的slot，则其中一个表移出元素，然后重新散列以找到一个新的位置</li>\n<li>查找和删除都是O(1)，因为每个hash表只检查一个位置</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash1.png\" alt=\"cuckoo-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash2.png\" alt=\"cuckoo-hash2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash3.png\" alt=\"cuckoo-hash3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash4.png\" alt=\"cuckoo-hash4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash5.png\" alt=\"cuckoo-hash5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash6.png\" alt=\"cuckoo-hash6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash7.png\" alt=\"cuckoo-hash7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash8.png\" alt=\"cuckoo-hash8\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash9.png\" alt=\"cuckoo-hash9\"></p>\n<ul>\n<li>确保移动键的时候不会陷入无限循环</li>\n<li>如果我们找到一个循环，那么我们可以用新的哈希函数来重建真个哈希表</li>\n<li>对于两个散列函数，我们（可能）不需要重建表，直到它满到50%</li>\n<li>对于三个哈希函数，我们（可能）不需要重新构建表，直到它达到大约90%的满值</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li>前面的哈希表要求知道要提前存储元素的数量</li>\n<li>如果需要增大/缩小，则需要重新生成整个表</li>\n<li>动态哈希表可以能够按需增长/收缩</li>\n</ul>\n<p><strong>链式散列</strong></p>\n<ul>\n<li>维护哈希表中每个槽的桶的链接列表</li>\n<li>通过将具有相同哈希键的所有元素放入同一个存储桶来解决冲突</li>\n<li>要确定元素是否存在，请散列到其bucket并扫描它</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/chained-hash1.png\" alt=\"chained-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/chained-hash2.png\" alt=\"chained-hash2\"></p>\n<ul>\n<li>哈希表可以无限增长，因为你只需不断向链接列表中添加新的存储桶</li>\n<li>你只需要在bucket上使用一个闩锁来存储一个新条目或扩展链接链表</li>\n</ul>\n<p><strong>可扩展散列</strong></p>\n<ul>\n<li>我们将桶拆分，而不是让链表永远增长。</li>\n<li>这要求拆分时重新调整条目，但是更改已经本地化</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash1.png\" alt=\"extendible-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash2.png\" alt=\"extendible-hash2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash3.png\" alt=\"extendible-hash3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash4.png\" alt=\"extendible-hash4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash5.png\" alt=\"extendible-hash5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash6.png\" alt=\"extendible-hash6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash7.png\" alt=\"extendible-hash7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash8.png\" alt=\"extendible-hash8\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash9.png\" alt=\"extendible-hash9\"></p>\n<p><strong>Linear Hashing</strong></p>\n<ul>\n<li>保持跟踪下一个要拆分的存储桶的指针</li>\n<li>在任何通溢出的时候，在指针位置拆分桶</li>\n<li>溢出条件由实际条件决定<ul>\n<li>空间利用</li>\n<li>溢出链平均长度</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash1.png\" alt=\"linear-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash2.png\" alt=\"linear-hash2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash3.png\" alt=\"linear-hash3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash4.png\" alt=\"linear-hash4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash6.png\" alt=\"linear-hash6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash7.png\" alt=\"linear-hash7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash8.png\" alt=\"linear-hash8\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash9.png\" alt=\"linear-hash9\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash10.png\" alt=\"linear-hash10\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>课程进度</strong></p>\n<ul>\n<li>前面我们讲了磁盘管理和缓冲池管理，现在我们将讨论如何支持DBMS的执行引擎从页面读取/写入数据。</li>\n<li>这涉及到两种重要的数据结构：哈希表（Hash Tables），树(Tree)</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/status.png\" alt=\"status\"></p>\n<ul>\n<li>数据库中用到这两种基础数据结构的组件：内部元数据；核心数据存储；临时数据存储；表索引</li>\n</ul>\n<p><strong>设计上的思考</strong></p>\n<ul>\n<li>数据组织：我们如何在内存/页面中布局数据结构，以及存储哪些信息以支持高效访问。</li>\n<li>并发控制：如何支持多线程同时访问数据结构而不出问题。</li>\n</ul>\n<p><strong>哈希表</strong></p>\n<ul>\n<li>哈希表实现了将键映射到值的关联数组抽象数据类型。</li>\n<li>它使用一个散列函数来计算数组中的偏移量，从中找到所需的值。</li>\n</ul>\n<p><strong>静态Hash表</strong></p>\n<ul>\n<li>为需要记录的每个元素分配一个槽的巨型数组。</li>\n<li>去找一个元素的时候，对key用数组元素的数量取模去找到它在数组中的偏移量。</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/static-hash1.png\" alt=\"static-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/static-hash2.png\" alt=\"static-hash2\"></p>\n<ul>\n<li>假设你事先知道元素的数量，每个key都是唯一的，有一个完美的hash函数，确保如果 key1 != key2，则 hash(key1) != hash(key2)。</li>\n</ul>\n<p><strong>哈希函数</strong></p>\n<ul>\n<li>我们不想在连接算法中使用加密哈希函数。</li>\n<li>我们希望实现的哈希算法，速度快，碰撞率足够低。</li>\n<li>一些有名的哈希函数<ul>\n<li>MurmurHash（2008）：被设计成一个快速、通用的哈希函数。</li>\n<li>Google CityHash（2011）：基于MurmurHash2的设计思想；被设计成对小key(&lt; 64 bytes)哈希速度很快。</li>\n<li>Google FarmHash（2014）：Cityhash的新版本，有更低的碰撞率。</li>\n<li>CLHash（2016）：基于无进位乘法的快速散列函数。</li>\n</ul>\n</li>\n<li>这些哈希函数性能对比测试</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/hash-benchmark.png\" alt=\"hash-benchmark\"></p>\n<p><strong>静态哈希函数的方案</strong></p>\n<ul>\n<li>方法一：线性探针散列(Linear Probe Hashing)</li>\n<li>方法二：Robin Hood hashing</li>\n<li>方法三：Cuckoo Hashing</li>\n</ul>\n<p><strong>Linear Probe Hashing</strong></p>\n<ul>\n<li>一张巨大的充满了slot的表</li>\n<li><p>通过线性的去搜索表中的下一个空闲slot来解决冲突</p>\n<ul>\n<li>要确定元素是否存在，请散列到索引重的某个位置并扫描它</li>\n<li>必须将key存储在索引中才能知道何时停止扫描</li>\n</ul>\n</li>\n<li><p>算法具体流程</p>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/probe-hash.png\" alt=\"probe-hash\"></p>\n<ul>\n<li>示例</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe1.png\" alt=\"liner-probe1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe2.png\" alt=\"liner-probe2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe3.png\" alt=\"liner-probe3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe4.png\" alt=\"liner-probe4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe5.png\" alt=\"liner-probe5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/liner-probe6.png\" alt=\"liner-probe6\"></p>\n<p><strong>Robin Hood Hashing</strong></p>\n<ul>\n<li>Linear probe hashing的变种，从“富”键中窃取插槽，并将其提供给“差”键。</li>\n<li>每个键跟踪它们在表中最佳位置的位置的数量</li>\n<li>插入时，如果第一个key比第二个key离其最佳位置更远，则key会占用另一个key的槽</li>\n<li>示例</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash1.png\" alt=\"robin-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash2.png\" alt=\"robin-hash2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash3.png\" alt=\"robin-hash3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash4.png\" alt=\"robin-hash4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash5.png\" alt=\"robin-hash5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash6.png\" alt=\"robin-hash6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash7.png\" alt=\"robin-hash7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash8.png\" alt=\"robin-hash8\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/robin-hash9.png\" alt=\"robin-hash9\"></p>\n<p><strong>CUCKOO HASHING</strong></p>\n<ul>\n<li>使用具有不同哈希函数的多个哈希表</li>\n<li>在插入时，检查每一张表并挑选任何一个有空闲slot的</li>\n<li>如果没有表有空闲的slot，则其中一个表移出元素，然后重新散列以找到一个新的位置</li>\n<li>查找和删除都是O(1)，因为每个hash表只检查一个位置</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash1.png\" alt=\"cuckoo-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash2.png\" alt=\"cuckoo-hash2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash3.png\" alt=\"cuckoo-hash3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash4.png\" alt=\"cuckoo-hash4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash5.png\" alt=\"cuckoo-hash5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash6.png\" alt=\"cuckoo-hash6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash7.png\" alt=\"cuckoo-hash7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash8.png\" alt=\"cuckoo-hash8\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash9.png\" alt=\"cuckoo-hash9\"></p>\n<ul>\n<li>确保移动键的时候不会陷入无限循环</li>\n<li>如果我们找到一个循环，那么我们可以用新的哈希函数来重建真个哈希表</li>\n<li>对于两个散列函数，我们（可能）不需要重建表，直到它满到50%</li>\n<li>对于三个哈希函数，我们（可能）不需要重新构建表，直到它达到大约90%的满值</li>\n</ul>\n<p><strong>总结</strong></p>\n<ul>\n<li>前面的哈希表要求知道要提前存储元素的数量</li>\n<li>如果需要增大/缩小，则需要重新生成整个表</li>\n<li>动态哈希表可以能够按需增长/收缩</li>\n</ul>\n<p><strong>链式散列</strong></p>\n<ul>\n<li>维护哈希表中每个槽的桶的链接列表</li>\n<li>通过将具有相同哈希键的所有元素放入同一个存储桶来解决冲突</li>\n<li>要确定元素是否存在，请散列到其bucket并扫描它</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/chained-hash1.png\" alt=\"chained-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/chained-hash2.png\" alt=\"chained-hash2\"></p>\n<ul>\n<li>哈希表可以无限增长，因为你只需不断向链接列表中添加新的存储桶</li>\n<li>你只需要在bucket上使用一个闩锁来存储一个新条目或扩展链接链表</li>\n</ul>\n<p><strong>可扩展散列</strong></p>\n<ul>\n<li>我们将桶拆分，而不是让链表永远增长。</li>\n<li>这要求拆分时重新调整条目，但是更改已经本地化</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash1.png\" alt=\"extendible-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash2.png\" alt=\"extendible-hash2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash3.png\" alt=\"extendible-hash3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash4.png\" alt=\"extendible-hash4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash5.png\" alt=\"extendible-hash5\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash6.png\" alt=\"extendible-hash6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash7.png\" alt=\"extendible-hash7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash8.png\" alt=\"extendible-hash8\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/extendible-hash9.png\" alt=\"extendible-hash9\"></p>\n<p><strong>Linear Hashing</strong></p>\n<ul>\n<li>保持跟踪下一个要拆分的存储桶的指针</li>\n<li>在任何通溢出的时候，在指针位置拆分桶</li>\n<li>溢出条件由实际条件决定<ul>\n<li>空间利用</li>\n<li>溢出链平均长度</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash1.png\" alt=\"linear-hash1\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash2.png\" alt=\"linear-hash2\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash3.png\" alt=\"linear-hash3\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash4.png\" alt=\"linear-hash4\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash6.png\" alt=\"linear-hash6\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash7.png\" alt=\"linear-hash7\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash8.png\" alt=\"linear-hash8\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash9.png\" alt=\"linear-hash9\"></p>\n<p><img src=\"/2019/04/06/CMU-DBMS-COURSE-06-NOTES/linear-hash10.png\" alt=\"linear-hash10\"></p>\n"},{"title":"CMU-DBMS-COURSE-08-NOTES","date":"2019-04-11T08:53:22.000Z","_content":"\n**隐式索引**\n\n- 大多数DBMS自动创建一个索引来确保完整性约束\n  - 主键\n  - 唯一约束\n  - 外键\n\n![implicit-index1](CMU-DBMS-COURSE-08-NOTES/implicit-index1.png)\n\n**部分索引**\n\n- 在整个表的子集上创建索引。这可能会减少它的大小和维护它的开销。\n\n![partial-index1](CMU-DBMS-COURSE-08-NOTES/partial-index1.png)\n\n**覆盖式索引**\n\n- 如果处理查询所需的所有字段都在索引中可用，那么DBMS不需要检索元组\n- 这就减少了对DBMS缓冲池的争用\n\n![covering-index1](CMU-DBMS-COURSE-08-NOTES/covering-index1.png)\n\n**索引包含列**\n\n- 在索引中嵌入其他列以支持仅索引查询，不是搜索键的一部分。\n\n![index-include1](CMU-DBMS-COURSE-08-NOTES/index-include1.png)\n\n![index-include2](CMU-DBMS-COURSE-08-NOTES/index-include2.png)\n\n![index-include3](CMU-DBMS-COURSE-08-NOTES/index-include3.png)\n\n**函数/表达式索引**\n\n- 索引不需要以它们在基表中出现的方式存储键\n- 声明索引时可以使用表达式\n\n![functional-index1](CMU-DBMS-COURSE-08-NOTES/functional-index1.png)\n\n![functional-index2](CMU-DBMS-COURSE-08-NOTES/functional-index2.png)\n\n![functional-index3](CMU-DBMS-COURSE-08-NOTES/functional-index3.png)\n\n![functional-index4](CMU-DBMS-COURSE-08-NOTES/functional-index4.png)\n\n![functional-index5](CMU-DBMS-COURSE-08-NOTES/functional-index5.png)\n\n![functional-index6](CMU-DBMS-COURSE-08-NOTES/functional-index6.png)\n\n**实现动态顺序索引的最简单的方法是使用已排序的链接列表**\n\n- 所有操作都是线性的搜索，平均开销O(N)\n\n- 优化的方案\n\n![observation1](CMU-DBMS-COURSE-08-NOTES/observation1.png)\n\n![observation2](CMU-DBMS-COURSE-08-NOTES/observation2.png)\n\n**跳跃列表**\n\n- 具有跳过中间节点的额外指针的多级链接列表\n- 在不需要全局重新平衡的情况下，按排序顺序维护keys\n\n- 不同级别的列表集合\n  - 最低级别是所有键的已排序、单独链接的列表\n  - 第二级每隔一个键连接\n  - 第三级隔4个键连接\n  - 一般来说，一个级别下面有一半的键\n- 要插入新的密钥，翻转coin以决定添加新密钥的级别。提供大致O(log n)搜索时间\n\n![skip-list1](CMU-DBMS-COURSE-08-NOTES/skip-list1.png)\n\n![skip-list2](CMU-DBMS-COURSE-08-NOTES/skip-list2.png)\n\n![skip-list3](CMU-DBMS-COURSE-08-NOTES/skip-list3.png)\n\n![skip-list4](CMU-DBMS-COURSE-08-NOTES/skip-list4.png)\n\n![skip-list5](CMU-DBMS-COURSE-08-NOTES/skip-list5.png)\n\n![skip-list6](CMU-DBMS-COURSE-08-NOTES/skip-list6.png)\n\n![skip-list7](CMU-DBMS-COURSE-08-NOTES/skip-list7.png)\n\n![skip-list8](CMU-DBMS-COURSE-08-NOTES/skip-list8.png)\n\n![skip-list9](CMU-DBMS-COURSE-08-NOTES/skip-list9.png)\n\n![skip-list10](CMU-DBMS-COURSE-08-NOTES/skip-list10.png)\n\n![skip-list11](CMU-DBMS-COURSE-08-NOTES/skip-list11.png)\n\n![skip-list12](CMU-DBMS-COURSE-08-NOTES/skip-list12.png)\n\n![skip-list13](CMU-DBMS-COURSE-08-NOTES/skip-list13.png)\n\n![skip-list14](CMU-DBMS-COURSE-08-NOTES/skip-list14.png)\n\n![skip-list15](CMU-DBMS-COURSE-08-NOTES/skip-list15.png)\n\n![skip-list16](CMU-DBMS-COURSE-08-NOTES/skip-list16.png)\n\n**跳跃链表删除操作**\n\n- 首先，通过设置一个标志告诉线程忽略，从索引中逻辑地删除一个键\n- 一旦我们知道没有其他线程持有此引用，就可以物理地删除该键\n\n![skip-list17](CMU-DBMS-COURSE-08-NOTES/skip-list17.png)\n\n![skip-list18](CMU-DBMS-COURSE-08-NOTES/skip-list18.png)\n\n![skip-list19](CMU-DBMS-COURSE-08-NOTES/skip-list19.png)\n\n![skip-list20](CMU-DBMS-COURSE-08-NOTES/skip-list20.png)\n\n![skip-list21](CMU-DBMS-COURSE-08-NOTES/skip-list21.png)\n\n![skip-list22](CMU-DBMS-COURSE-08-NOTES/skip-list22.png)\n\n- 跳表优点\n  - 如果不包含反向指针，则使用的内存比典型的B+树少\n  - 插入和删除不需要重新平衡\n- 跳表缺点\n  - 对磁盘缓存支持不友好，因为它们不优化引用的位置\n  - 反向搜索是很重要的\n\n**基数树 R-Tree**\n\n- 将键表示伟单个数字的组合。这允许线程逐个检查前缀，而不是比较整个密钥\n  - 树的高度取决于key的长度\n  - 不需要重新平衡\n  - 叶节点的路径表示叶节点的键\n  - key是隐式存储的，可以从路径中重建\n\n![r-tree1](CMU-DBMS-COURSE-08-NOTES/r-tree1.png)\n\n![r-tree2](CMU-DBMS-COURSE-08-NOTES/r-tree2.png)\n\n![r-tree3](CMU-DBMS-COURSE-08-NOTES/r-tree3.png)\n\n![r-tree4](CMU-DBMS-COURSE-08-NOTES/r-tree4.png)\n\n![r-tree5](CMU-DBMS-COURSE-08-NOTES/r-tree5.png)\n\n![r-tree6](CMU-DBMS-COURSE-08-NOTES/r-tree6.png)\n\n![r-tree7](CMU-DBMS-COURSE-08-NOTES/r-tree7.png)\n\n![r-tree8](CMU-DBMS-COURSE-08-NOTES/r-tree8.png)\n\n![r-tree9](CMU-DBMS-COURSE-08-NOTES/r-tree9.png)\n\n![r-tree10](CMU-DBMS-COURSE-08-NOTES/r-tree10.png)\n\n![r-tree11](CMU-DBMS-COURSE-08-NOTES/r-tree11.png)\n\n**基数树-二进制可比较的键**\n\n- 并非所有属性类型都可以分解为基数树的二进制可比数字\n  - Unsigned Intehers：对于小端机器，字节顺序必须翻转\n  - Signed Integers：翻转两个补码，使负数小于正数\n  - Floats：分类为组(负与正，规范化与非规范化)，然后存储为无符号整数\n  - Compound：分别变换每个属性\n\n![r-tree-bck1](CMU-DBMS-COURSE-08-NOTES/r-tree-bck1.png)\n\n![r-tree-bck2](CMU-DBMS-COURSE-08-NOTES/r-tree-bck2.png)\n\n![r-tree-bck3](CMU-DBMS-COURSE-08-NOTES/r-tree-bck3.png)\n\n**内存表索引性能比较**\n\n![in-mem-index1](CMU-DBMS-COURSE-08-NOTES/in-mem-index1.png)\n\n**思考**\n\n- 到目前为止，我们讨论过的树索引对于“点”和“范围”查询很有用\n  - 查找15217邮政编码中的所有客户\n  - 查找2018年6月至2018年9月之间的所有订单\n- 它们不擅长关键词搜索\n  - 查找包含“pavlo”一词的所有维基百科文章\n\n**维基百科查询例子**\n\n![wikipadia-example1](CMU-DBMS-COURSE-08-NOTES/wikipadia-example1.png)\n\n- 下面操作并不会帮助到我们的查询\n\n![wikipadia-example2](CMU-DBMS-COURSE-08-NOTES/wikipadia-example2.png)\n\n**倒排索引**\n\n- 倒排索引将单词映射到目标属性中包含这些单词的记录\n  - 有时称为全文搜索索引\n- 支持这个特性的主要数据库有：Solr，elastic search, Sphinx\n\n**查询类型**\n\n- 词组搜索\n  - 查找按给定顺序包含单词列表的记录\n- 临近搜索\n  - 查找两个单词出现在彼此n个单词内的记录\n- 通配符搜索\n  - 查找包含符合某种模式的单词的记录\n\n","source":"_posts/CMU-DBMS-COURSE-08-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-08-NOTES\ndate: 2019-04-11 16:53:22\ntags:\n---\n\n**隐式索引**\n\n- 大多数DBMS自动创建一个索引来确保完整性约束\n  - 主键\n  - 唯一约束\n  - 外键\n\n![implicit-index1](CMU-DBMS-COURSE-08-NOTES/implicit-index1.png)\n\n**部分索引**\n\n- 在整个表的子集上创建索引。这可能会减少它的大小和维护它的开销。\n\n![partial-index1](CMU-DBMS-COURSE-08-NOTES/partial-index1.png)\n\n**覆盖式索引**\n\n- 如果处理查询所需的所有字段都在索引中可用，那么DBMS不需要检索元组\n- 这就减少了对DBMS缓冲池的争用\n\n![covering-index1](CMU-DBMS-COURSE-08-NOTES/covering-index1.png)\n\n**索引包含列**\n\n- 在索引中嵌入其他列以支持仅索引查询，不是搜索键的一部分。\n\n![index-include1](CMU-DBMS-COURSE-08-NOTES/index-include1.png)\n\n![index-include2](CMU-DBMS-COURSE-08-NOTES/index-include2.png)\n\n![index-include3](CMU-DBMS-COURSE-08-NOTES/index-include3.png)\n\n**函数/表达式索引**\n\n- 索引不需要以它们在基表中出现的方式存储键\n- 声明索引时可以使用表达式\n\n![functional-index1](CMU-DBMS-COURSE-08-NOTES/functional-index1.png)\n\n![functional-index2](CMU-DBMS-COURSE-08-NOTES/functional-index2.png)\n\n![functional-index3](CMU-DBMS-COURSE-08-NOTES/functional-index3.png)\n\n![functional-index4](CMU-DBMS-COURSE-08-NOTES/functional-index4.png)\n\n![functional-index5](CMU-DBMS-COURSE-08-NOTES/functional-index5.png)\n\n![functional-index6](CMU-DBMS-COURSE-08-NOTES/functional-index6.png)\n\n**实现动态顺序索引的最简单的方法是使用已排序的链接列表**\n\n- 所有操作都是线性的搜索，平均开销O(N)\n\n- 优化的方案\n\n![observation1](CMU-DBMS-COURSE-08-NOTES/observation1.png)\n\n![observation2](CMU-DBMS-COURSE-08-NOTES/observation2.png)\n\n**跳跃列表**\n\n- 具有跳过中间节点的额外指针的多级链接列表\n- 在不需要全局重新平衡的情况下，按排序顺序维护keys\n\n- 不同级别的列表集合\n  - 最低级别是所有键的已排序、单独链接的列表\n  - 第二级每隔一个键连接\n  - 第三级隔4个键连接\n  - 一般来说，一个级别下面有一半的键\n- 要插入新的密钥，翻转coin以决定添加新密钥的级别。提供大致O(log n)搜索时间\n\n![skip-list1](CMU-DBMS-COURSE-08-NOTES/skip-list1.png)\n\n![skip-list2](CMU-DBMS-COURSE-08-NOTES/skip-list2.png)\n\n![skip-list3](CMU-DBMS-COURSE-08-NOTES/skip-list3.png)\n\n![skip-list4](CMU-DBMS-COURSE-08-NOTES/skip-list4.png)\n\n![skip-list5](CMU-DBMS-COURSE-08-NOTES/skip-list5.png)\n\n![skip-list6](CMU-DBMS-COURSE-08-NOTES/skip-list6.png)\n\n![skip-list7](CMU-DBMS-COURSE-08-NOTES/skip-list7.png)\n\n![skip-list8](CMU-DBMS-COURSE-08-NOTES/skip-list8.png)\n\n![skip-list9](CMU-DBMS-COURSE-08-NOTES/skip-list9.png)\n\n![skip-list10](CMU-DBMS-COURSE-08-NOTES/skip-list10.png)\n\n![skip-list11](CMU-DBMS-COURSE-08-NOTES/skip-list11.png)\n\n![skip-list12](CMU-DBMS-COURSE-08-NOTES/skip-list12.png)\n\n![skip-list13](CMU-DBMS-COURSE-08-NOTES/skip-list13.png)\n\n![skip-list14](CMU-DBMS-COURSE-08-NOTES/skip-list14.png)\n\n![skip-list15](CMU-DBMS-COURSE-08-NOTES/skip-list15.png)\n\n![skip-list16](CMU-DBMS-COURSE-08-NOTES/skip-list16.png)\n\n**跳跃链表删除操作**\n\n- 首先，通过设置一个标志告诉线程忽略，从索引中逻辑地删除一个键\n- 一旦我们知道没有其他线程持有此引用，就可以物理地删除该键\n\n![skip-list17](CMU-DBMS-COURSE-08-NOTES/skip-list17.png)\n\n![skip-list18](CMU-DBMS-COURSE-08-NOTES/skip-list18.png)\n\n![skip-list19](CMU-DBMS-COURSE-08-NOTES/skip-list19.png)\n\n![skip-list20](CMU-DBMS-COURSE-08-NOTES/skip-list20.png)\n\n![skip-list21](CMU-DBMS-COURSE-08-NOTES/skip-list21.png)\n\n![skip-list22](CMU-DBMS-COURSE-08-NOTES/skip-list22.png)\n\n- 跳表优点\n  - 如果不包含反向指针，则使用的内存比典型的B+树少\n  - 插入和删除不需要重新平衡\n- 跳表缺点\n  - 对磁盘缓存支持不友好，因为它们不优化引用的位置\n  - 反向搜索是很重要的\n\n**基数树 R-Tree**\n\n- 将键表示伟单个数字的组合。这允许线程逐个检查前缀，而不是比较整个密钥\n  - 树的高度取决于key的长度\n  - 不需要重新平衡\n  - 叶节点的路径表示叶节点的键\n  - key是隐式存储的，可以从路径中重建\n\n![r-tree1](CMU-DBMS-COURSE-08-NOTES/r-tree1.png)\n\n![r-tree2](CMU-DBMS-COURSE-08-NOTES/r-tree2.png)\n\n![r-tree3](CMU-DBMS-COURSE-08-NOTES/r-tree3.png)\n\n![r-tree4](CMU-DBMS-COURSE-08-NOTES/r-tree4.png)\n\n![r-tree5](CMU-DBMS-COURSE-08-NOTES/r-tree5.png)\n\n![r-tree6](CMU-DBMS-COURSE-08-NOTES/r-tree6.png)\n\n![r-tree7](CMU-DBMS-COURSE-08-NOTES/r-tree7.png)\n\n![r-tree8](CMU-DBMS-COURSE-08-NOTES/r-tree8.png)\n\n![r-tree9](CMU-DBMS-COURSE-08-NOTES/r-tree9.png)\n\n![r-tree10](CMU-DBMS-COURSE-08-NOTES/r-tree10.png)\n\n![r-tree11](CMU-DBMS-COURSE-08-NOTES/r-tree11.png)\n\n**基数树-二进制可比较的键**\n\n- 并非所有属性类型都可以分解为基数树的二进制可比数字\n  - Unsigned Intehers：对于小端机器，字节顺序必须翻转\n  - Signed Integers：翻转两个补码，使负数小于正数\n  - Floats：分类为组(负与正，规范化与非规范化)，然后存储为无符号整数\n  - Compound：分别变换每个属性\n\n![r-tree-bck1](CMU-DBMS-COURSE-08-NOTES/r-tree-bck1.png)\n\n![r-tree-bck2](CMU-DBMS-COURSE-08-NOTES/r-tree-bck2.png)\n\n![r-tree-bck3](CMU-DBMS-COURSE-08-NOTES/r-tree-bck3.png)\n\n**内存表索引性能比较**\n\n![in-mem-index1](CMU-DBMS-COURSE-08-NOTES/in-mem-index1.png)\n\n**思考**\n\n- 到目前为止，我们讨论过的树索引对于“点”和“范围”查询很有用\n  - 查找15217邮政编码中的所有客户\n  - 查找2018年6月至2018年9月之间的所有订单\n- 它们不擅长关键词搜索\n  - 查找包含“pavlo”一词的所有维基百科文章\n\n**维基百科查询例子**\n\n![wikipadia-example1](CMU-DBMS-COURSE-08-NOTES/wikipadia-example1.png)\n\n- 下面操作并不会帮助到我们的查询\n\n![wikipadia-example2](CMU-DBMS-COURSE-08-NOTES/wikipadia-example2.png)\n\n**倒排索引**\n\n- 倒排索引将单词映射到目标属性中包含这些单词的记录\n  - 有时称为全文搜索索引\n- 支持这个特性的主要数据库有：Solr，elastic search, Sphinx\n\n**查询类型**\n\n- 词组搜索\n  - 查找按给定顺序包含单词列表的记录\n- 临近搜索\n  - 查找两个单词出现在彼此n个单词内的记录\n- 通配符搜索\n  - 查找包含符合某种模式的单词的记录\n\n","slug":"CMU-DBMS-COURSE-08-NOTES","published":1,"updated":"2019-06-26T11:56:34.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvymq000bvkqpsbms8wlb","content":"<p><strong>隐式索引</strong></p>\n<ul>\n<li>大多数DBMS自动创建一个索引来确保完整性约束<ul>\n<li>主键</li>\n<li>唯一约束</li>\n<li>外键</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/implicit-index1.png\" alt=\"implicit-index1\"></p>\n<p><strong>部分索引</strong></p>\n<ul>\n<li>在整个表的子集上创建索引。这可能会减少它的大小和维护它的开销。</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/partial-index1.png\" alt=\"partial-index1\"></p>\n<p><strong>覆盖式索引</strong></p>\n<ul>\n<li>如果处理查询所需的所有字段都在索引中可用，那么DBMS不需要检索元组</li>\n<li>这就减少了对DBMS缓冲池的争用</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/covering-index1.png\" alt=\"covering-index1\"></p>\n<p><strong>索引包含列</strong></p>\n<ul>\n<li>在索引中嵌入其他列以支持仅索引查询，不是搜索键的一部分。</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/index-include1.png\" alt=\"index-include1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/index-include2.png\" alt=\"index-include2\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/index-include3.png\" alt=\"index-include3\"></p>\n<p><strong>函数/表达式索引</strong></p>\n<ul>\n<li>索引不需要以它们在基表中出现的方式存储键</li>\n<li>声明索引时可以使用表达式</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index1.png\" alt=\"functional-index1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index2.png\" alt=\"functional-index2\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index3.png\" alt=\"functional-index3\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index4.png\" alt=\"functional-index4\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index5.png\" alt=\"functional-index5\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index6.png\" alt=\"functional-index6\"></p>\n<p><strong>实现动态顺序索引的最简单的方法是使用已排序的链接列表</strong></p>\n<ul>\n<li><p>所有操作都是线性的搜索，平均开销O(N)</p>\n</li>\n<li><p>优化的方案</p>\n</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/observation1.png\" alt=\"observation1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/observation2.png\" alt=\"observation2\"></p>\n<p><strong>跳跃列表</strong></p>\n<ul>\n<li>具有跳过中间节点的额外指针的多级链接列表</li>\n<li><p>在不需要全局重新平衡的情况下，按排序顺序维护keys</p>\n</li>\n<li><p>不同级别的列表集合</p>\n<ul>\n<li>最低级别是所有键的已排序、单独链接的列表</li>\n<li>第二级每隔一个键连接</li>\n<li>第三级隔4个键连接</li>\n<li>一般来说，一个级别下面有一半的键</li>\n</ul>\n</li>\n<li>要插入新的密钥，翻转coin以决定添加新密钥的级别。提供大致O(log n)搜索时间</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list1.png\" alt=\"skip-list1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list2.png\" alt=\"skip-list2\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list3.png\" alt=\"skip-list3\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list4.png\" alt=\"skip-list4\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list5.png\" alt=\"skip-list5\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list6.png\" alt=\"skip-list6\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list7.png\" alt=\"skip-list7\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list8.png\" alt=\"skip-list8\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list9.png\" alt=\"skip-list9\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list10.png\" alt=\"skip-list10\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list11.png\" alt=\"skip-list11\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list12.png\" alt=\"skip-list12\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list13.png\" alt=\"skip-list13\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list14.png\" alt=\"skip-list14\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list15.png\" alt=\"skip-list15\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list16.png\" alt=\"skip-list16\"></p>\n<p><strong>跳跃链表删除操作</strong></p>\n<ul>\n<li>首先，通过设置一个标志告诉线程忽略，从索引中逻辑地删除一个键</li>\n<li>一旦我们知道没有其他线程持有此引用，就可以物理地删除该键</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list17.png\" alt=\"skip-list17\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list18.png\" alt=\"skip-list18\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list19.png\" alt=\"skip-list19\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list20.png\" alt=\"skip-list20\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list21.png\" alt=\"skip-list21\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list22.png\" alt=\"skip-list22\"></p>\n<ul>\n<li>跳表优点<ul>\n<li>如果不包含反向指针，则使用的内存比典型的B+树少</li>\n<li>插入和删除不需要重新平衡</li>\n</ul>\n</li>\n<li>跳表缺点<ul>\n<li>对磁盘缓存支持不友好，因为它们不优化引用的位置</li>\n<li>反向搜索是很重要的</li>\n</ul>\n</li>\n</ul>\n<p><strong>基数树 R-Tree</strong></p>\n<ul>\n<li>将键表示伟单个数字的组合。这允许线程逐个检查前缀，而不是比较整个密钥<ul>\n<li>树的高度取决于key的长度</li>\n<li>不需要重新平衡</li>\n<li>叶节点的路径表示叶节点的键</li>\n<li>key是隐式存储的，可以从路径中重建</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree1.png\" alt=\"r-tree1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree2.png\" alt=\"r-tree2\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree3.png\" alt=\"r-tree3\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree4.png\" alt=\"r-tree4\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree5.png\" alt=\"r-tree5\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree6.png\" alt=\"r-tree6\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree7.png\" alt=\"r-tree7\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree8.png\" alt=\"r-tree8\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree9.png\" alt=\"r-tree9\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree10.png\" alt=\"r-tree10\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree11.png\" alt=\"r-tree11\"></p>\n<p><strong>基数树-二进制可比较的键</strong></p>\n<ul>\n<li>并非所有属性类型都可以分解为基数树的二进制可比数字<ul>\n<li>Unsigned Intehers：对于小端机器，字节顺序必须翻转</li>\n<li>Signed Integers：翻转两个补码，使负数小于正数</li>\n<li>Floats：分类为组(负与正，规范化与非规范化)，然后存储为无符号整数</li>\n<li>Compound：分别变换每个属性</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree-bck1.png\" alt=\"r-tree-bck1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree-bck2.png\" alt=\"r-tree-bck2\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree-bck3.png\" alt=\"r-tree-bck3\"></p>\n<p><strong>内存表索引性能比较</strong></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/in-mem-index1.png\" alt=\"in-mem-index1\"></p>\n<p><strong>思考</strong></p>\n<ul>\n<li>到目前为止，我们讨论过的树索引对于“点”和“范围”查询很有用<ul>\n<li>查找15217邮政编码中的所有客户</li>\n<li>查找2018年6月至2018年9月之间的所有订单</li>\n</ul>\n</li>\n<li>它们不擅长关键词搜索<ul>\n<li>查找包含“pavlo”一词的所有维基百科文章</li>\n</ul>\n</li>\n</ul>\n<p><strong>维基百科查询例子</strong></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/wikipadia-example1.png\" alt=\"wikipadia-example1\"></p>\n<ul>\n<li>下面操作并不会帮助到我们的查询</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/wikipadia-example2.png\" alt=\"wikipadia-example2\"></p>\n<p><strong>倒排索引</strong></p>\n<ul>\n<li>倒排索引将单词映射到目标属性中包含这些单词的记录<ul>\n<li>有时称为全文搜索索引</li>\n</ul>\n</li>\n<li>支持这个特性的主要数据库有：Solr，elastic search, Sphinx</li>\n</ul>\n<p><strong>查询类型</strong></p>\n<ul>\n<li>词组搜索<ul>\n<li>查找按给定顺序包含单词列表的记录</li>\n</ul>\n</li>\n<li>临近搜索<ul>\n<li>查找两个单词出现在彼此n个单词内的记录</li>\n</ul>\n</li>\n<li>通配符搜索<ul>\n<li>查找包含符合某种模式的单词的记录</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>隐式索引</strong></p>\n<ul>\n<li>大多数DBMS自动创建一个索引来确保完整性约束<ul>\n<li>主键</li>\n<li>唯一约束</li>\n<li>外键</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/implicit-index1.png\" alt=\"implicit-index1\"></p>\n<p><strong>部分索引</strong></p>\n<ul>\n<li>在整个表的子集上创建索引。这可能会减少它的大小和维护它的开销。</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/partial-index1.png\" alt=\"partial-index1\"></p>\n<p><strong>覆盖式索引</strong></p>\n<ul>\n<li>如果处理查询所需的所有字段都在索引中可用，那么DBMS不需要检索元组</li>\n<li>这就减少了对DBMS缓冲池的争用</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/covering-index1.png\" alt=\"covering-index1\"></p>\n<p><strong>索引包含列</strong></p>\n<ul>\n<li>在索引中嵌入其他列以支持仅索引查询，不是搜索键的一部分。</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/index-include1.png\" alt=\"index-include1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/index-include2.png\" alt=\"index-include2\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/index-include3.png\" alt=\"index-include3\"></p>\n<p><strong>函数/表达式索引</strong></p>\n<ul>\n<li>索引不需要以它们在基表中出现的方式存储键</li>\n<li>声明索引时可以使用表达式</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index1.png\" alt=\"functional-index1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index2.png\" alt=\"functional-index2\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index3.png\" alt=\"functional-index3\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index4.png\" alt=\"functional-index4\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index5.png\" alt=\"functional-index5\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/functional-index6.png\" alt=\"functional-index6\"></p>\n<p><strong>实现动态顺序索引的最简单的方法是使用已排序的链接列表</strong></p>\n<ul>\n<li><p>所有操作都是线性的搜索，平均开销O(N)</p>\n</li>\n<li><p>优化的方案</p>\n</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/observation1.png\" alt=\"observation1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/observation2.png\" alt=\"observation2\"></p>\n<p><strong>跳跃列表</strong></p>\n<ul>\n<li>具有跳过中间节点的额外指针的多级链接列表</li>\n<li><p>在不需要全局重新平衡的情况下，按排序顺序维护keys</p>\n</li>\n<li><p>不同级别的列表集合</p>\n<ul>\n<li>最低级别是所有键的已排序、单独链接的列表</li>\n<li>第二级每隔一个键连接</li>\n<li>第三级隔4个键连接</li>\n<li>一般来说，一个级别下面有一半的键</li>\n</ul>\n</li>\n<li>要插入新的密钥，翻转coin以决定添加新密钥的级别。提供大致O(log n)搜索时间</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list1.png\" alt=\"skip-list1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list2.png\" alt=\"skip-list2\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list3.png\" alt=\"skip-list3\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list4.png\" alt=\"skip-list4\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list5.png\" alt=\"skip-list5\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list6.png\" alt=\"skip-list6\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list7.png\" alt=\"skip-list7\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list8.png\" alt=\"skip-list8\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list9.png\" alt=\"skip-list9\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list10.png\" alt=\"skip-list10\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list11.png\" alt=\"skip-list11\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list12.png\" alt=\"skip-list12\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list13.png\" alt=\"skip-list13\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list14.png\" alt=\"skip-list14\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list15.png\" alt=\"skip-list15\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list16.png\" alt=\"skip-list16\"></p>\n<p><strong>跳跃链表删除操作</strong></p>\n<ul>\n<li>首先，通过设置一个标志告诉线程忽略，从索引中逻辑地删除一个键</li>\n<li>一旦我们知道没有其他线程持有此引用，就可以物理地删除该键</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list17.png\" alt=\"skip-list17\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list18.png\" alt=\"skip-list18\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list19.png\" alt=\"skip-list19\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list20.png\" alt=\"skip-list20\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list21.png\" alt=\"skip-list21\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/skip-list22.png\" alt=\"skip-list22\"></p>\n<ul>\n<li>跳表优点<ul>\n<li>如果不包含反向指针，则使用的内存比典型的B+树少</li>\n<li>插入和删除不需要重新平衡</li>\n</ul>\n</li>\n<li>跳表缺点<ul>\n<li>对磁盘缓存支持不友好，因为它们不优化引用的位置</li>\n<li>反向搜索是很重要的</li>\n</ul>\n</li>\n</ul>\n<p><strong>基数树 R-Tree</strong></p>\n<ul>\n<li>将键表示伟单个数字的组合。这允许线程逐个检查前缀，而不是比较整个密钥<ul>\n<li>树的高度取决于key的长度</li>\n<li>不需要重新平衡</li>\n<li>叶节点的路径表示叶节点的键</li>\n<li>key是隐式存储的，可以从路径中重建</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree1.png\" alt=\"r-tree1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree2.png\" alt=\"r-tree2\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree3.png\" alt=\"r-tree3\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree4.png\" alt=\"r-tree4\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree5.png\" alt=\"r-tree5\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree6.png\" alt=\"r-tree6\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree7.png\" alt=\"r-tree7\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree8.png\" alt=\"r-tree8\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree9.png\" alt=\"r-tree9\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree10.png\" alt=\"r-tree10\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree11.png\" alt=\"r-tree11\"></p>\n<p><strong>基数树-二进制可比较的键</strong></p>\n<ul>\n<li>并非所有属性类型都可以分解为基数树的二进制可比数字<ul>\n<li>Unsigned Intehers：对于小端机器，字节顺序必须翻转</li>\n<li>Signed Integers：翻转两个补码，使负数小于正数</li>\n<li>Floats：分类为组(负与正，规范化与非规范化)，然后存储为无符号整数</li>\n<li>Compound：分别变换每个属性</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree-bck1.png\" alt=\"r-tree-bck1\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree-bck2.png\" alt=\"r-tree-bck2\"></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/r-tree-bck3.png\" alt=\"r-tree-bck3\"></p>\n<p><strong>内存表索引性能比较</strong></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/in-mem-index1.png\" alt=\"in-mem-index1\"></p>\n<p><strong>思考</strong></p>\n<ul>\n<li>到目前为止，我们讨论过的树索引对于“点”和“范围”查询很有用<ul>\n<li>查找15217邮政编码中的所有客户</li>\n<li>查找2018年6月至2018年9月之间的所有订单</li>\n</ul>\n</li>\n<li>它们不擅长关键词搜索<ul>\n<li>查找包含“pavlo”一词的所有维基百科文章</li>\n</ul>\n</li>\n</ul>\n<p><strong>维基百科查询例子</strong></p>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/wikipadia-example1.png\" alt=\"wikipadia-example1\"></p>\n<ul>\n<li>下面操作并不会帮助到我们的查询</li>\n</ul>\n<p><img src=\"/2019/04/11/CMU-DBMS-COURSE-08-NOTES/wikipadia-example2.png\" alt=\"wikipadia-example2\"></p>\n<p><strong>倒排索引</strong></p>\n<ul>\n<li>倒排索引将单词映射到目标属性中包含这些单词的记录<ul>\n<li>有时称为全文搜索索引</li>\n</ul>\n</li>\n<li>支持这个特性的主要数据库有：Solr，elastic search, Sphinx</li>\n</ul>\n<p><strong>查询类型</strong></p>\n<ul>\n<li>词组搜索<ul>\n<li>查找按给定顺序包含单词列表的记录</li>\n</ul>\n</li>\n<li>临近搜索<ul>\n<li>查找两个单词出现在彼此n个单词内的记录</li>\n</ul>\n</li>\n<li>通配符搜索<ul>\n<li>查找包含符合某种模式的单词的记录</li>\n</ul>\n</li>\n</ul>\n"},{"title":"CMU-DBMS-COURSE-09-NOTES","date":"2019-04-13T06:53:23.000Z","_content":"\n- 我们假设到目前为止我们讨论的所有数据结构都是单线程的\n- 但是我们需要允许多个线程安全地访问我们的数据结构，以利用额外的CPU核心\n\n**并发控制**\n\n- 并发控制协议是DBMS用来确保共享对象上并发操作产生“正确”结果的方法\n- 协议的正确性标准可能有所不同\n  - 逻辑正确性：我能看到我应该看到的数据吗？\n  - 物理正确性：对象的内部表示是否正确？\n\n**锁 vs 闩**\n\n- 锁\n  - 保护索引的逻辑内容不受其他线程的影响\n  - 确保线程的持久化操作\n  - 需要有能力回滚变化\n- 闩\n  - 保护索引内部数据结构关键部分不受其他线程的影响\n  - 确保操作的持久化\n  - 不需要保证能够回滚变化\n\n|        | Locks(锁)              | Latches(闩)        |\n| ------ | ---------------------- | ------------------ |\n| 区分   | 用户事务               | 线程               |\n| 保护   | 数据库的内容           | 在内存中的数据结构 |\n| 期间   | 整个事务               | 关键部分           |\n| 模式   | 共享、独占、更新、意图 | 读、写             |\n| 死锁   | 检测 & 分辨            | 避开               |\n| 通过   | 等待，超时，中断       | 专业的编码         |\n| 保存在 | 锁管理器               | 被保护的数据结构中 |\n\n**闩锁模式**\n\n- 读模式\n  - 允许多个线程在同一时刻读取同一个项目\n  - 一个线程可以获得读闩锁，当另一个线程也在读模式\n- 写模式\n  - 只有一个线程允许访问项目\n  - 当宁一个线程获得一把任意模式的闩锁时，一个线程不能获得一把写闩锁\n\n**B+树并发控制**\n\n- 我们希望允许多个线程同时读和更新B+树索引\n- 我们需要避免两类问题\n  - 试图同时修改节点内容的多个线程\n  - 一个线程遍历树，另一个线程拆分/合并解节点\n\n![muti-thr1](CMU-DBMS-COURSE-09-NOTES/muti-thr1.png)\n\n![muti-thr2](CMU-DBMS-COURSE-09-NOTES/muti-thr2.png)\n\n![muti-thr3](CMU-DBMS-COURSE-09-NOTES/muti-thr3.png)\n\n![muti-thr4](CMU-DBMS-COURSE-09-NOTES/muti-thr4.png)\n\n![muti-thr5](CMU-DBMS-COURSE-09-NOTES/muti-thr5.png)\n\n![muti-thr6](CMU-DBMS-COURSE-09-NOTES/muti-thr6.png)\n\n![muti-thr7](CMU-DBMS-COURSE-09-NOTES/muti-thr7.png)\n\n- 协议允许多线程同时访问和修改B+树\n- 基本的idea\n  - 为父节点获取闩锁\n  - 为子节点获取闩锁\n  - 如果父节点安全，释放闩锁\n- 一个安全的节点是更新时不会拆分或合并的节点\n  - 没有满（插入操作的时候）\n  - 超过一半满（删除操作的时候）\n- 搜索：从根开始向下，反复\n  - 为子节点获取读锁\n  - 然后释放父节点的读锁\n- 插入/删除：从根部开始向下，根据需要获得读锁。一旦子节点被锁上，检查它是否安全\n  - 如果子节点安全，释放祖先节点多有的锁\n\n![latch1](CMU-DBMS-COURSE-09-NOTES/latch1.png)\n\n![latch2](CMU-DBMS-COURSE-09-NOTES/latch2.png)\n\n![latch3](CMU-DBMS-COURSE-09-NOTES/latch3.png)\n\n![latch4](CMU-DBMS-COURSE-09-NOTES/latch4.png)\n\n![latch5](CMU-DBMS-COURSE-09-NOTES/latch5.png)\n\n![latch6](CMU-DBMS-COURSE-09-NOTES/latch6.png)\n\n![latch7](CMU-DBMS-COURSE-09-NOTES/latch7.png)\n\n![latch8](CMU-DBMS-COURSE-09-NOTES/latch8.png)![latch9](CMU-DBMS-COURSE-09-NOTES/latch9.png)\n\n![latch10](CMU-DBMS-COURSE-09-NOTES/latch10.png)\n\n![latch11](CMU-DBMS-COURSE-09-NOTES/latch11.png)\n\n![latch12](CMU-DBMS-COURSE-09-NOTES/latch12.png)\n\n![latch13](CMU-DBMS-COURSE-09-NOTES/latch13.png)\n\n![latch14](CMU-DBMS-COURSE-09-NOTES/latch14.png)\n\n![latch15](CMU-DBMS-COURSE-09-NOTES/latch15.png)\n\n![latch16](CMU-DBMS-COURSE-09-NOTES/latch16.png)\n\n![latch17](CMU-DBMS-COURSE-09-NOTES/latch17.png)\n\n![latch18](CMU-DBMS-COURSE-09-NOTES/latch18.png)\n\n![latch19](CMU-DBMS-COURSE-09-NOTES/latch19.png)\n\n![latch20](CMU-DBMS-COURSE-09-NOTES/latch20.png)\n\n![latch21](CMU-DBMS-COURSE-09-NOTES/latch21.png)\n\n![latch22](CMU-DBMS-COURSE-09-NOTES/latch22.png)![latch23](CMU-DBMS-COURSE-09-NOTES/latch23.png)\n\n\n\n![latch24](CMU-DBMS-COURSE-09-NOTES/latch24.png)\n\n![latch25](CMU-DBMS-COURSE-09-NOTES/latch25.png)\n\n**思考**\n\n- 下面这个示例，哪个是第一个针对B+树要执行的更新操作?\n\n![observation1](CMU-DBMS-COURSE-09-NOTES/observation1.png)\n\n- 每次在根上执行的写锁操作都会成为高并发的性能瓶颈\n\n**更好的加锁算法**\n\n- 假设叶节点是安全的\n- 使用读闩锁抵达到它，并验证它是否安全\n- 如果叶节点不安全，用读锁执行先前的算法\n\n![better1](CMU-DBMS-COURSE-09-NOTES/better1.png)\n\n![better2](CMU-DBMS-COURSE-09-NOTES/better2.png)\n\n![better3](CMU-DBMS-COURSE-09-NOTES/better3.png)\n\n![better4](CMU-DBMS-COURSE-09-NOTES/better4.png)\n\n![better5](CMU-DBMS-COURSE-09-NOTES/better5.png)\n\n![better6](CMU-DBMS-COURSE-09-NOTES/better6.png)\n\n![better7](CMU-DBMS-COURSE-09-NOTES/better7.png)\n\n![better8](CMU-DBMS-COURSE-09-NOTES/better8.png)\n\n- 搜索：和前面的算法一样\n- 插入/删除\n  - 像搜索一样设置闩锁，抵达叶节点，并在叶节点上设置写闩锁\n  - 如果叶节点的操作不安全，释放所有闩锁，然后使用具有写闩锁的插入/删除的协议重新启动线程\n\n- 这种方法乐观的假定只修改叶节点；否则，在第一次传递到叶节点时设置的读锁是浪费的\n\n- 到目前为止，所有示例中的线程都以“从上而下”的方式获得了锁存\n  - 线程只能从低于其当前节点的节点获取闩锁\n  - 如果所需的闩锁不可用，则线程必须等到它可用为止\n  - 但是如果我们想从一个叶节点移动到另一个叶节点呢\n\n**叶节点扫描**\n\n![leaf-node-scan1](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan1.png)\n\n![leaf-node-scan2](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan2.png)\n\n![leaf-node-scan3](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan3.png)\n\n![leaf-node-scan4](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan4.png)\n\n![leaf-node-scan5](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan5.png)\n\n![leaf-node-scan6](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan6.png)\n\n![leaf-node-scan7](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan7.png)\n\n![leaf-node-scan8](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan8.png)\n\n![leaf-node-scan9](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan9.png)\n\n![leaf-node-scan10](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan10.png)\n\n![leaf-node-scan11](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan11.png)\n\n![leaf-node-scan12](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan12.png)\n\n![leaf-node-scan13](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan13.png)\n\n![leaf-node-scan14](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan14.png)\n\n![leaf-node-scan15](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan15.png)\n\n- 闩锁不支持死锁检测和避免，我们唯一能解决这个问题的方法是通过编码规则\n- 叶节点同级闩锁采集协议必须支持“无等待”模式，B+树代码必须处理失败的锁存采集\n\n**延迟父节点更新**\n\n- 每当一个叶子节点溢出时，我们必须至少更新三个节点\n  - 正在拆分的叶节点\n  - 新创建的叶节点\n  - 父节点\n- B link - 树优化：当一个叶节点溢出时，延迟父节点的更新操作\n\n![delay-parent1](CMU-DBMS-COURSE-09-NOTES/delay-parent1.png)\n\n![delay-parent2](CMU-DBMS-COURSE-09-NOTES/delay-parent2.png)\n\n![delay-parent3](CMU-DBMS-COURSE-09-NOTES/delay-parent3.png)\n\n![delay-parent4](CMU-DBMS-COURSE-09-NOTES/delay-parent4.png)\n\n![delay-parent5](CMU-DBMS-COURSE-09-NOTES/delay-parent5.png)\n\n![delay-parent6](CMU-DBMS-COURSE-09-NOTES/delay-parent6.png)\n\n![delay-parent7](CMU-DBMS-COURSE-09-NOTES/delay-parent7.png)\n\n![delay-parent8](CMU-DBMS-COURSE-09-NOTES/delay-parent8.png)\n\n![delay-parent9](CMU-DBMS-COURSE-09-NOTES/delay-parent9.png)\n\n![delay-parent10](CMU-DBMS-COURSE-09-NOTES/delay-parent10.png)\n\n**结论**\n\n- 使一个数据结构线程安全似乎很容易理解，但在实践中缺非常困难\n- 我们关注的是B+树，但同样高级技术叶适用于其他的数据结构\n\n","source":"_posts/CMU-DBMS-COURSE-09-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-09-NOTES\ndate: 2019-04-13 14:53:23\ntags:\n---\n\n- 我们假设到目前为止我们讨论的所有数据结构都是单线程的\n- 但是我们需要允许多个线程安全地访问我们的数据结构，以利用额外的CPU核心\n\n**并发控制**\n\n- 并发控制协议是DBMS用来确保共享对象上并发操作产生“正确”结果的方法\n- 协议的正确性标准可能有所不同\n  - 逻辑正确性：我能看到我应该看到的数据吗？\n  - 物理正确性：对象的内部表示是否正确？\n\n**锁 vs 闩**\n\n- 锁\n  - 保护索引的逻辑内容不受其他线程的影响\n  - 确保线程的持久化操作\n  - 需要有能力回滚变化\n- 闩\n  - 保护索引内部数据结构关键部分不受其他线程的影响\n  - 确保操作的持久化\n  - 不需要保证能够回滚变化\n\n|        | Locks(锁)              | Latches(闩)        |\n| ------ | ---------------------- | ------------------ |\n| 区分   | 用户事务               | 线程               |\n| 保护   | 数据库的内容           | 在内存中的数据结构 |\n| 期间   | 整个事务               | 关键部分           |\n| 模式   | 共享、独占、更新、意图 | 读、写             |\n| 死锁   | 检测 & 分辨            | 避开               |\n| 通过   | 等待，超时，中断       | 专业的编码         |\n| 保存在 | 锁管理器               | 被保护的数据结构中 |\n\n**闩锁模式**\n\n- 读模式\n  - 允许多个线程在同一时刻读取同一个项目\n  - 一个线程可以获得读闩锁，当另一个线程也在读模式\n- 写模式\n  - 只有一个线程允许访问项目\n  - 当宁一个线程获得一把任意模式的闩锁时，一个线程不能获得一把写闩锁\n\n**B+树并发控制**\n\n- 我们希望允许多个线程同时读和更新B+树索引\n- 我们需要避免两类问题\n  - 试图同时修改节点内容的多个线程\n  - 一个线程遍历树，另一个线程拆分/合并解节点\n\n![muti-thr1](CMU-DBMS-COURSE-09-NOTES/muti-thr1.png)\n\n![muti-thr2](CMU-DBMS-COURSE-09-NOTES/muti-thr2.png)\n\n![muti-thr3](CMU-DBMS-COURSE-09-NOTES/muti-thr3.png)\n\n![muti-thr4](CMU-DBMS-COURSE-09-NOTES/muti-thr4.png)\n\n![muti-thr5](CMU-DBMS-COURSE-09-NOTES/muti-thr5.png)\n\n![muti-thr6](CMU-DBMS-COURSE-09-NOTES/muti-thr6.png)\n\n![muti-thr7](CMU-DBMS-COURSE-09-NOTES/muti-thr7.png)\n\n- 协议允许多线程同时访问和修改B+树\n- 基本的idea\n  - 为父节点获取闩锁\n  - 为子节点获取闩锁\n  - 如果父节点安全，释放闩锁\n- 一个安全的节点是更新时不会拆分或合并的节点\n  - 没有满（插入操作的时候）\n  - 超过一半满（删除操作的时候）\n- 搜索：从根开始向下，反复\n  - 为子节点获取读锁\n  - 然后释放父节点的读锁\n- 插入/删除：从根部开始向下，根据需要获得读锁。一旦子节点被锁上，检查它是否安全\n  - 如果子节点安全，释放祖先节点多有的锁\n\n![latch1](CMU-DBMS-COURSE-09-NOTES/latch1.png)\n\n![latch2](CMU-DBMS-COURSE-09-NOTES/latch2.png)\n\n![latch3](CMU-DBMS-COURSE-09-NOTES/latch3.png)\n\n![latch4](CMU-DBMS-COURSE-09-NOTES/latch4.png)\n\n![latch5](CMU-DBMS-COURSE-09-NOTES/latch5.png)\n\n![latch6](CMU-DBMS-COURSE-09-NOTES/latch6.png)\n\n![latch7](CMU-DBMS-COURSE-09-NOTES/latch7.png)\n\n![latch8](CMU-DBMS-COURSE-09-NOTES/latch8.png)![latch9](CMU-DBMS-COURSE-09-NOTES/latch9.png)\n\n![latch10](CMU-DBMS-COURSE-09-NOTES/latch10.png)\n\n![latch11](CMU-DBMS-COURSE-09-NOTES/latch11.png)\n\n![latch12](CMU-DBMS-COURSE-09-NOTES/latch12.png)\n\n![latch13](CMU-DBMS-COURSE-09-NOTES/latch13.png)\n\n![latch14](CMU-DBMS-COURSE-09-NOTES/latch14.png)\n\n![latch15](CMU-DBMS-COURSE-09-NOTES/latch15.png)\n\n![latch16](CMU-DBMS-COURSE-09-NOTES/latch16.png)\n\n![latch17](CMU-DBMS-COURSE-09-NOTES/latch17.png)\n\n![latch18](CMU-DBMS-COURSE-09-NOTES/latch18.png)\n\n![latch19](CMU-DBMS-COURSE-09-NOTES/latch19.png)\n\n![latch20](CMU-DBMS-COURSE-09-NOTES/latch20.png)\n\n![latch21](CMU-DBMS-COURSE-09-NOTES/latch21.png)\n\n![latch22](CMU-DBMS-COURSE-09-NOTES/latch22.png)![latch23](CMU-DBMS-COURSE-09-NOTES/latch23.png)\n\n\n\n![latch24](CMU-DBMS-COURSE-09-NOTES/latch24.png)\n\n![latch25](CMU-DBMS-COURSE-09-NOTES/latch25.png)\n\n**思考**\n\n- 下面这个示例，哪个是第一个针对B+树要执行的更新操作?\n\n![observation1](CMU-DBMS-COURSE-09-NOTES/observation1.png)\n\n- 每次在根上执行的写锁操作都会成为高并发的性能瓶颈\n\n**更好的加锁算法**\n\n- 假设叶节点是安全的\n- 使用读闩锁抵达到它，并验证它是否安全\n- 如果叶节点不安全，用读锁执行先前的算法\n\n![better1](CMU-DBMS-COURSE-09-NOTES/better1.png)\n\n![better2](CMU-DBMS-COURSE-09-NOTES/better2.png)\n\n![better3](CMU-DBMS-COURSE-09-NOTES/better3.png)\n\n![better4](CMU-DBMS-COURSE-09-NOTES/better4.png)\n\n![better5](CMU-DBMS-COURSE-09-NOTES/better5.png)\n\n![better6](CMU-DBMS-COURSE-09-NOTES/better6.png)\n\n![better7](CMU-DBMS-COURSE-09-NOTES/better7.png)\n\n![better8](CMU-DBMS-COURSE-09-NOTES/better8.png)\n\n- 搜索：和前面的算法一样\n- 插入/删除\n  - 像搜索一样设置闩锁，抵达叶节点，并在叶节点上设置写闩锁\n  - 如果叶节点的操作不安全，释放所有闩锁，然后使用具有写闩锁的插入/删除的协议重新启动线程\n\n- 这种方法乐观的假定只修改叶节点；否则，在第一次传递到叶节点时设置的读锁是浪费的\n\n- 到目前为止，所有示例中的线程都以“从上而下”的方式获得了锁存\n  - 线程只能从低于其当前节点的节点获取闩锁\n  - 如果所需的闩锁不可用，则线程必须等到它可用为止\n  - 但是如果我们想从一个叶节点移动到另一个叶节点呢\n\n**叶节点扫描**\n\n![leaf-node-scan1](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan1.png)\n\n![leaf-node-scan2](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan2.png)\n\n![leaf-node-scan3](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan3.png)\n\n![leaf-node-scan4](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan4.png)\n\n![leaf-node-scan5](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan5.png)\n\n![leaf-node-scan6](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan6.png)\n\n![leaf-node-scan7](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan7.png)\n\n![leaf-node-scan8](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan8.png)\n\n![leaf-node-scan9](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan9.png)\n\n![leaf-node-scan10](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan10.png)\n\n![leaf-node-scan11](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan11.png)\n\n![leaf-node-scan12](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan12.png)\n\n![leaf-node-scan13](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan13.png)\n\n![leaf-node-scan14](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan14.png)\n\n![leaf-node-scan15](CMU-DBMS-COURSE-09-NOTES/leaf-node-scan15.png)\n\n- 闩锁不支持死锁检测和避免，我们唯一能解决这个问题的方法是通过编码规则\n- 叶节点同级闩锁采集协议必须支持“无等待”模式，B+树代码必须处理失败的锁存采集\n\n**延迟父节点更新**\n\n- 每当一个叶子节点溢出时，我们必须至少更新三个节点\n  - 正在拆分的叶节点\n  - 新创建的叶节点\n  - 父节点\n- B link - 树优化：当一个叶节点溢出时，延迟父节点的更新操作\n\n![delay-parent1](CMU-DBMS-COURSE-09-NOTES/delay-parent1.png)\n\n![delay-parent2](CMU-DBMS-COURSE-09-NOTES/delay-parent2.png)\n\n![delay-parent3](CMU-DBMS-COURSE-09-NOTES/delay-parent3.png)\n\n![delay-parent4](CMU-DBMS-COURSE-09-NOTES/delay-parent4.png)\n\n![delay-parent5](CMU-DBMS-COURSE-09-NOTES/delay-parent5.png)\n\n![delay-parent6](CMU-DBMS-COURSE-09-NOTES/delay-parent6.png)\n\n![delay-parent7](CMU-DBMS-COURSE-09-NOTES/delay-parent7.png)\n\n![delay-parent8](CMU-DBMS-COURSE-09-NOTES/delay-parent8.png)\n\n![delay-parent9](CMU-DBMS-COURSE-09-NOTES/delay-parent9.png)\n\n![delay-parent10](CMU-DBMS-COURSE-09-NOTES/delay-parent10.png)\n\n**结论**\n\n- 使一个数据结构线程安全似乎很容易理解，但在实践中缺非常困难\n- 我们关注的是B+树，但同样高级技术叶适用于其他的数据结构\n\n","slug":"CMU-DBMS-COURSE-09-NOTES","published":1,"updated":"2019-06-26T11:56:34.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvymu000cvkqpkd5m0j1k","content":"<ul>\n<li>我们假设到目前为止我们讨论的所有数据结构都是单线程的</li>\n<li>但是我们需要允许多个线程安全地访问我们的数据结构，以利用额外的CPU核心</li>\n</ul>\n<p><strong>并发控制</strong></p>\n<ul>\n<li>并发控制协议是DBMS用来确保共享对象上并发操作产生“正确”结果的方法</li>\n<li>协议的正确性标准可能有所不同<ul>\n<li>逻辑正确性：我能看到我应该看到的数据吗？</li>\n<li>物理正确性：对象的内部表示是否正确？</li>\n</ul>\n</li>\n</ul>\n<p><strong>锁 vs 闩</strong></p>\n<ul>\n<li>锁<ul>\n<li>保护索引的逻辑内容不受其他线程的影响</li>\n<li>确保线程的持久化操作</li>\n<li>需要有能力回滚变化</li>\n</ul>\n</li>\n<li>闩<ul>\n<li>保护索引内部数据结构关键部分不受其他线程的影响</li>\n<li>确保操作的持久化</li>\n<li>不需要保证能够回滚变化</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Locks(锁)</th>\n<th>Latches(闩)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>区分</td>\n<td>用户事务</td>\n<td>线程</td>\n</tr>\n<tr>\n<td>保护</td>\n<td>数据库的内容</td>\n<td>在内存中的数据结构</td>\n</tr>\n<tr>\n<td>期间</td>\n<td>整个事务</td>\n<td>关键部分</td>\n</tr>\n<tr>\n<td>模式</td>\n<td>共享、独占、更新、意图</td>\n<td>读、写</td>\n</tr>\n<tr>\n<td>死锁</td>\n<td>检测 &amp; 分辨</td>\n<td>避开</td>\n</tr>\n<tr>\n<td>通过</td>\n<td>等待，超时，中断</td>\n<td>专业的编码</td>\n</tr>\n<tr>\n<td>保存在</td>\n<td>锁管理器</td>\n<td>被保护的数据结构中</td>\n</tr>\n</tbody>\n</table>\n<p><strong>闩锁模式</strong></p>\n<ul>\n<li>读模式<ul>\n<li>允许多个线程在同一时刻读取同一个项目</li>\n<li>一个线程可以获得读闩锁，当另一个线程也在读模式</li>\n</ul>\n</li>\n<li>写模式<ul>\n<li>只有一个线程允许访问项目</li>\n<li>当宁一个线程获得一把任意模式的闩锁时，一个线程不能获得一把写闩锁</li>\n</ul>\n</li>\n</ul>\n<p><strong>B+树并发控制</strong></p>\n<ul>\n<li>我们希望允许多个线程同时读和更新B+树索引</li>\n<li>我们需要避免两类问题<ul>\n<li>试图同时修改节点内容的多个线程</li>\n<li>一个线程遍历树，另一个线程拆分/合并解节点</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr1.png\" alt=\"muti-thr1\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr2.png\" alt=\"muti-thr2\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr3.png\" alt=\"muti-thr3\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr4.png\" alt=\"muti-thr4\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr5.png\" alt=\"muti-thr5\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr6.png\" alt=\"muti-thr6\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr7.png\" alt=\"muti-thr7\"></p>\n<ul>\n<li>协议允许多线程同时访问和修改B+树</li>\n<li>基本的idea<ul>\n<li>为父节点获取闩锁</li>\n<li>为子节点获取闩锁</li>\n<li>如果父节点安全，释放闩锁</li>\n</ul>\n</li>\n<li>一个安全的节点是更新时不会拆分或合并的节点<ul>\n<li>没有满（插入操作的时候）</li>\n<li>超过一半满（删除操作的时候）</li>\n</ul>\n</li>\n<li>搜索：从根开始向下，反复<ul>\n<li>为子节点获取读锁</li>\n<li>然后释放父节点的读锁</li>\n</ul>\n</li>\n<li>插入/删除：从根部开始向下，根据需要获得读锁。一旦子节点被锁上，检查它是否安全<ul>\n<li>如果子节点安全，释放祖先节点多有的锁</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch1.png\" alt=\"latch1\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch2.png\" alt=\"latch2\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch3.png\" alt=\"latch3\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch4.png\" alt=\"latch4\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch5.png\" alt=\"latch5\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch6.png\" alt=\"latch6\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch7.png\" alt=\"latch7\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch8.png\" alt=\"latch8\"><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch9.png\" alt=\"latch9\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch10.png\" alt=\"latch10\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch11.png\" alt=\"latch11\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch12.png\" alt=\"latch12\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch13.png\" alt=\"latch13\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch14.png\" alt=\"latch14\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch15.png\" alt=\"latch15\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch16.png\" alt=\"latch16\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch17.png\" alt=\"latch17\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch18.png\" alt=\"latch18\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch19.png\" alt=\"latch19\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch20.png\" alt=\"latch20\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch21.png\" alt=\"latch21\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch22.png\" alt=\"latch22\"><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch23.png\" alt=\"latch23\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch24.png\" alt=\"latch24\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch25.png\" alt=\"latch25\"></p>\n<p><strong>思考</strong></p>\n<ul>\n<li>下面这个示例，哪个是第一个针对B+树要执行的更新操作?</li>\n</ul>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/observation1.png\" alt=\"observation1\"></p>\n<ul>\n<li>每次在根上执行的写锁操作都会成为高并发的性能瓶颈</li>\n</ul>\n<p><strong>更好的加锁算法</strong></p>\n<ul>\n<li>假设叶节点是安全的</li>\n<li>使用读闩锁抵达到它，并验证它是否安全</li>\n<li>如果叶节点不安全，用读锁执行先前的算法</li>\n</ul>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better1.png\" alt=\"better1\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better2.png\" alt=\"better2\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better3.png\" alt=\"better3\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better4.png\" alt=\"better4\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better5.png\" alt=\"better5\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better6.png\" alt=\"better6\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better7.png\" alt=\"better7\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better8.png\" alt=\"better8\"></p>\n<ul>\n<li>搜索：和前面的算法一样</li>\n<li><p>插入/删除</p>\n<ul>\n<li>像搜索一样设置闩锁，抵达叶节点，并在叶节点上设置写闩锁</li>\n<li>如果叶节点的操作不安全，释放所有闩锁，然后使用具有写闩锁的插入/删除的协议重新启动线程</li>\n</ul>\n</li>\n<li><p>这种方法乐观的假定只修改叶节点；否则，在第一次传递到叶节点时设置的读锁是浪费的</p>\n</li>\n<li><p>到目前为止，所有示例中的线程都以“从上而下”的方式获得了锁存</p>\n<ul>\n<li>线程只能从低于其当前节点的节点获取闩锁</li>\n<li>如果所需的闩锁不可用，则线程必须等到它可用为止</li>\n<li>但是如果我们想从一个叶节点移动到另一个叶节点呢</li>\n</ul>\n</li>\n</ul>\n<p><strong>叶节点扫描</strong></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan1.png\" alt=\"leaf-node-scan1\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan2.png\" alt=\"leaf-node-scan2\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan3.png\" alt=\"leaf-node-scan3\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan4.png\" alt=\"leaf-node-scan4\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan5.png\" alt=\"leaf-node-scan5\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan6.png\" alt=\"leaf-node-scan6\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan7.png\" alt=\"leaf-node-scan7\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan8.png\" alt=\"leaf-node-scan8\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan9.png\" alt=\"leaf-node-scan9\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan10.png\" alt=\"leaf-node-scan10\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan11.png\" alt=\"leaf-node-scan11\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan12.png\" alt=\"leaf-node-scan12\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan13.png\" alt=\"leaf-node-scan13\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan14.png\" alt=\"leaf-node-scan14\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan15.png\" alt=\"leaf-node-scan15\"></p>\n<ul>\n<li>闩锁不支持死锁检测和避免，我们唯一能解决这个问题的方法是通过编码规则</li>\n<li>叶节点同级闩锁采集协议必须支持“无等待”模式，B+树代码必须处理失败的锁存采集</li>\n</ul>\n<p><strong>延迟父节点更新</strong></p>\n<ul>\n<li>每当一个叶子节点溢出时，我们必须至少更新三个节点<ul>\n<li>正在拆分的叶节点</li>\n<li>新创建的叶节点</li>\n<li>父节点</li>\n</ul>\n</li>\n<li>B link - 树优化：当一个叶节点溢出时，延迟父节点的更新操作</li>\n</ul>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent1.png\" alt=\"delay-parent1\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent2.png\" alt=\"delay-parent2\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent3.png\" alt=\"delay-parent3\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent4.png\" alt=\"delay-parent4\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent5.png\" alt=\"delay-parent5\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent6.png\" alt=\"delay-parent6\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent7.png\" alt=\"delay-parent7\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent8.png\" alt=\"delay-parent8\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent9.png\" alt=\"delay-parent9\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent10.png\" alt=\"delay-parent10\"></p>\n<p><strong>结论</strong></p>\n<ul>\n<li>使一个数据结构线程安全似乎很容易理解，但在实践中缺非常困难</li>\n<li>我们关注的是B+树，但同样高级技术叶适用于其他的数据结构</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>我们假设到目前为止我们讨论的所有数据结构都是单线程的</li>\n<li>但是我们需要允许多个线程安全地访问我们的数据结构，以利用额外的CPU核心</li>\n</ul>\n<p><strong>并发控制</strong></p>\n<ul>\n<li>并发控制协议是DBMS用来确保共享对象上并发操作产生“正确”结果的方法</li>\n<li>协议的正确性标准可能有所不同<ul>\n<li>逻辑正确性：我能看到我应该看到的数据吗？</li>\n<li>物理正确性：对象的内部表示是否正确？</li>\n</ul>\n</li>\n</ul>\n<p><strong>锁 vs 闩</strong></p>\n<ul>\n<li>锁<ul>\n<li>保护索引的逻辑内容不受其他线程的影响</li>\n<li>确保线程的持久化操作</li>\n<li>需要有能力回滚变化</li>\n</ul>\n</li>\n<li>闩<ul>\n<li>保护索引内部数据结构关键部分不受其他线程的影响</li>\n<li>确保操作的持久化</li>\n<li>不需要保证能够回滚变化</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Locks(锁)</th>\n<th>Latches(闩)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>区分</td>\n<td>用户事务</td>\n<td>线程</td>\n</tr>\n<tr>\n<td>保护</td>\n<td>数据库的内容</td>\n<td>在内存中的数据结构</td>\n</tr>\n<tr>\n<td>期间</td>\n<td>整个事务</td>\n<td>关键部分</td>\n</tr>\n<tr>\n<td>模式</td>\n<td>共享、独占、更新、意图</td>\n<td>读、写</td>\n</tr>\n<tr>\n<td>死锁</td>\n<td>检测 &amp; 分辨</td>\n<td>避开</td>\n</tr>\n<tr>\n<td>通过</td>\n<td>等待，超时，中断</td>\n<td>专业的编码</td>\n</tr>\n<tr>\n<td>保存在</td>\n<td>锁管理器</td>\n<td>被保护的数据结构中</td>\n</tr>\n</tbody>\n</table>\n<p><strong>闩锁模式</strong></p>\n<ul>\n<li>读模式<ul>\n<li>允许多个线程在同一时刻读取同一个项目</li>\n<li>一个线程可以获得读闩锁，当另一个线程也在读模式</li>\n</ul>\n</li>\n<li>写模式<ul>\n<li>只有一个线程允许访问项目</li>\n<li>当宁一个线程获得一把任意模式的闩锁时，一个线程不能获得一把写闩锁</li>\n</ul>\n</li>\n</ul>\n<p><strong>B+树并发控制</strong></p>\n<ul>\n<li>我们希望允许多个线程同时读和更新B+树索引</li>\n<li>我们需要避免两类问题<ul>\n<li>试图同时修改节点内容的多个线程</li>\n<li>一个线程遍历树，另一个线程拆分/合并解节点</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr1.png\" alt=\"muti-thr1\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr2.png\" alt=\"muti-thr2\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr3.png\" alt=\"muti-thr3\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr4.png\" alt=\"muti-thr4\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr5.png\" alt=\"muti-thr5\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr6.png\" alt=\"muti-thr6\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/muti-thr7.png\" alt=\"muti-thr7\"></p>\n<ul>\n<li>协议允许多线程同时访问和修改B+树</li>\n<li>基本的idea<ul>\n<li>为父节点获取闩锁</li>\n<li>为子节点获取闩锁</li>\n<li>如果父节点安全，释放闩锁</li>\n</ul>\n</li>\n<li>一个安全的节点是更新时不会拆分或合并的节点<ul>\n<li>没有满（插入操作的时候）</li>\n<li>超过一半满（删除操作的时候）</li>\n</ul>\n</li>\n<li>搜索：从根开始向下，反复<ul>\n<li>为子节点获取读锁</li>\n<li>然后释放父节点的读锁</li>\n</ul>\n</li>\n<li>插入/删除：从根部开始向下，根据需要获得读锁。一旦子节点被锁上，检查它是否安全<ul>\n<li>如果子节点安全，释放祖先节点多有的锁</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch1.png\" alt=\"latch1\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch2.png\" alt=\"latch2\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch3.png\" alt=\"latch3\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch4.png\" alt=\"latch4\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch5.png\" alt=\"latch5\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch6.png\" alt=\"latch6\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch7.png\" alt=\"latch7\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch8.png\" alt=\"latch8\"><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch9.png\" alt=\"latch9\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch10.png\" alt=\"latch10\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch11.png\" alt=\"latch11\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch12.png\" alt=\"latch12\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch13.png\" alt=\"latch13\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch14.png\" alt=\"latch14\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch15.png\" alt=\"latch15\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch16.png\" alt=\"latch16\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch17.png\" alt=\"latch17\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch18.png\" alt=\"latch18\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch19.png\" alt=\"latch19\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch20.png\" alt=\"latch20\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch21.png\" alt=\"latch21\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch22.png\" alt=\"latch22\"><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch23.png\" alt=\"latch23\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch24.png\" alt=\"latch24\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/latch25.png\" alt=\"latch25\"></p>\n<p><strong>思考</strong></p>\n<ul>\n<li>下面这个示例，哪个是第一个针对B+树要执行的更新操作?</li>\n</ul>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/observation1.png\" alt=\"observation1\"></p>\n<ul>\n<li>每次在根上执行的写锁操作都会成为高并发的性能瓶颈</li>\n</ul>\n<p><strong>更好的加锁算法</strong></p>\n<ul>\n<li>假设叶节点是安全的</li>\n<li>使用读闩锁抵达到它，并验证它是否安全</li>\n<li>如果叶节点不安全，用读锁执行先前的算法</li>\n</ul>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better1.png\" alt=\"better1\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better2.png\" alt=\"better2\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better3.png\" alt=\"better3\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better4.png\" alt=\"better4\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better5.png\" alt=\"better5\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better6.png\" alt=\"better6\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better7.png\" alt=\"better7\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/better8.png\" alt=\"better8\"></p>\n<ul>\n<li>搜索：和前面的算法一样</li>\n<li><p>插入/删除</p>\n<ul>\n<li>像搜索一样设置闩锁，抵达叶节点，并在叶节点上设置写闩锁</li>\n<li>如果叶节点的操作不安全，释放所有闩锁，然后使用具有写闩锁的插入/删除的协议重新启动线程</li>\n</ul>\n</li>\n<li><p>这种方法乐观的假定只修改叶节点；否则，在第一次传递到叶节点时设置的读锁是浪费的</p>\n</li>\n<li><p>到目前为止，所有示例中的线程都以“从上而下”的方式获得了锁存</p>\n<ul>\n<li>线程只能从低于其当前节点的节点获取闩锁</li>\n<li>如果所需的闩锁不可用，则线程必须等到它可用为止</li>\n<li>但是如果我们想从一个叶节点移动到另一个叶节点呢</li>\n</ul>\n</li>\n</ul>\n<p><strong>叶节点扫描</strong></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan1.png\" alt=\"leaf-node-scan1\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan2.png\" alt=\"leaf-node-scan2\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan3.png\" alt=\"leaf-node-scan3\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan4.png\" alt=\"leaf-node-scan4\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan5.png\" alt=\"leaf-node-scan5\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan6.png\" alt=\"leaf-node-scan6\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan7.png\" alt=\"leaf-node-scan7\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan8.png\" alt=\"leaf-node-scan8\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan9.png\" alt=\"leaf-node-scan9\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan10.png\" alt=\"leaf-node-scan10\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan11.png\" alt=\"leaf-node-scan11\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan12.png\" alt=\"leaf-node-scan12\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan13.png\" alt=\"leaf-node-scan13\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan14.png\" alt=\"leaf-node-scan14\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan15.png\" alt=\"leaf-node-scan15\"></p>\n<ul>\n<li>闩锁不支持死锁检测和避免，我们唯一能解决这个问题的方法是通过编码规则</li>\n<li>叶节点同级闩锁采集协议必须支持“无等待”模式，B+树代码必须处理失败的锁存采集</li>\n</ul>\n<p><strong>延迟父节点更新</strong></p>\n<ul>\n<li>每当一个叶子节点溢出时，我们必须至少更新三个节点<ul>\n<li>正在拆分的叶节点</li>\n<li>新创建的叶节点</li>\n<li>父节点</li>\n</ul>\n</li>\n<li>B link - 树优化：当一个叶节点溢出时，延迟父节点的更新操作</li>\n</ul>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent1.png\" alt=\"delay-parent1\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent2.png\" alt=\"delay-parent2\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent3.png\" alt=\"delay-parent3\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent4.png\" alt=\"delay-parent4\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent5.png\" alt=\"delay-parent5\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent6.png\" alt=\"delay-parent6\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent7.png\" alt=\"delay-parent7\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent8.png\" alt=\"delay-parent8\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent9.png\" alt=\"delay-parent9\"></p>\n<p><img src=\"/2019/04/13/CMU-DBMS-COURSE-09-NOTES/delay-parent10.png\" alt=\"delay-parent10\"></p>\n<p><strong>结论</strong></p>\n<ul>\n<li>使一个数据结构线程安全似乎很容易理解，但在实践中缺非常困难</li>\n<li>我们关注的是B+树，但同样高级技术叶适用于其他的数据结构</li>\n</ul>\n"},{"title":"CMU-DBMS-COURSE-10-NOTES","date":"2019-04-15T09:25:50.000Z","_content":"\n#### 查询计划\n\n​\tDBMS将SQL语句转换为查询计划。操作被安排在一棵树中。数据从叶节点流向根，树中根节点的输出是查询的结果，通常运算符是二进制的，同一个查询计划可以有多种执行方式，大多数DBMS都希望尽可能多地使用索引扫描。\n\n![query-plan](CMU-DBMS-COURSE-10-NOTES/query-plan.png)\n\n#### 处理模型\n\nDBMS处理模型定义了系统如何执行查询计划。对于不同的工作负载，不同的模型具有不同的权衡。\n\n##### 迭代模型\n\n这是最常见的处理模型，几乎每个DBMS都使用它\n\n- 自顶向下处理\n- 每一个查询计划操作实现一个next函数\n  - 每次调用next时，如果没有更多的元组，则运算符返回单个元组或空标记\n  - 运算符实现了一个循环，该循环对其子代节点调用next，以检查它们的元组，然后对它们进行处理\n\n- 允许必须检索下一个元组之前，DBMS可以通过尽可能多的运算符处理元组的流水线操作\n\n- 一些操作将被阻塞，直到子节点发出所有元组（连接，子查询，排序）\n- 使用这种方法，输出控制很容易\n\n![iter-model1](CMU-DBMS-COURSE-10-NOTES/iter-model1.png)\n\n![iter-model2](CMU-DBMS-COURSE-10-NOTES/iter-model2.png)\n\n![iter-model3](CMU-DBMS-COURSE-10-NOTES/iter-model3.png)\n\n![iter-model4](CMU-DBMS-COURSE-10-NOTES/iter-model4.png)\n\n![iter-model5](CMU-DBMS-COURSE-10-NOTES/iter-model5.png)\n\n#### 具体化模型\n\n- 每个操作一次处理其输入，然后立即发出输出。操作将其输出‘具体化“为单个结果\n- 从底向上执行\n- 对于OLTP工作负载，此方法更好，因为查询通常一次只能访问少量元组。因此，检索元组的函数调用较少\n- 不适合具有大型中间结果的OLAP查询\n\n![mate-model1](CMU-DBMS-COURSE-10-NOTES/mate-model1.png)\n\n![mate-model2](CMU-DBMS-COURSE-10-NOTES/mate-model2.png)\n\n![mate-model3](CMU-DBMS-COURSE-10-NOTES/mate-model3.png)\n\n![mate-model4](CMU-DBMS-COURSE-10-NOTES/mate-model4.png)\n\n![mate-model5](CMU-DBMS-COURSE-10-NOTES/mate-model5.png)\n\n**矢量化模型**\n\n- 就像迭代器模型一样，每个运算符都实现了next函数。但是每个运算符发出一批数据（即向量）而不是单个元组\n- 从上向下执行\n- 非常适合必须扫描大量元组的OLAP查询，因为next函数的调用次数较少\n\n![vect-model1](CMU-DBMS-COURSE-10-NOTES/vect-model1.png)\n\n![vect-model2](CMU-DBMS-COURSE-10-NOTES/vect-model2.png)\n\n![vect-model3](CMU-DBMS-COURSE-10-NOTES/vect-model3.png)\n\n#### 访问方式\n\n- 访问方式是DBMS访问数据表的方法，在关系代数中没有定义\n- 三种基本方法\n  - 顺序扫描\n  - 索引扫描\n  - 多索引/\"位图\"扫描\n\n#### 顺序扫描\n\n- 对于页表中的每一个页，从缓冲池中检索出来，迭代的访问每个元组，并检查是否包含它。\n- DBMS维护了一个内部的光标，跟踪它检查的最后一个页/槽。\n\n##### 顺序扫描的优化\n\n- 预读(Prefetching)\n- 并行化(Parallelization)\n- 缓冲池旁路(Buffer Pool Bypass)\n- 区域地图(Zone Maps)\n\n###### Zone Maps\n\n预先计算页面中属性值的聚合，DBMS首先检查区域地图以决定是否要访问该页面\n\n![zone-map1](CMU-DBMS-COURSE-10-NOTES/zone-map1.png)\n\n![zone-map2](CMU-DBMS-COURSE-10-NOTES/zone-map2.png)\n\n![zone-map3](CMU-DBMS-COURSE-10-NOTES/zone-map3.png)\n\n- 延迟实现(Late Materialization)\n\n##### Late Materialization\n\n- DBMS可以延迟将元组缝合到一起，直到查询计划执行到上部\n\n![late1](CMU-DBMS-COURSE-10-NOTES/late1.png)\n\n![late2](CMU-DBMS-COURSE-10-NOTES/late2.png)\n\n![late3](CMU-DBMS-COURSE-10-NOTES/late3.png)\n\n![late4](CMU-DBMS-COURSE-10-NOTES/late4.png)\n\n- 堆聚类\n\n##### Heap Clustering\n\n使用聚集索引指定的顺序对堆页中的元祖进行排序。\n\n如果查询使用集群索引的属性访问元组，那么DBMS可以直接跳转到它需要的页面。\n\n![heap-cluster1](CMU-DBMS-COURSE-10-NOTES/heap-cluster1.png)\n\n![heap-cluster2](CMU-DBMS-COURSE-10-NOTES/heap-cluster2.png)\n\n##### 索引扫描\n\n```\nSELECT * FROM students\nWHERE age < 30\nAND dept = 'CS'\nAND country = 'US'\n```\n\n- 假设我们有一个表里面有100个元组和两个索引，索引1 age 索引2 dept\n\n**多索引扫描**\n\n- 如果表中有多个索引供DBMS用于查询\n  - 对匹配的索引计算ids的集合\n  - 根据查询的谓词组合这些集合（并集或者交集）\n  - 检索纪录项并应用其余的检索条件\n\n```\nSELECT * FROM students\nWHERE age < 30\nAND dept = 'CS'\nAND country = 'US'\n```\n\n上述语句的执行过程为\n\n- 首先通过age < 30拿到记录的ids\n- 其次通过dept='CS'拿到指定纪录的ids\n- 求它们的交集\n- 检索这些匹配出来的纪录检查country = 'US'是否满足\n\n- 集合交集操作可以通过位图、哈希表或Bloom过滤器完成。\n\n![multi-index-scan1](CMU-DBMS-COURSE-10-NOTES/multi-index-scan1.png)\n\n![multi-index-scan2](CMU-DBMS-COURSE-10-NOTES/multi-index-scan2.png)\n\n![multi-index-scan3](CMU-DBMS-COURSE-10-NOTES/multi-index-scan3.png)\n\n##### 索引扫描页排序\n\n- 按照未出现在分类索引中的顺序检索元组效率很低\n- DBMS可以首先找出它需要的所有元组，然后根据它们的页ID对它们进行排序\n\n![index-scan1](CMU-DBMS-COURSE-10-NOTES/index-scan1.png)\n\n![index-scan2](CMU-DBMS-COURSE-10-NOTES/index-scan2.png)\n\n![index-scan3](CMU-DBMS-COURSE-10-NOTES/index-scan3.png)\n\n![index-scan4](CMU-DBMS-COURSE-10-NOTES/index-scan4.png)\n\n**表达式求值**\n\n- DBMS将WHERE字句表示为表达式树\n\n- 树中的节点表示不通的表达式类型\n  - 比较 （=,<,>,!=）\n  - 逻辑与 (AND)，逻辑或 (OR)\n  - 数值运算操作(+,-,*,/,%)\n  - 常量值\n  - 元组属性引用\n\n![evalution-1](CMU-DBMS-COURSE-10-NOTES/evalution-1.png)\n\n![evalution-2](CMU-DBMS-COURSE-10-NOTES/evalution-2.png)\n\n![evalution-3](CMU-DBMS-COURSE-10-NOTES/evalution-3.png)\n\n![evalution-4](CMU-DBMS-COURSE-10-NOTES/evalution-4.png)\n\n![evalution-5](CMU-DBMS-COURSE-10-NOTES/evalution-5.png)\n\n![evalution-6](CMU-DBMS-COURSE-10-NOTES/evalution-6.png)\n\n![evalution-7](CMU-DBMS-COURSE-10-NOTES/evalution-7.png)\n\n","source":"_posts/CMU-DBMS-COURSE-10-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-10-NOTES\ndate: 2019-04-15 17:25:50\ntags:\n---\n\n#### 查询计划\n\n​\tDBMS将SQL语句转换为查询计划。操作被安排在一棵树中。数据从叶节点流向根，树中根节点的输出是查询的结果，通常运算符是二进制的，同一个查询计划可以有多种执行方式，大多数DBMS都希望尽可能多地使用索引扫描。\n\n![query-plan](CMU-DBMS-COURSE-10-NOTES/query-plan.png)\n\n#### 处理模型\n\nDBMS处理模型定义了系统如何执行查询计划。对于不同的工作负载，不同的模型具有不同的权衡。\n\n##### 迭代模型\n\n这是最常见的处理模型，几乎每个DBMS都使用它\n\n- 自顶向下处理\n- 每一个查询计划操作实现一个next函数\n  - 每次调用next时，如果没有更多的元组，则运算符返回单个元组或空标记\n  - 运算符实现了一个循环，该循环对其子代节点调用next，以检查它们的元组，然后对它们进行处理\n\n- 允许必须检索下一个元组之前，DBMS可以通过尽可能多的运算符处理元组的流水线操作\n\n- 一些操作将被阻塞，直到子节点发出所有元组（连接，子查询，排序）\n- 使用这种方法，输出控制很容易\n\n![iter-model1](CMU-DBMS-COURSE-10-NOTES/iter-model1.png)\n\n![iter-model2](CMU-DBMS-COURSE-10-NOTES/iter-model2.png)\n\n![iter-model3](CMU-DBMS-COURSE-10-NOTES/iter-model3.png)\n\n![iter-model4](CMU-DBMS-COURSE-10-NOTES/iter-model4.png)\n\n![iter-model5](CMU-DBMS-COURSE-10-NOTES/iter-model5.png)\n\n#### 具体化模型\n\n- 每个操作一次处理其输入，然后立即发出输出。操作将其输出‘具体化“为单个结果\n- 从底向上执行\n- 对于OLTP工作负载，此方法更好，因为查询通常一次只能访问少量元组。因此，检索元组的函数调用较少\n- 不适合具有大型中间结果的OLAP查询\n\n![mate-model1](CMU-DBMS-COURSE-10-NOTES/mate-model1.png)\n\n![mate-model2](CMU-DBMS-COURSE-10-NOTES/mate-model2.png)\n\n![mate-model3](CMU-DBMS-COURSE-10-NOTES/mate-model3.png)\n\n![mate-model4](CMU-DBMS-COURSE-10-NOTES/mate-model4.png)\n\n![mate-model5](CMU-DBMS-COURSE-10-NOTES/mate-model5.png)\n\n**矢量化模型**\n\n- 就像迭代器模型一样，每个运算符都实现了next函数。但是每个运算符发出一批数据（即向量）而不是单个元组\n- 从上向下执行\n- 非常适合必须扫描大量元组的OLAP查询，因为next函数的调用次数较少\n\n![vect-model1](CMU-DBMS-COURSE-10-NOTES/vect-model1.png)\n\n![vect-model2](CMU-DBMS-COURSE-10-NOTES/vect-model2.png)\n\n![vect-model3](CMU-DBMS-COURSE-10-NOTES/vect-model3.png)\n\n#### 访问方式\n\n- 访问方式是DBMS访问数据表的方法，在关系代数中没有定义\n- 三种基本方法\n  - 顺序扫描\n  - 索引扫描\n  - 多索引/\"位图\"扫描\n\n#### 顺序扫描\n\n- 对于页表中的每一个页，从缓冲池中检索出来，迭代的访问每个元组，并检查是否包含它。\n- DBMS维护了一个内部的光标，跟踪它检查的最后一个页/槽。\n\n##### 顺序扫描的优化\n\n- 预读(Prefetching)\n- 并行化(Parallelization)\n- 缓冲池旁路(Buffer Pool Bypass)\n- 区域地图(Zone Maps)\n\n###### Zone Maps\n\n预先计算页面中属性值的聚合，DBMS首先检查区域地图以决定是否要访问该页面\n\n![zone-map1](CMU-DBMS-COURSE-10-NOTES/zone-map1.png)\n\n![zone-map2](CMU-DBMS-COURSE-10-NOTES/zone-map2.png)\n\n![zone-map3](CMU-DBMS-COURSE-10-NOTES/zone-map3.png)\n\n- 延迟实现(Late Materialization)\n\n##### Late Materialization\n\n- DBMS可以延迟将元组缝合到一起，直到查询计划执行到上部\n\n![late1](CMU-DBMS-COURSE-10-NOTES/late1.png)\n\n![late2](CMU-DBMS-COURSE-10-NOTES/late2.png)\n\n![late3](CMU-DBMS-COURSE-10-NOTES/late3.png)\n\n![late4](CMU-DBMS-COURSE-10-NOTES/late4.png)\n\n- 堆聚类\n\n##### Heap Clustering\n\n使用聚集索引指定的顺序对堆页中的元祖进行排序。\n\n如果查询使用集群索引的属性访问元组，那么DBMS可以直接跳转到它需要的页面。\n\n![heap-cluster1](CMU-DBMS-COURSE-10-NOTES/heap-cluster1.png)\n\n![heap-cluster2](CMU-DBMS-COURSE-10-NOTES/heap-cluster2.png)\n\n##### 索引扫描\n\n```\nSELECT * FROM students\nWHERE age < 30\nAND dept = 'CS'\nAND country = 'US'\n```\n\n- 假设我们有一个表里面有100个元组和两个索引，索引1 age 索引2 dept\n\n**多索引扫描**\n\n- 如果表中有多个索引供DBMS用于查询\n  - 对匹配的索引计算ids的集合\n  - 根据查询的谓词组合这些集合（并集或者交集）\n  - 检索纪录项并应用其余的检索条件\n\n```\nSELECT * FROM students\nWHERE age < 30\nAND dept = 'CS'\nAND country = 'US'\n```\n\n上述语句的执行过程为\n\n- 首先通过age < 30拿到记录的ids\n- 其次通过dept='CS'拿到指定纪录的ids\n- 求它们的交集\n- 检索这些匹配出来的纪录检查country = 'US'是否满足\n\n- 集合交集操作可以通过位图、哈希表或Bloom过滤器完成。\n\n![multi-index-scan1](CMU-DBMS-COURSE-10-NOTES/multi-index-scan1.png)\n\n![multi-index-scan2](CMU-DBMS-COURSE-10-NOTES/multi-index-scan2.png)\n\n![multi-index-scan3](CMU-DBMS-COURSE-10-NOTES/multi-index-scan3.png)\n\n##### 索引扫描页排序\n\n- 按照未出现在分类索引中的顺序检索元组效率很低\n- DBMS可以首先找出它需要的所有元组，然后根据它们的页ID对它们进行排序\n\n![index-scan1](CMU-DBMS-COURSE-10-NOTES/index-scan1.png)\n\n![index-scan2](CMU-DBMS-COURSE-10-NOTES/index-scan2.png)\n\n![index-scan3](CMU-DBMS-COURSE-10-NOTES/index-scan3.png)\n\n![index-scan4](CMU-DBMS-COURSE-10-NOTES/index-scan4.png)\n\n**表达式求值**\n\n- DBMS将WHERE字句表示为表达式树\n\n- 树中的节点表示不通的表达式类型\n  - 比较 （=,<,>,!=）\n  - 逻辑与 (AND)，逻辑或 (OR)\n  - 数值运算操作(+,-,*,/,%)\n  - 常量值\n  - 元组属性引用\n\n![evalution-1](CMU-DBMS-COURSE-10-NOTES/evalution-1.png)\n\n![evalution-2](CMU-DBMS-COURSE-10-NOTES/evalution-2.png)\n\n![evalution-3](CMU-DBMS-COURSE-10-NOTES/evalution-3.png)\n\n![evalution-4](CMU-DBMS-COURSE-10-NOTES/evalution-4.png)\n\n![evalution-5](CMU-DBMS-COURSE-10-NOTES/evalution-5.png)\n\n![evalution-6](CMU-DBMS-COURSE-10-NOTES/evalution-6.png)\n\n![evalution-7](CMU-DBMS-COURSE-10-NOTES/evalution-7.png)\n\n","slug":"CMU-DBMS-COURSE-10-NOTES","published":1,"updated":"2019-06-26T11:56:34.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvymx000dvkqpvj2657ki","content":"<h4 id=\"查询计划\"><a href=\"#查询计划\" class=\"headerlink\" title=\"查询计划\"></a>查询计划</h4><p>​    DBMS将SQL语句转换为查询计划。操作被安排在一棵树中。数据从叶节点流向根，树中根节点的输出是查询的结果，通常运算符是二进制的，同一个查询计划可以有多种执行方式，大多数DBMS都希望尽可能多地使用索引扫描。</p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/query-plan.png\" alt=\"query-plan\"></p>\n<h4 id=\"处理模型\"><a href=\"#处理模型\" class=\"headerlink\" title=\"处理模型\"></a>处理模型</h4><p>DBMS处理模型定义了系统如何执行查询计划。对于不同的工作负载，不同的模型具有不同的权衡。</p>\n<h5 id=\"迭代模型\"><a href=\"#迭代模型\" class=\"headerlink\" title=\"迭代模型\"></a>迭代模型</h5><p>这是最常见的处理模型，几乎每个DBMS都使用它</p>\n<ul>\n<li>自顶向下处理</li>\n<li><p>每一个查询计划操作实现一个next函数</p>\n<ul>\n<li>每次调用next时，如果没有更多的元组，则运算符返回单个元组或空标记</li>\n<li>运算符实现了一个循环，该循环对其子代节点调用next，以检查它们的元组，然后对它们进行处理</li>\n</ul>\n</li>\n<li><p>允许必须检索下一个元组之前，DBMS可以通过尽可能多的运算符处理元组的流水线操作</p>\n</li>\n<li><p>一些操作将被阻塞，直到子节点发出所有元组（连接，子查询，排序）</p>\n</li>\n<li>使用这种方法，输出控制很容易</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/iter-model1.png\" alt=\"iter-model1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/iter-model2.png\" alt=\"iter-model2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/iter-model3.png\" alt=\"iter-model3\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/iter-model4.png\" alt=\"iter-model4\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/iter-model5.png\" alt=\"iter-model5\"></p>\n<h4 id=\"具体化模型\"><a href=\"#具体化模型\" class=\"headerlink\" title=\"具体化模型\"></a>具体化模型</h4><ul>\n<li>每个操作一次处理其输入，然后立即发出输出。操作将其输出‘具体化“为单个结果</li>\n<li>从底向上执行</li>\n<li>对于OLTP工作负载，此方法更好，因为查询通常一次只能访问少量元组。因此，检索元组的函数调用较少</li>\n<li>不适合具有大型中间结果的OLAP查询</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/mate-model1.png\" alt=\"mate-model1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/mate-model2.png\" alt=\"mate-model2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/mate-model3.png\" alt=\"mate-model3\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/mate-model4.png\" alt=\"mate-model4\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/mate-model5.png\" alt=\"mate-model5\"></p>\n<p><strong>矢量化模型</strong></p>\n<ul>\n<li>就像迭代器模型一样，每个运算符都实现了next函数。但是每个运算符发出一批数据（即向量）而不是单个元组</li>\n<li>从上向下执行</li>\n<li>非常适合必须扫描大量元组的OLAP查询，因为next函数的调用次数较少</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/vect-model1.png\" alt=\"vect-model1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/vect-model2.png\" alt=\"vect-model2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/vect-model3.png\" alt=\"vect-model3\"></p>\n<h4 id=\"访问方式\"><a href=\"#访问方式\" class=\"headerlink\" title=\"访问方式\"></a>访问方式</h4><ul>\n<li>访问方式是DBMS访问数据表的方法，在关系代数中没有定义</li>\n<li>三种基本方法<ul>\n<li>顺序扫描</li>\n<li>索引扫描</li>\n<li>多索引/“位图”扫描</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"顺序扫描\"><a href=\"#顺序扫描\" class=\"headerlink\" title=\"顺序扫描\"></a>顺序扫描</h4><ul>\n<li>对于页表中的每一个页，从缓冲池中检索出来，迭代的访问每个元组，并检查是否包含它。</li>\n<li>DBMS维护了一个内部的光标，跟踪它检查的最后一个页/槽。</li>\n</ul>\n<h5 id=\"顺序扫描的优化\"><a href=\"#顺序扫描的优化\" class=\"headerlink\" title=\"顺序扫描的优化\"></a>顺序扫描的优化</h5><ul>\n<li>预读(Prefetching)</li>\n<li>并行化(Parallelization)</li>\n<li>缓冲池旁路(Buffer Pool Bypass)</li>\n<li>区域地图(Zone Maps)</li>\n</ul>\n<h6 id=\"Zone-Maps\"><a href=\"#Zone-Maps\" class=\"headerlink\" title=\"Zone Maps\"></a>Zone Maps</h6><p>预先计算页面中属性值的聚合，DBMS首先检查区域地图以决定是否要访问该页面</p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/zone-map1.png\" alt=\"zone-map1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/zone-map2.png\" alt=\"zone-map2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/zone-map3.png\" alt=\"zone-map3\"></p>\n<ul>\n<li>延迟实现(Late Materialization)</li>\n</ul>\n<h5 id=\"Late-Materialization\"><a href=\"#Late-Materialization\" class=\"headerlink\" title=\"Late Materialization\"></a>Late Materialization</h5><ul>\n<li>DBMS可以延迟将元组缝合到一起，直到查询计划执行到上部</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/late1.png\" alt=\"late1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/late2.png\" alt=\"late2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/late3.png\" alt=\"late3\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/late4.png\" alt=\"late4\"></p>\n<ul>\n<li>堆聚类</li>\n</ul>\n<h5 id=\"Heap-Clustering\"><a href=\"#Heap-Clustering\" class=\"headerlink\" title=\"Heap Clustering\"></a>Heap Clustering</h5><p>使用聚集索引指定的顺序对堆页中的元祖进行排序。</p>\n<p>如果查询使用集群索引的属性访问元组，那么DBMS可以直接跳转到它需要的页面。</p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/heap-cluster1.png\" alt=\"heap-cluster1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/heap-cluster2.png\" alt=\"heap-cluster2\"></p>\n<h5 id=\"索引扫描\"><a href=\"#索引扫描\" class=\"headerlink\" title=\"索引扫描\"></a>索引扫描</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM students</span><br><span class=\"line\">WHERE age &lt; 30</span><br><span class=\"line\">AND dept = &apos;CS&apos;</span><br><span class=\"line\">AND country = &apos;US&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>假设我们有一个表里面有100个元组和两个索引，索引1 age 索引2 dept</li>\n</ul>\n<p><strong>多索引扫描</strong></p>\n<ul>\n<li>如果表中有多个索引供DBMS用于查询<ul>\n<li>对匹配的索引计算ids的集合</li>\n<li>根据查询的谓词组合这些集合（并集或者交集）</li>\n<li>检索纪录项并应用其余的检索条件</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM students</span><br><span class=\"line\">WHERE age &lt; 30</span><br><span class=\"line\">AND dept = &apos;CS&apos;</span><br><span class=\"line\">AND country = &apos;US&apos;</span><br></pre></td></tr></table></figure>\n<p>上述语句的执行过程为</p>\n<ul>\n<li>首先通过age &lt; 30拿到记录的ids</li>\n<li>其次通过dept=’CS’拿到指定纪录的ids</li>\n<li>求它们的交集</li>\n<li><p>检索这些匹配出来的纪录检查country = ‘US’是否满足</p>\n</li>\n<li><p>集合交集操作可以通过位图、哈希表或Bloom过滤器完成。</p>\n</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/multi-index-scan1.png\" alt=\"multi-index-scan1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/multi-index-scan2.png\" alt=\"multi-index-scan2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/multi-index-scan3.png\" alt=\"multi-index-scan3\"></p>\n<h5 id=\"索引扫描页排序\"><a href=\"#索引扫描页排序\" class=\"headerlink\" title=\"索引扫描页排序\"></a>索引扫描页排序</h5><ul>\n<li>按照未出现在分类索引中的顺序检索元组效率很低</li>\n<li>DBMS可以首先找出它需要的所有元组，然后根据它们的页ID对它们进行排序</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/index-scan1.png\" alt=\"index-scan1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/index-scan2.png\" alt=\"index-scan2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/index-scan3.png\" alt=\"index-scan3\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/index-scan4.png\" alt=\"index-scan4\"></p>\n<p><strong>表达式求值</strong></p>\n<ul>\n<li><p>DBMS将WHERE字句表示为表达式树</p>\n</li>\n<li><p>树中的节点表示不通的表达式类型</p>\n<ul>\n<li>比较 （=,&lt;,&gt;,!=）</li>\n<li>逻辑与 (AND)，逻辑或 (OR)</li>\n<li>数值运算操作(+,-,*,/,%)</li>\n<li>常量值</li>\n<li>元组属性引用</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-1.png\" alt=\"evalution-1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-2.png\" alt=\"evalution-2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-3.png\" alt=\"evalution-3\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-4.png\" alt=\"evalution-4\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-5.png\" alt=\"evalution-5\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-6.png\" alt=\"evalution-6\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-7.png\" alt=\"evalution-7\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"查询计划\"><a href=\"#查询计划\" class=\"headerlink\" title=\"查询计划\"></a>查询计划</h4><p>​    DBMS将SQL语句转换为查询计划。操作被安排在一棵树中。数据从叶节点流向根，树中根节点的输出是查询的结果，通常运算符是二进制的，同一个查询计划可以有多种执行方式，大多数DBMS都希望尽可能多地使用索引扫描。</p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/query-plan.png\" alt=\"query-plan\"></p>\n<h4 id=\"处理模型\"><a href=\"#处理模型\" class=\"headerlink\" title=\"处理模型\"></a>处理模型</h4><p>DBMS处理模型定义了系统如何执行查询计划。对于不同的工作负载，不同的模型具有不同的权衡。</p>\n<h5 id=\"迭代模型\"><a href=\"#迭代模型\" class=\"headerlink\" title=\"迭代模型\"></a>迭代模型</h5><p>这是最常见的处理模型，几乎每个DBMS都使用它</p>\n<ul>\n<li>自顶向下处理</li>\n<li><p>每一个查询计划操作实现一个next函数</p>\n<ul>\n<li>每次调用next时，如果没有更多的元组，则运算符返回单个元组或空标记</li>\n<li>运算符实现了一个循环，该循环对其子代节点调用next，以检查它们的元组，然后对它们进行处理</li>\n</ul>\n</li>\n<li><p>允许必须检索下一个元组之前，DBMS可以通过尽可能多的运算符处理元组的流水线操作</p>\n</li>\n<li><p>一些操作将被阻塞，直到子节点发出所有元组（连接，子查询，排序）</p>\n</li>\n<li>使用这种方法，输出控制很容易</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/iter-model1.png\" alt=\"iter-model1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/iter-model2.png\" alt=\"iter-model2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/iter-model3.png\" alt=\"iter-model3\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/iter-model4.png\" alt=\"iter-model4\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/iter-model5.png\" alt=\"iter-model5\"></p>\n<h4 id=\"具体化模型\"><a href=\"#具体化模型\" class=\"headerlink\" title=\"具体化模型\"></a>具体化模型</h4><ul>\n<li>每个操作一次处理其输入，然后立即发出输出。操作将其输出‘具体化“为单个结果</li>\n<li>从底向上执行</li>\n<li>对于OLTP工作负载，此方法更好，因为查询通常一次只能访问少量元组。因此，检索元组的函数调用较少</li>\n<li>不适合具有大型中间结果的OLAP查询</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/mate-model1.png\" alt=\"mate-model1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/mate-model2.png\" alt=\"mate-model2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/mate-model3.png\" alt=\"mate-model3\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/mate-model4.png\" alt=\"mate-model4\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/mate-model5.png\" alt=\"mate-model5\"></p>\n<p><strong>矢量化模型</strong></p>\n<ul>\n<li>就像迭代器模型一样，每个运算符都实现了next函数。但是每个运算符发出一批数据（即向量）而不是单个元组</li>\n<li>从上向下执行</li>\n<li>非常适合必须扫描大量元组的OLAP查询，因为next函数的调用次数较少</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/vect-model1.png\" alt=\"vect-model1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/vect-model2.png\" alt=\"vect-model2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/vect-model3.png\" alt=\"vect-model3\"></p>\n<h4 id=\"访问方式\"><a href=\"#访问方式\" class=\"headerlink\" title=\"访问方式\"></a>访问方式</h4><ul>\n<li>访问方式是DBMS访问数据表的方法，在关系代数中没有定义</li>\n<li>三种基本方法<ul>\n<li>顺序扫描</li>\n<li>索引扫描</li>\n<li>多索引/“位图”扫描</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"顺序扫描\"><a href=\"#顺序扫描\" class=\"headerlink\" title=\"顺序扫描\"></a>顺序扫描</h4><ul>\n<li>对于页表中的每一个页，从缓冲池中检索出来，迭代的访问每个元组，并检查是否包含它。</li>\n<li>DBMS维护了一个内部的光标，跟踪它检查的最后一个页/槽。</li>\n</ul>\n<h5 id=\"顺序扫描的优化\"><a href=\"#顺序扫描的优化\" class=\"headerlink\" title=\"顺序扫描的优化\"></a>顺序扫描的优化</h5><ul>\n<li>预读(Prefetching)</li>\n<li>并行化(Parallelization)</li>\n<li>缓冲池旁路(Buffer Pool Bypass)</li>\n<li>区域地图(Zone Maps)</li>\n</ul>\n<h6 id=\"Zone-Maps\"><a href=\"#Zone-Maps\" class=\"headerlink\" title=\"Zone Maps\"></a>Zone Maps</h6><p>预先计算页面中属性值的聚合，DBMS首先检查区域地图以决定是否要访问该页面</p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/zone-map1.png\" alt=\"zone-map1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/zone-map2.png\" alt=\"zone-map2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/zone-map3.png\" alt=\"zone-map3\"></p>\n<ul>\n<li>延迟实现(Late Materialization)</li>\n</ul>\n<h5 id=\"Late-Materialization\"><a href=\"#Late-Materialization\" class=\"headerlink\" title=\"Late Materialization\"></a>Late Materialization</h5><ul>\n<li>DBMS可以延迟将元组缝合到一起，直到查询计划执行到上部</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/late1.png\" alt=\"late1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/late2.png\" alt=\"late2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/late3.png\" alt=\"late3\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/late4.png\" alt=\"late4\"></p>\n<ul>\n<li>堆聚类</li>\n</ul>\n<h5 id=\"Heap-Clustering\"><a href=\"#Heap-Clustering\" class=\"headerlink\" title=\"Heap Clustering\"></a>Heap Clustering</h5><p>使用聚集索引指定的顺序对堆页中的元祖进行排序。</p>\n<p>如果查询使用集群索引的属性访问元组，那么DBMS可以直接跳转到它需要的页面。</p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/heap-cluster1.png\" alt=\"heap-cluster1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/heap-cluster2.png\" alt=\"heap-cluster2\"></p>\n<h5 id=\"索引扫描\"><a href=\"#索引扫描\" class=\"headerlink\" title=\"索引扫描\"></a>索引扫描</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM students</span><br><span class=\"line\">WHERE age &lt; 30</span><br><span class=\"line\">AND dept = &apos;CS&apos;</span><br><span class=\"line\">AND country = &apos;US&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>假设我们有一个表里面有100个元组和两个索引，索引1 age 索引2 dept</li>\n</ul>\n<p><strong>多索引扫描</strong></p>\n<ul>\n<li>如果表中有多个索引供DBMS用于查询<ul>\n<li>对匹配的索引计算ids的集合</li>\n<li>根据查询的谓词组合这些集合（并集或者交集）</li>\n<li>检索纪录项并应用其余的检索条件</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM students</span><br><span class=\"line\">WHERE age &lt; 30</span><br><span class=\"line\">AND dept = &apos;CS&apos;</span><br><span class=\"line\">AND country = &apos;US&apos;</span><br></pre></td></tr></table></figure>\n<p>上述语句的执行过程为</p>\n<ul>\n<li>首先通过age &lt; 30拿到记录的ids</li>\n<li>其次通过dept=’CS’拿到指定纪录的ids</li>\n<li>求它们的交集</li>\n<li><p>检索这些匹配出来的纪录检查country = ‘US’是否满足</p>\n</li>\n<li><p>集合交集操作可以通过位图、哈希表或Bloom过滤器完成。</p>\n</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/multi-index-scan1.png\" alt=\"multi-index-scan1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/multi-index-scan2.png\" alt=\"multi-index-scan2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/multi-index-scan3.png\" alt=\"multi-index-scan3\"></p>\n<h5 id=\"索引扫描页排序\"><a href=\"#索引扫描页排序\" class=\"headerlink\" title=\"索引扫描页排序\"></a>索引扫描页排序</h5><ul>\n<li>按照未出现在分类索引中的顺序检索元组效率很低</li>\n<li>DBMS可以首先找出它需要的所有元组，然后根据它们的页ID对它们进行排序</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/index-scan1.png\" alt=\"index-scan1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/index-scan2.png\" alt=\"index-scan2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/index-scan3.png\" alt=\"index-scan3\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/index-scan4.png\" alt=\"index-scan4\"></p>\n<p><strong>表达式求值</strong></p>\n<ul>\n<li><p>DBMS将WHERE字句表示为表达式树</p>\n</li>\n<li><p>树中的节点表示不通的表达式类型</p>\n<ul>\n<li>比较 （=,&lt;,&gt;,!=）</li>\n<li>逻辑与 (AND)，逻辑或 (OR)</li>\n<li>数值运算操作(+,-,*,/,%)</li>\n<li>常量值</li>\n<li>元组属性引用</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-1.png\" alt=\"evalution-1\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-2.png\" alt=\"evalution-2\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-3.png\" alt=\"evalution-3\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-4.png\" alt=\"evalution-4\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-5.png\" alt=\"evalution-5\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-6.png\" alt=\"evalution-6\"></p>\n<p><img src=\"/2019/04/15/CMU-DBMS-COURSE-10-NOTES/evalution-7.png\" alt=\"evalution-7\"></p>\n"},{"title":"CMU-DBMS-COURSE-12-NOTES","date":"2019-06-09T02:21:04.000Z","_content":"\n##### Why do we need to join?\n\nWe normalize(标准化) tables in a relational database to avoid unnecessary repetition(重复) of information.\n\nWe use the join operate to reconstruct(重建) the original tuples without any information loss.\n\n##### Normalized tables\n\n![Normalized-tables](CMU-DBMS-COURSE-12-NOTES/Normalized-tables.png)\n\n##### Join Algorithms\n\nWe will focus on joining two tables at a time. In general, we want the smaller table to always be the outer table.\n\n##### Join Operator Output\n\nFor a tuple r belong to R and a tuple s belong to S that match on join attributes, concatenate(连接) r and s together into a new tuple.\n\nContents can vary(变化):\n\n- Depends on processing model\n- Depends on storage model\n- Depends on the query\n\n![Join-OPERATOR-1](CMU-DBMS-COURSE-12-NOTES/Join-OPERATOR-1.png)\n\n##### Join operator output: data\n\nCopy the values for the attributes in outer and inner tuples into a new output tuple.\n\n![JOIN-OPERATOR-OUTPUT-DATA-1](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-1.png)\n\n![JOIN-OPERATOR-OUTPUT-DATA-2](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-2.png)\n\nSubsequent operators in the query plan never need to go back to the base tables to get more data.\n\n![JOIN-OPERATOR-OUTPUT-DATA-3](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-3.png)\n\n\n\n##### Join Operator output: record ids\n\nOnly copy the joins keys along with the record ids of the matching tuples.\n\n![JOIN-OPERATOR-OUTPUT-RECORD-IDS-1](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-1.png)\n\n![JOIN-OPERATOR-OUTPUT-RECORD-IDS-2](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-2.png)\n\n![JOIN-OPERATOR-OUTPUT-RECORD-IDS-3](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-3.png)\n\nIdeal for column stores because the DBMS does not copy data that is not need for the query.\n\nThis is called late materialization.\n\n##### Simple nested loop join\n\n```\nforeach tuple r ∈ R : <- Outer\n\tforeach tuple s ∈ S : <- Inner\n\t emit , if r and s match\n```\n\n![SIMPLE-NESTED-LOOP-JOIN-1](CMU-DBMS-COURSE-12-NOTES/SIMPLE-NESTED-LOOP-JOIN-1.png)\n\nWhy is this algorithm bad?\n\n-> For every tuple in R, it scans S once\n\n**Cost：M + (m * N)**\n\nExample database:\n\n-> M = 1000, m = 100,000\n\n-> N = 500, n = 40,000\n\nCost Analysis:\n\n-> M + (m * N) = 1000 + (100000 * 500) = 50,000,100 IOs\n\n-> At 0.1 ms/IO, Total time = 1.3 hours\n\nWhat if smaller table（S）is used as the outer table?\n\n-> N + (n * M) = 500 + (40000 * 1000) = 40,000,500 Ios\n\n-> At 0.1 ms/IO, Total time = 1.1 hours\n\n##### Block nested(嵌套) loop join\n\n```\nforeach block BR ∈ R:\n\tforeach block BS ∈ S:\n\t\tforeach tuple r ∈ BR:\n\t\t\tforeach tuple s ∈ Bs:\n\t\t\t\temit, if r and s match\n```\n\n![BLOCK-NESTED-LOOP-JOIN-1](CMU-DBMS-COURSE-12-NOTES/BLOCK-NESTED-LOOP-JOIN-1.png)\n\nThis algorithm performs fewer disk accesses.\n\n-> for every block in R, it scans S one\n\nCost: M + (M* N)\n\nWhich one should be the outter table?\n\n- The smaller table in terms of # of pages\n\nExample databases:\n\n-> M = 1000, m = 100,000\n\n-> N = 500, n = 40,000\n\nCost Analysis:\n\n-> M + (M * N) = 1000 + (1000 * 500) = 501,000 IOs\n\n-> At 0.1 ms/IO, Total time = 50 seconds\n\nWhat if we have B buffers available?\n\n-> Use B-2 buffers for scanning the outer table.\n\n-> Use one buffer for the inner table, one buffer for storing output.\n\n```\nforeach B - 2 blocks b(R) ∈ R\n\tforeach block b(S) ∈ S\n\t\tforeach tuple r ∈ b(R)\n\t\t\tforeach\ttuple s ∈ b(S)\n\t\t\t\temit , if r and s match\n```\n\nThis algorithm uses B-2 buffers for scanning R.\n\nCost: M + ([M / (B - 2)] * N) (向上取整)\n\nWhat of the outer relation completely fits in memory(B > M + 2)?\n\n-> Cost: M + N = 1000 + 500 = 1500 IOs\n\n-> At 0.1 ms/IO, Total time = 0.15 seconds\n\n##### Index nested（嵌套的） loop join\n\nWhy do basic nested  loop joins suck ass(很糟糕)?\n\n- For each tuple in the outer table, we have to do a sequential(顺序的) scan to check for a match in the inner table.\n\nCan we accelerate(加快) the join using an index?\n\nUse an index to find inner table matches.\n\n- We could use an existing index for the join.\n- Or even build one on the fly.\n\n```\nforeach tuple r ∈ R:\n\tforeach tuple s ∈ Index r(i) = s(j)):\n\t\temit , if r and s match\n```\n\n![INDEX-NESTED-LOOP-JOIN-1](CMU-DBMS-COURSE-12-NOTES/INDEX-NESTED-LOOP-JOIN-1.png)\n\nAssume the cost of each index probe is some constant C per tuple.\n\nCost: M + (m * C)\n\n##### Nested loop join\n\nPick the smaller table as the outer table.\n\nBuffer as much of the outer table in memory as possible.\n\nLoop over the inner table or use an index.\n\n##### Sort-merge join\n\nPhase #1: Sort\n\n- Sort both tables on the join key(s).\n- Can use the external merge sort algorithm that we talked about last class.\n\nPhase #2: Merge\n\n- Step through the two sorted tables in parallel, and emit matching tuples.\n- My need to backtrack(回溯) depending on the join type.\n\n```\nsort R,S on join keys\ncursor(R) <- R(sorted), cursor(S)<- S(sorted)\nwhile cursor(R) and cursor(S)\n\tif cursor(R) > cursor(S):\n\t\tincrement cursor(S)\n\tif cursor(R) < cursor(S):\n\t\tincrement cursor(R)\n\telif cursor(R) and cursor(S) matcg:\n\t\temit\n\t\tincrement cursor(S)\n```\n\n![SORT-MERGE-JOIN-1](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-1.png)\n\n![SORT-MERGE-JOIN-2](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-2.png)\n\n![SORT-MERGE-JOIN-3](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-3.png)\n\n![SORT-MERGE-JOIN-4](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-4.png)\n\n![SORT-MERGE-JOIN-5](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-5.png)\n\n![SORT-MERGE-JOIN-6](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-6.png)\n\n![SORT-MERGE-JOIN-7](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-7.png)\n\n![SORT-MERGE-JOIN-8](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-8.png)\n\n![SORT-MERGE-JOIN-9](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-9.png)\n\n![SORT-MERGE-JOIN-10](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-10.png)\n\n![SORT-MERGE-JOIN-11](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-11.png)\n\n![SORT-MERGE-JOIN-12](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-12.png)\n\nSort Cost(R): 2M * (log M / log B)\n\nSort Cost(S): 2N * (log N / log B)\n\nMerge Cost: (M + N)\n\nTotal Cost: Sort + Merge\n\nExample database:\n\n-> M = 1000, m = 100,000\n\n-> N= 500, n = 40,000\n\nWith 100 buffer pages, both R and S can be sorted in two passes:\n\n- Sort Cost(R) = 2000 * (log 1000 / log 100) = 3000 IOs\n- Sort Cost(S) = 1000 * (log 500 / log 100) = 1350 IOs\n- Merge Cost = (1000 + 500) = 1500 IOs\n- Total Cost = 3000 + 1350 + 1500 = 5850 IOs\n- At 0.1 ms/IO, Total time = 0.59 seconds\n\nCost: (M * N) + (sort cost)\n\n##### When is sort-merge join useful?\n\nOne or both tables are already sorted on join key.\n\nOutput must be sorted on join key.\n\nThe input relations may be sorted by either by an explicit(明确的) sort operator, or by scanning the relation using an index on the join key.\n\n##### Hash join\n\nIf tuple **r ∈ R** and a tuple **s ∈ S** satisfy（满足） the join condition（条件）, then they have the same value for the join attributes.\n\nIf that value is hashed to some value i, the R tuple has to be in r(i) and the S tuple in s(i).\n\nTherefore, R tuples in r(i) need only to be compared with S tuples in s(i).\n\n##### Basic hash join algorithm\n\nPhase #1: Build\n\nScan the outer relation and populate a hash table using the hash function h1 on join attributes.\n\nPhase #2: Probe\n\nScan the inner relation and use h1 on each tuple to jump to a location in the hash table and find a matching tuple.\n\n```\nbuild hash table HT(R) for R\nforeach\ttuple s ∈ S\n\toutput , if h1 (s) ∈ HT(R)\n```\n\n![BASIC-HASH-JOIN-ALGORITHM-1](CMU-DBMS-COURSE-12-NOTES/BASIC-HASH-JOIN-ALGORITHM-1.png)\n\n##### Hash table contents\n\nKey: The attribute(s) that the query is joining the tables on.\n\nValue: Varies per implementation.\n\nDepends on what the operators above the join in the query plan expect as its input.\n\n##### Hash table values\n\nApproach #1: Full Tuple\n\nAvoid having to retrieve(检索) the outer relation's tuple contents on a match.\n\nTakes up more space in memory.\n\nApproach #2: Tuple Identifier\n\nIdeal for column stores because the DBMS doesn't fetch data from disk it doesn't need.\n\nAlso better if join selectivity(选择性) is low.\n\n##### Hash join\n\nWhat happens if we do not have enough memory to fit the entire hash table?\n\nWe do not want to let the buffer pool manager swap out the hash table pages at a random.\n\n##### Grace hash join\n\nHash join when tables don't fit in memory.\n\nBuild Phase: Hash both tables on the join attribute into partitions(分区)\n\nProbe(查看) Phase: Compares tuples in corresponding(相应的) partitions for each table.\n\nNamed after the GRACE database machine from Japan.\n\n![GRACE-HASH-JOIN-1](CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-1.png)\n\nHash R into (0,1,...,max) buckets.\n\nHash S into the same # of buckets with the same hash fuction.\n\n![GRACE-HASH-JOIN-2](CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-2.png)\n\n![GRACE-HASH-JOIN-3](CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-3.png)\n\nIf the buckets do not fit in memory, then use recursive(递归的) partitioning to split the tables into chunks that will fit.\n\nBuild another hash table for bucket(R,i) using hash function h2 (with h2 != h1)\n\nThen probe it for each tuple of the other table's bucket at that level.\n\n##### Recursive partitioning\n\n![RECURSIVE-PARTITIONING-1](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-1.png)\n\n![RECURSIVE-PARTITIONING-2](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-2.png)\n\n![RECURSIVE-PARTITIONING-3](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-3.png)\n\n![RECURSIVE-PARTITIONING-4](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-4.png)\n\n![RECURSIVE-PARTITIONING-5](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-5.png)\n\n![RECURSIVE-PARTITIONING-6](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-6.png)\n\nCost of hash join?\n\nAssume that we have enough buffers.\n\nCost: 3(M + N)\n\nPartitioning Phase:\n\nRead + Write both tables\n\n2(M + N) IOs\n\nProbing Phase:\n\nRead both tables\n\nM + N IOs\n\nExample database:\n\nM = 1000, m = 100,000\n\nN = 500, n = 40,000\n\nCost analysis:\n\n3 * (M + N) = 3 * (1000 + 500) = 4,500 IOs\n\nAt 0.1 ms/IO, Total time = 0.45 seconds\n\n##### Join algorithms: summary\n\n| **Algorithm**           | **IO Cost**           | **Example**  |\n| ----------------------- | --------------------- | ------------ |\n| Simple Nested Loop Join | **M+ (m * N)**        | 1.3 hours    |\n| Block Nested Loop Join  | **M+ (M * N)**        | 50 seconds   |\n| Index Nested Loop Join  | **M+ (m * C)**        | ~20 seconds  |\n| Sort-Merge Join         | **M+ N+ (sort cost)** | 0.59 seconds |\n| Hash Join               | **3(M+ N)**           | 0.45 seconds |\n\n","source":"_posts/CMU-DBMS-COURSE-12-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-12-NOTES\ndate: 2019-06-09 10:21:04\ntags: Join Algorithms\n---\n\n##### Why do we need to join?\n\nWe normalize(标准化) tables in a relational database to avoid unnecessary repetition(重复) of information.\n\nWe use the join operate to reconstruct(重建) the original tuples without any information loss.\n\n##### Normalized tables\n\n![Normalized-tables](CMU-DBMS-COURSE-12-NOTES/Normalized-tables.png)\n\n##### Join Algorithms\n\nWe will focus on joining two tables at a time. In general, we want the smaller table to always be the outer table.\n\n##### Join Operator Output\n\nFor a tuple r belong to R and a tuple s belong to S that match on join attributes, concatenate(连接) r and s together into a new tuple.\n\nContents can vary(变化):\n\n- Depends on processing model\n- Depends on storage model\n- Depends on the query\n\n![Join-OPERATOR-1](CMU-DBMS-COURSE-12-NOTES/Join-OPERATOR-1.png)\n\n##### Join operator output: data\n\nCopy the values for the attributes in outer and inner tuples into a new output tuple.\n\n![JOIN-OPERATOR-OUTPUT-DATA-1](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-1.png)\n\n![JOIN-OPERATOR-OUTPUT-DATA-2](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-2.png)\n\nSubsequent operators in the query plan never need to go back to the base tables to get more data.\n\n![JOIN-OPERATOR-OUTPUT-DATA-3](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-3.png)\n\n\n\n##### Join Operator output: record ids\n\nOnly copy the joins keys along with the record ids of the matching tuples.\n\n![JOIN-OPERATOR-OUTPUT-RECORD-IDS-1](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-1.png)\n\n![JOIN-OPERATOR-OUTPUT-RECORD-IDS-2](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-2.png)\n\n![JOIN-OPERATOR-OUTPUT-RECORD-IDS-3](CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-3.png)\n\nIdeal for column stores because the DBMS does not copy data that is not need for the query.\n\nThis is called late materialization.\n\n##### Simple nested loop join\n\n```\nforeach tuple r ∈ R : <- Outer\n\tforeach tuple s ∈ S : <- Inner\n\t emit , if r and s match\n```\n\n![SIMPLE-NESTED-LOOP-JOIN-1](CMU-DBMS-COURSE-12-NOTES/SIMPLE-NESTED-LOOP-JOIN-1.png)\n\nWhy is this algorithm bad?\n\n-> For every tuple in R, it scans S once\n\n**Cost：M + (m * N)**\n\nExample database:\n\n-> M = 1000, m = 100,000\n\n-> N = 500, n = 40,000\n\nCost Analysis:\n\n-> M + (m * N) = 1000 + (100000 * 500) = 50,000,100 IOs\n\n-> At 0.1 ms/IO, Total time = 1.3 hours\n\nWhat if smaller table（S）is used as the outer table?\n\n-> N + (n * M) = 500 + (40000 * 1000) = 40,000,500 Ios\n\n-> At 0.1 ms/IO, Total time = 1.1 hours\n\n##### Block nested(嵌套) loop join\n\n```\nforeach block BR ∈ R:\n\tforeach block BS ∈ S:\n\t\tforeach tuple r ∈ BR:\n\t\t\tforeach tuple s ∈ Bs:\n\t\t\t\temit, if r and s match\n```\n\n![BLOCK-NESTED-LOOP-JOIN-1](CMU-DBMS-COURSE-12-NOTES/BLOCK-NESTED-LOOP-JOIN-1.png)\n\nThis algorithm performs fewer disk accesses.\n\n-> for every block in R, it scans S one\n\nCost: M + (M* N)\n\nWhich one should be the outter table?\n\n- The smaller table in terms of # of pages\n\nExample databases:\n\n-> M = 1000, m = 100,000\n\n-> N = 500, n = 40,000\n\nCost Analysis:\n\n-> M + (M * N) = 1000 + (1000 * 500) = 501,000 IOs\n\n-> At 0.1 ms/IO, Total time = 50 seconds\n\nWhat if we have B buffers available?\n\n-> Use B-2 buffers for scanning the outer table.\n\n-> Use one buffer for the inner table, one buffer for storing output.\n\n```\nforeach B - 2 blocks b(R) ∈ R\n\tforeach block b(S) ∈ S\n\t\tforeach tuple r ∈ b(R)\n\t\t\tforeach\ttuple s ∈ b(S)\n\t\t\t\temit , if r and s match\n```\n\nThis algorithm uses B-2 buffers for scanning R.\n\nCost: M + ([M / (B - 2)] * N) (向上取整)\n\nWhat of the outer relation completely fits in memory(B > M + 2)?\n\n-> Cost: M + N = 1000 + 500 = 1500 IOs\n\n-> At 0.1 ms/IO, Total time = 0.15 seconds\n\n##### Index nested（嵌套的） loop join\n\nWhy do basic nested  loop joins suck ass(很糟糕)?\n\n- For each tuple in the outer table, we have to do a sequential(顺序的) scan to check for a match in the inner table.\n\nCan we accelerate(加快) the join using an index?\n\nUse an index to find inner table matches.\n\n- We could use an existing index for the join.\n- Or even build one on the fly.\n\n```\nforeach tuple r ∈ R:\n\tforeach tuple s ∈ Index r(i) = s(j)):\n\t\temit , if r and s match\n```\n\n![INDEX-NESTED-LOOP-JOIN-1](CMU-DBMS-COURSE-12-NOTES/INDEX-NESTED-LOOP-JOIN-1.png)\n\nAssume the cost of each index probe is some constant C per tuple.\n\nCost: M + (m * C)\n\n##### Nested loop join\n\nPick the smaller table as the outer table.\n\nBuffer as much of the outer table in memory as possible.\n\nLoop over the inner table or use an index.\n\n##### Sort-merge join\n\nPhase #1: Sort\n\n- Sort both tables on the join key(s).\n- Can use the external merge sort algorithm that we talked about last class.\n\nPhase #2: Merge\n\n- Step through the two sorted tables in parallel, and emit matching tuples.\n- My need to backtrack(回溯) depending on the join type.\n\n```\nsort R,S on join keys\ncursor(R) <- R(sorted), cursor(S)<- S(sorted)\nwhile cursor(R) and cursor(S)\n\tif cursor(R) > cursor(S):\n\t\tincrement cursor(S)\n\tif cursor(R) < cursor(S):\n\t\tincrement cursor(R)\n\telif cursor(R) and cursor(S) matcg:\n\t\temit\n\t\tincrement cursor(S)\n```\n\n![SORT-MERGE-JOIN-1](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-1.png)\n\n![SORT-MERGE-JOIN-2](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-2.png)\n\n![SORT-MERGE-JOIN-3](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-3.png)\n\n![SORT-MERGE-JOIN-4](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-4.png)\n\n![SORT-MERGE-JOIN-5](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-5.png)\n\n![SORT-MERGE-JOIN-6](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-6.png)\n\n![SORT-MERGE-JOIN-7](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-7.png)\n\n![SORT-MERGE-JOIN-8](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-8.png)\n\n![SORT-MERGE-JOIN-9](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-9.png)\n\n![SORT-MERGE-JOIN-10](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-10.png)\n\n![SORT-MERGE-JOIN-11](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-11.png)\n\n![SORT-MERGE-JOIN-12](CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-12.png)\n\nSort Cost(R): 2M * (log M / log B)\n\nSort Cost(S): 2N * (log N / log B)\n\nMerge Cost: (M + N)\n\nTotal Cost: Sort + Merge\n\nExample database:\n\n-> M = 1000, m = 100,000\n\n-> N= 500, n = 40,000\n\nWith 100 buffer pages, both R and S can be sorted in two passes:\n\n- Sort Cost(R) = 2000 * (log 1000 / log 100) = 3000 IOs\n- Sort Cost(S) = 1000 * (log 500 / log 100) = 1350 IOs\n- Merge Cost = (1000 + 500) = 1500 IOs\n- Total Cost = 3000 + 1350 + 1500 = 5850 IOs\n- At 0.1 ms/IO, Total time = 0.59 seconds\n\nCost: (M * N) + (sort cost)\n\n##### When is sort-merge join useful?\n\nOne or both tables are already sorted on join key.\n\nOutput must be sorted on join key.\n\nThe input relations may be sorted by either by an explicit(明确的) sort operator, or by scanning the relation using an index on the join key.\n\n##### Hash join\n\nIf tuple **r ∈ R** and a tuple **s ∈ S** satisfy（满足） the join condition（条件）, then they have the same value for the join attributes.\n\nIf that value is hashed to some value i, the R tuple has to be in r(i) and the S tuple in s(i).\n\nTherefore, R tuples in r(i) need only to be compared with S tuples in s(i).\n\n##### Basic hash join algorithm\n\nPhase #1: Build\n\nScan the outer relation and populate a hash table using the hash function h1 on join attributes.\n\nPhase #2: Probe\n\nScan the inner relation and use h1 on each tuple to jump to a location in the hash table and find a matching tuple.\n\n```\nbuild hash table HT(R) for R\nforeach\ttuple s ∈ S\n\toutput , if h1 (s) ∈ HT(R)\n```\n\n![BASIC-HASH-JOIN-ALGORITHM-1](CMU-DBMS-COURSE-12-NOTES/BASIC-HASH-JOIN-ALGORITHM-1.png)\n\n##### Hash table contents\n\nKey: The attribute(s) that the query is joining the tables on.\n\nValue: Varies per implementation.\n\nDepends on what the operators above the join in the query plan expect as its input.\n\n##### Hash table values\n\nApproach #1: Full Tuple\n\nAvoid having to retrieve(检索) the outer relation's tuple contents on a match.\n\nTakes up more space in memory.\n\nApproach #2: Tuple Identifier\n\nIdeal for column stores because the DBMS doesn't fetch data from disk it doesn't need.\n\nAlso better if join selectivity(选择性) is low.\n\n##### Hash join\n\nWhat happens if we do not have enough memory to fit the entire hash table?\n\nWe do not want to let the buffer pool manager swap out the hash table pages at a random.\n\n##### Grace hash join\n\nHash join when tables don't fit in memory.\n\nBuild Phase: Hash both tables on the join attribute into partitions(分区)\n\nProbe(查看) Phase: Compares tuples in corresponding(相应的) partitions for each table.\n\nNamed after the GRACE database machine from Japan.\n\n![GRACE-HASH-JOIN-1](CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-1.png)\n\nHash R into (0,1,...,max) buckets.\n\nHash S into the same # of buckets with the same hash fuction.\n\n![GRACE-HASH-JOIN-2](CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-2.png)\n\n![GRACE-HASH-JOIN-3](CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-3.png)\n\nIf the buckets do not fit in memory, then use recursive(递归的) partitioning to split the tables into chunks that will fit.\n\nBuild another hash table for bucket(R,i) using hash function h2 (with h2 != h1)\n\nThen probe it for each tuple of the other table's bucket at that level.\n\n##### Recursive partitioning\n\n![RECURSIVE-PARTITIONING-1](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-1.png)\n\n![RECURSIVE-PARTITIONING-2](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-2.png)\n\n![RECURSIVE-PARTITIONING-3](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-3.png)\n\n![RECURSIVE-PARTITIONING-4](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-4.png)\n\n![RECURSIVE-PARTITIONING-5](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-5.png)\n\n![RECURSIVE-PARTITIONING-6](CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-6.png)\n\nCost of hash join?\n\nAssume that we have enough buffers.\n\nCost: 3(M + N)\n\nPartitioning Phase:\n\nRead + Write both tables\n\n2(M + N) IOs\n\nProbing Phase:\n\nRead both tables\n\nM + N IOs\n\nExample database:\n\nM = 1000, m = 100,000\n\nN = 500, n = 40,000\n\nCost analysis:\n\n3 * (M + N) = 3 * (1000 + 500) = 4,500 IOs\n\nAt 0.1 ms/IO, Total time = 0.45 seconds\n\n##### Join algorithms: summary\n\n| **Algorithm**           | **IO Cost**           | **Example**  |\n| ----------------------- | --------------------- | ------------ |\n| Simple Nested Loop Join | **M+ (m * N)**        | 1.3 hours    |\n| Block Nested Loop Join  | **M+ (M * N)**        | 50 seconds   |\n| Index Nested Loop Join  | **M+ (m * C)**        | ~20 seconds  |\n| Sort-Merge Join         | **M+ N+ (sort cost)** | 0.59 seconds |\n| Hash Join               | **3(M+ N)**           | 0.45 seconds |\n\n","slug":"CMU-DBMS-COURSE-12-NOTES","published":1,"updated":"2019-06-26T11:56:34.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyn1000evkqplz6s24th","content":"<h5 id=\"Why-do-we-need-to-join\"><a href=\"#Why-do-we-need-to-join\" class=\"headerlink\" title=\"Why do we need to join?\"></a>Why do we need to join?</h5><p>We normalize(标准化) tables in a relational database to avoid unnecessary repetition(重复) of information.</p>\n<p>We use the join operate to reconstruct(重建) the original tuples without any information loss.</p>\n<h5 id=\"Normalized-tables\"><a href=\"#Normalized-tables\" class=\"headerlink\" title=\"Normalized tables\"></a>Normalized tables</h5><p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/Normalized-tables.png\" alt=\"Normalized-tables\"></p>\n<h5 id=\"Join-Algorithms\"><a href=\"#Join-Algorithms\" class=\"headerlink\" title=\"Join Algorithms\"></a>Join Algorithms</h5><p>We will focus on joining two tables at a time. In general, we want the smaller table to always be the outer table.</p>\n<h5 id=\"Join-Operator-Output\"><a href=\"#Join-Operator-Output\" class=\"headerlink\" title=\"Join Operator Output\"></a>Join Operator Output</h5><p>For a tuple r belong to R and a tuple s belong to S that match on join attributes, concatenate(连接) r and s together into a new tuple.</p>\n<p>Contents can vary(变化):</p>\n<ul>\n<li>Depends on processing model</li>\n<li>Depends on storage model</li>\n<li>Depends on the query</li>\n</ul>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/Join-OPERATOR-1.png\" alt=\"Join-OPERATOR-1\"></p>\n<h5 id=\"Join-operator-output-data\"><a href=\"#Join-operator-output-data\" class=\"headerlink\" title=\"Join operator output: data\"></a>Join operator output: data</h5><p>Copy the values for the attributes in outer and inner tuples into a new output tuple.</p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-1.png\" alt=\"JOIN-OPERATOR-OUTPUT-DATA-1\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-2.png\" alt=\"JOIN-OPERATOR-OUTPUT-DATA-2\"></p>\n<p>Subsequent operators in the query plan never need to go back to the base tables to get more data.</p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-3.png\" alt=\"JOIN-OPERATOR-OUTPUT-DATA-3\"></p>\n<h5 id=\"Join-Operator-output-record-ids\"><a href=\"#Join-Operator-output-record-ids\" class=\"headerlink\" title=\"Join Operator output: record ids\"></a>Join Operator output: record ids</h5><p>Only copy the joins keys along with the record ids of the matching tuples.</p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-1.png\" alt=\"JOIN-OPERATOR-OUTPUT-RECORD-IDS-1\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-2.png\" alt=\"JOIN-OPERATOR-OUTPUT-RECORD-IDS-2\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-3.png\" alt=\"JOIN-OPERATOR-OUTPUT-RECORD-IDS-3\"></p>\n<p>Ideal for column stores because the DBMS does not copy data that is not need for the query.</p>\n<p>This is called late materialization.</p>\n<h5 id=\"Simple-nested-loop-join\"><a href=\"#Simple-nested-loop-join\" class=\"headerlink\" title=\"Simple nested loop join\"></a>Simple nested loop join</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foreach tuple r ∈ R : &lt;- Outer</span><br><span class=\"line\">\tforeach tuple s ∈ S : &lt;- Inner</span><br><span class=\"line\">\t emit , if r and s match</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SIMPLE-NESTED-LOOP-JOIN-1.png\" alt=\"SIMPLE-NESTED-LOOP-JOIN-1\"></p>\n<p>Why is this algorithm bad?</p>\n<p>-&gt; For every tuple in R, it scans S once</p>\n<p><strong>Cost：M + (m * N)</strong></p>\n<p>Example database:</p>\n<p>-&gt; M = 1000, m = 100,000</p>\n<p>-&gt; N = 500, n = 40,000</p>\n<p>Cost Analysis:</p>\n<p>-&gt; M + (m <em> N) = 1000 + (100000 </em> 500) = 50,000,100 IOs</p>\n<p>-&gt; At 0.1 ms/IO, Total time = 1.3 hours</p>\n<p>What if smaller table（S）is used as the outer table?</p>\n<p>-&gt; N + (n <em> M) = 500 + (40000 </em> 1000) = 40,000,500 Ios</p>\n<p>-&gt; At 0.1 ms/IO, Total time = 1.1 hours</p>\n<h5 id=\"Block-nested-嵌套-loop-join\"><a href=\"#Block-nested-嵌套-loop-join\" class=\"headerlink\" title=\"Block nested(嵌套) loop join\"></a>Block nested(嵌套) loop join</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foreach block BR ∈ R:</span><br><span class=\"line\">\tforeach block BS ∈ S:</span><br><span class=\"line\">\t\tforeach tuple r ∈ BR:</span><br><span class=\"line\">\t\t\tforeach tuple s ∈ Bs:</span><br><span class=\"line\">\t\t\t\temit, if r and s match</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/BLOCK-NESTED-LOOP-JOIN-1.png\" alt=\"BLOCK-NESTED-LOOP-JOIN-1\"></p>\n<p>This algorithm performs fewer disk accesses.</p>\n<p>-&gt; for every block in R, it scans S one</p>\n<p>Cost: M + (M* N)</p>\n<p>Which one should be the outter table?</p>\n<ul>\n<li>The smaller table in terms of # of pages</li>\n</ul>\n<p>Example databases:</p>\n<p>-&gt; M = 1000, m = 100,000</p>\n<p>-&gt; N = 500, n = 40,000</p>\n<p>Cost Analysis:</p>\n<p>-&gt; M + (M <em> N) = 1000 + (1000 </em> 500) = 501,000 IOs</p>\n<p>-&gt; At 0.1 ms/IO, Total time = 50 seconds</p>\n<p>What if we have B buffers available?</p>\n<p>-&gt; Use B-2 buffers for scanning the outer table.</p>\n<p>-&gt; Use one buffer for the inner table, one buffer for storing output.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foreach B - 2 blocks b(R) ∈ R</span><br><span class=\"line\">\tforeach block b(S) ∈ S</span><br><span class=\"line\">\t\tforeach tuple r ∈ b(R)</span><br><span class=\"line\">\t\t\tforeach\ttuple s ∈ b(S)</span><br><span class=\"line\">\t\t\t\temit , if r and s match</span><br></pre></td></tr></table></figure>\n<p>This algorithm uses B-2 buffers for scanning R.</p>\n<p>Cost: M + ([M / (B - 2)] * N) (向上取整)</p>\n<p>What of the outer relation completely fits in memory(B &gt; M + 2)?</p>\n<p>-&gt; Cost: M + N = 1000 + 500 = 1500 IOs</p>\n<p>-&gt; At 0.1 ms/IO, Total time = 0.15 seconds</p>\n<h5 id=\"Index-nested（嵌套的）-loop-join\"><a href=\"#Index-nested（嵌套的）-loop-join\" class=\"headerlink\" title=\"Index nested（嵌套的） loop join\"></a>Index nested（嵌套的） loop join</h5><p>Why do basic nested  loop joins suck ass(很糟糕)?</p>\n<ul>\n<li>For each tuple in the outer table, we have to do a sequential(顺序的) scan to check for a match in the inner table.</li>\n</ul>\n<p>Can we accelerate(加快) the join using an index?</p>\n<p>Use an index to find inner table matches.</p>\n<ul>\n<li>We could use an existing index for the join.</li>\n<li>Or even build one on the fly.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foreach tuple r ∈ R:</span><br><span class=\"line\">\tforeach tuple s ∈ Index r(i) = s(j)):</span><br><span class=\"line\">\t\temit , if r and s match</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/INDEX-NESTED-LOOP-JOIN-1.png\" alt=\"INDEX-NESTED-LOOP-JOIN-1\"></p>\n<p>Assume the cost of each index probe is some constant C per tuple.</p>\n<p>Cost: M + (m * C)</p>\n<h5 id=\"Nested-loop-join\"><a href=\"#Nested-loop-join\" class=\"headerlink\" title=\"Nested loop join\"></a>Nested loop join</h5><p>Pick the smaller table as the outer table.</p>\n<p>Buffer as much of the outer table in memory as possible.</p>\n<p>Loop over the inner table or use an index.</p>\n<h5 id=\"Sort-merge-join\"><a href=\"#Sort-merge-join\" class=\"headerlink\" title=\"Sort-merge join\"></a>Sort-merge join</h5><p>Phase #1: Sort</p>\n<ul>\n<li>Sort both tables on the join key(s).</li>\n<li>Can use the external merge sort algorithm that we talked about last class.</li>\n</ul>\n<p>Phase #2: Merge</p>\n<ul>\n<li>Step through the two sorted tables in parallel, and emit matching tuples.</li>\n<li>My need to backtrack(回溯) depending on the join type.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort R,S on join keys</span><br><span class=\"line\">cursor(R) &lt;- R(sorted), cursor(S)&lt;- S(sorted)</span><br><span class=\"line\">while cursor(R) and cursor(S)</span><br><span class=\"line\">\tif cursor(R) &gt; cursor(S):</span><br><span class=\"line\">\t\tincrement cursor(S)</span><br><span class=\"line\">\tif cursor(R) &lt; cursor(S):</span><br><span class=\"line\">\t\tincrement cursor(R)</span><br><span class=\"line\">\telif cursor(R) and cursor(S) matcg:</span><br><span class=\"line\">\t\temit</span><br><span class=\"line\">\t\tincrement cursor(S)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-1.png\" alt=\"SORT-MERGE-JOIN-1\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-2.png\" alt=\"SORT-MERGE-JOIN-2\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-3.png\" alt=\"SORT-MERGE-JOIN-3\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-4.png\" alt=\"SORT-MERGE-JOIN-4\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-5.png\" alt=\"SORT-MERGE-JOIN-5\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-6.png\" alt=\"SORT-MERGE-JOIN-6\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-7.png\" alt=\"SORT-MERGE-JOIN-7\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-8.png\" alt=\"SORT-MERGE-JOIN-8\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-9.png\" alt=\"SORT-MERGE-JOIN-9\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-10.png\" alt=\"SORT-MERGE-JOIN-10\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-11.png\" alt=\"SORT-MERGE-JOIN-11\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-12.png\" alt=\"SORT-MERGE-JOIN-12\"></p>\n<p>Sort Cost(R): 2M * (log M / log B)</p>\n<p>Sort Cost(S): 2N * (log N / log B)</p>\n<p>Merge Cost: (M + N)</p>\n<p>Total Cost: Sort + Merge</p>\n<p>Example database:</p>\n<p>-&gt; M = 1000, m = 100,000</p>\n<p>-&gt; N= 500, n = 40,000</p>\n<p>With 100 buffer pages, both R and S can be sorted in two passes:</p>\n<ul>\n<li>Sort Cost(R) = 2000 * (log 1000 / log 100) = 3000 IOs</li>\n<li>Sort Cost(S) = 1000 * (log 500 / log 100) = 1350 IOs</li>\n<li>Merge Cost = (1000 + 500) = 1500 IOs</li>\n<li>Total Cost = 3000 + 1350 + 1500 = 5850 IOs</li>\n<li>At 0.1 ms/IO, Total time = 0.59 seconds</li>\n</ul>\n<p>Cost: (M * N) + (sort cost)</p>\n<h5 id=\"When-is-sort-merge-join-useful\"><a href=\"#When-is-sort-merge-join-useful\" class=\"headerlink\" title=\"When is sort-merge join useful?\"></a>When is sort-merge join useful?</h5><p>One or both tables are already sorted on join key.</p>\n<p>Output must be sorted on join key.</p>\n<p>The input relations may be sorted by either by an explicit(明确的) sort operator, or by scanning the relation using an index on the join key.</p>\n<h5 id=\"Hash-join\"><a href=\"#Hash-join\" class=\"headerlink\" title=\"Hash join\"></a>Hash join</h5><p>If tuple <strong>r ∈ R</strong> and a tuple <strong>s ∈ S</strong> satisfy（满足） the join condition（条件）, then they have the same value for the join attributes.</p>\n<p>If that value is hashed to some value i, the R tuple has to be in r(i) and the S tuple in s(i).</p>\n<p>Therefore, R tuples in r(i) need only to be compared with S tuples in s(i).</p>\n<h5 id=\"Basic-hash-join-algorithm\"><a href=\"#Basic-hash-join-algorithm\" class=\"headerlink\" title=\"Basic hash join algorithm\"></a>Basic hash join algorithm</h5><p>Phase #1: Build</p>\n<p>Scan the outer relation and populate a hash table using the hash function h1 on join attributes.</p>\n<p>Phase #2: Probe</p>\n<p>Scan the inner relation and use h1 on each tuple to jump to a location in the hash table and find a matching tuple.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build hash table HT(R) for R</span><br><span class=\"line\">foreach\ttuple s ∈ S</span><br><span class=\"line\">\toutput , if h1 (s) ∈ HT(R)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/BASIC-HASH-JOIN-ALGORITHM-1.png\" alt=\"BASIC-HASH-JOIN-ALGORITHM-1\"></p>\n<h5 id=\"Hash-table-contents\"><a href=\"#Hash-table-contents\" class=\"headerlink\" title=\"Hash table contents\"></a>Hash table contents</h5><p>Key: The attribute(s) that the query is joining the tables on.</p>\n<p>Value: Varies per implementation.</p>\n<p>Depends on what the operators above the join in the query plan expect as its input.</p>\n<h5 id=\"Hash-table-values\"><a href=\"#Hash-table-values\" class=\"headerlink\" title=\"Hash table values\"></a>Hash table values</h5><p>Approach #1: Full Tuple</p>\n<p>Avoid having to retrieve(检索) the outer relation’s tuple contents on a match.</p>\n<p>Takes up more space in memory.</p>\n<p>Approach #2: Tuple Identifier</p>\n<p>Ideal for column stores because the DBMS doesn’t fetch data from disk it doesn’t need.</p>\n<p>Also better if join selectivity(选择性) is low.</p>\n<h5 id=\"Hash-join-1\"><a href=\"#Hash-join-1\" class=\"headerlink\" title=\"Hash join\"></a>Hash join</h5><p>What happens if we do not have enough memory to fit the entire hash table?</p>\n<p>We do not want to let the buffer pool manager swap out the hash table pages at a random.</p>\n<h5 id=\"Grace-hash-join\"><a href=\"#Grace-hash-join\" class=\"headerlink\" title=\"Grace hash join\"></a>Grace hash join</h5><p>Hash join when tables don’t fit in memory.</p>\n<p>Build Phase: Hash both tables on the join attribute into partitions(分区)</p>\n<p>Probe(查看) Phase: Compares tuples in corresponding(相应的) partitions for each table.</p>\n<p>Named after the GRACE database machine from Japan.</p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-1.png\" alt=\"GRACE-HASH-JOIN-1\"></p>\n<p>Hash R into (0,1,…,max) buckets.</p>\n<p>Hash S into the same # of buckets with the same hash fuction.</p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-2.png\" alt=\"GRACE-HASH-JOIN-2\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-3.png\" alt=\"GRACE-HASH-JOIN-3\"></p>\n<p>If the buckets do not fit in memory, then use recursive(递归的) partitioning to split the tables into chunks that will fit.</p>\n<p>Build another hash table for bucket(R,i) using hash function h2 (with h2 != h1)</p>\n<p>Then probe it for each tuple of the other table’s bucket at that level.</p>\n<h5 id=\"Recursive-partitioning\"><a href=\"#Recursive-partitioning\" class=\"headerlink\" title=\"Recursive partitioning\"></a>Recursive partitioning</h5><p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-1.png\" alt=\"RECURSIVE-PARTITIONING-1\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-2.png\" alt=\"RECURSIVE-PARTITIONING-2\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-3.png\" alt=\"RECURSIVE-PARTITIONING-3\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-4.png\" alt=\"RECURSIVE-PARTITIONING-4\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-5.png\" alt=\"RECURSIVE-PARTITIONING-5\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-6.png\" alt=\"RECURSIVE-PARTITIONING-6\"></p>\n<p>Cost of hash join?</p>\n<p>Assume that we have enough buffers.</p>\n<p>Cost: 3(M + N)</p>\n<p>Partitioning Phase:</p>\n<p>Read + Write both tables</p>\n<p>2(M + N) IOs</p>\n<p>Probing Phase:</p>\n<p>Read both tables</p>\n<p>M + N IOs</p>\n<p>Example database:</p>\n<p>M = 1000, m = 100,000</p>\n<p>N = 500, n = 40,000</p>\n<p>Cost analysis:</p>\n<p>3 <em> (M + N) = 3 </em> (1000 + 500) = 4,500 IOs</p>\n<p>At 0.1 ms/IO, Total time = 0.45 seconds</p>\n<h5 id=\"Join-algorithms-summary\"><a href=\"#Join-algorithms-summary\" class=\"headerlink\" title=\"Join algorithms: summary\"></a>Join algorithms: summary</h5><table>\n<thead>\n<tr>\n<th><strong>Algorithm</strong></th>\n<th><strong>IO Cost</strong></th>\n<th><strong>Example</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Simple Nested Loop Join</td>\n<td><strong>M+ (m * N)</strong></td>\n<td>1.3 hours</td>\n</tr>\n<tr>\n<td>Block Nested Loop Join</td>\n<td><strong>M+ (M * N)</strong></td>\n<td>50 seconds</td>\n</tr>\n<tr>\n<td>Index Nested Loop Join</td>\n<td><strong>M+ (m * C)</strong></td>\n<td>~20 seconds</td>\n</tr>\n<tr>\n<td>Sort-Merge Join</td>\n<td><strong>M+ N+ (sort cost)</strong></td>\n<td>0.59 seconds</td>\n</tr>\n<tr>\n<td>Hash Join</td>\n<td><strong>3(M+ N)</strong></td>\n<td>0.45 seconds</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"Why-do-we-need-to-join\"><a href=\"#Why-do-we-need-to-join\" class=\"headerlink\" title=\"Why do we need to join?\"></a>Why do we need to join?</h5><p>We normalize(标准化) tables in a relational database to avoid unnecessary repetition(重复) of information.</p>\n<p>We use the join operate to reconstruct(重建) the original tuples without any information loss.</p>\n<h5 id=\"Normalized-tables\"><a href=\"#Normalized-tables\" class=\"headerlink\" title=\"Normalized tables\"></a>Normalized tables</h5><p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/Normalized-tables.png\" alt=\"Normalized-tables\"></p>\n<h5 id=\"Join-Algorithms\"><a href=\"#Join-Algorithms\" class=\"headerlink\" title=\"Join Algorithms\"></a>Join Algorithms</h5><p>We will focus on joining two tables at a time. In general, we want the smaller table to always be the outer table.</p>\n<h5 id=\"Join-Operator-Output\"><a href=\"#Join-Operator-Output\" class=\"headerlink\" title=\"Join Operator Output\"></a>Join Operator Output</h5><p>For a tuple r belong to R and a tuple s belong to S that match on join attributes, concatenate(连接) r and s together into a new tuple.</p>\n<p>Contents can vary(变化):</p>\n<ul>\n<li>Depends on processing model</li>\n<li>Depends on storage model</li>\n<li>Depends on the query</li>\n</ul>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/Join-OPERATOR-1.png\" alt=\"Join-OPERATOR-1\"></p>\n<h5 id=\"Join-operator-output-data\"><a href=\"#Join-operator-output-data\" class=\"headerlink\" title=\"Join operator output: data\"></a>Join operator output: data</h5><p>Copy the values for the attributes in outer and inner tuples into a new output tuple.</p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-1.png\" alt=\"JOIN-OPERATOR-OUTPUT-DATA-1\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-2.png\" alt=\"JOIN-OPERATOR-OUTPUT-DATA-2\"></p>\n<p>Subsequent operators in the query plan never need to go back to the base tables to get more data.</p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-3.png\" alt=\"JOIN-OPERATOR-OUTPUT-DATA-3\"></p>\n<h5 id=\"Join-Operator-output-record-ids\"><a href=\"#Join-Operator-output-record-ids\" class=\"headerlink\" title=\"Join Operator output: record ids\"></a>Join Operator output: record ids</h5><p>Only copy the joins keys along with the record ids of the matching tuples.</p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-1.png\" alt=\"JOIN-OPERATOR-OUTPUT-RECORD-IDS-1\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-2.png\" alt=\"JOIN-OPERATOR-OUTPUT-RECORD-IDS-2\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-3.png\" alt=\"JOIN-OPERATOR-OUTPUT-RECORD-IDS-3\"></p>\n<p>Ideal for column stores because the DBMS does not copy data that is not need for the query.</p>\n<p>This is called late materialization.</p>\n<h5 id=\"Simple-nested-loop-join\"><a href=\"#Simple-nested-loop-join\" class=\"headerlink\" title=\"Simple nested loop join\"></a>Simple nested loop join</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foreach tuple r ∈ R : &lt;- Outer</span><br><span class=\"line\">\tforeach tuple s ∈ S : &lt;- Inner</span><br><span class=\"line\">\t emit , if r and s match</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SIMPLE-NESTED-LOOP-JOIN-1.png\" alt=\"SIMPLE-NESTED-LOOP-JOIN-1\"></p>\n<p>Why is this algorithm bad?</p>\n<p>-&gt; For every tuple in R, it scans S once</p>\n<p><strong>Cost：M + (m * N)</strong></p>\n<p>Example database:</p>\n<p>-&gt; M = 1000, m = 100,000</p>\n<p>-&gt; N = 500, n = 40,000</p>\n<p>Cost Analysis:</p>\n<p>-&gt; M + (m <em> N) = 1000 + (100000 </em> 500) = 50,000,100 IOs</p>\n<p>-&gt; At 0.1 ms/IO, Total time = 1.3 hours</p>\n<p>What if smaller table（S）is used as the outer table?</p>\n<p>-&gt; N + (n <em> M) = 500 + (40000 </em> 1000) = 40,000,500 Ios</p>\n<p>-&gt; At 0.1 ms/IO, Total time = 1.1 hours</p>\n<h5 id=\"Block-nested-嵌套-loop-join\"><a href=\"#Block-nested-嵌套-loop-join\" class=\"headerlink\" title=\"Block nested(嵌套) loop join\"></a>Block nested(嵌套) loop join</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foreach block BR ∈ R:</span><br><span class=\"line\">\tforeach block BS ∈ S:</span><br><span class=\"line\">\t\tforeach tuple r ∈ BR:</span><br><span class=\"line\">\t\t\tforeach tuple s ∈ Bs:</span><br><span class=\"line\">\t\t\t\temit, if r and s match</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/BLOCK-NESTED-LOOP-JOIN-1.png\" alt=\"BLOCK-NESTED-LOOP-JOIN-1\"></p>\n<p>This algorithm performs fewer disk accesses.</p>\n<p>-&gt; for every block in R, it scans S one</p>\n<p>Cost: M + (M* N)</p>\n<p>Which one should be the outter table?</p>\n<ul>\n<li>The smaller table in terms of # of pages</li>\n</ul>\n<p>Example databases:</p>\n<p>-&gt; M = 1000, m = 100,000</p>\n<p>-&gt; N = 500, n = 40,000</p>\n<p>Cost Analysis:</p>\n<p>-&gt; M + (M <em> N) = 1000 + (1000 </em> 500) = 501,000 IOs</p>\n<p>-&gt; At 0.1 ms/IO, Total time = 50 seconds</p>\n<p>What if we have B buffers available?</p>\n<p>-&gt; Use B-2 buffers for scanning the outer table.</p>\n<p>-&gt; Use one buffer for the inner table, one buffer for storing output.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foreach B - 2 blocks b(R) ∈ R</span><br><span class=\"line\">\tforeach block b(S) ∈ S</span><br><span class=\"line\">\t\tforeach tuple r ∈ b(R)</span><br><span class=\"line\">\t\t\tforeach\ttuple s ∈ b(S)</span><br><span class=\"line\">\t\t\t\temit , if r and s match</span><br></pre></td></tr></table></figure>\n<p>This algorithm uses B-2 buffers for scanning R.</p>\n<p>Cost: M + ([M / (B - 2)] * N) (向上取整)</p>\n<p>What of the outer relation completely fits in memory(B &gt; M + 2)?</p>\n<p>-&gt; Cost: M + N = 1000 + 500 = 1500 IOs</p>\n<p>-&gt; At 0.1 ms/IO, Total time = 0.15 seconds</p>\n<h5 id=\"Index-nested（嵌套的）-loop-join\"><a href=\"#Index-nested（嵌套的）-loop-join\" class=\"headerlink\" title=\"Index nested（嵌套的） loop join\"></a>Index nested（嵌套的） loop join</h5><p>Why do basic nested  loop joins suck ass(很糟糕)?</p>\n<ul>\n<li>For each tuple in the outer table, we have to do a sequential(顺序的) scan to check for a match in the inner table.</li>\n</ul>\n<p>Can we accelerate(加快) the join using an index?</p>\n<p>Use an index to find inner table matches.</p>\n<ul>\n<li>We could use an existing index for the join.</li>\n<li>Or even build one on the fly.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foreach tuple r ∈ R:</span><br><span class=\"line\">\tforeach tuple s ∈ Index r(i) = s(j)):</span><br><span class=\"line\">\t\temit , if r and s match</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/INDEX-NESTED-LOOP-JOIN-1.png\" alt=\"INDEX-NESTED-LOOP-JOIN-1\"></p>\n<p>Assume the cost of each index probe is some constant C per tuple.</p>\n<p>Cost: M + (m * C)</p>\n<h5 id=\"Nested-loop-join\"><a href=\"#Nested-loop-join\" class=\"headerlink\" title=\"Nested loop join\"></a>Nested loop join</h5><p>Pick the smaller table as the outer table.</p>\n<p>Buffer as much of the outer table in memory as possible.</p>\n<p>Loop over the inner table or use an index.</p>\n<h5 id=\"Sort-merge-join\"><a href=\"#Sort-merge-join\" class=\"headerlink\" title=\"Sort-merge join\"></a>Sort-merge join</h5><p>Phase #1: Sort</p>\n<ul>\n<li>Sort both tables on the join key(s).</li>\n<li>Can use the external merge sort algorithm that we talked about last class.</li>\n</ul>\n<p>Phase #2: Merge</p>\n<ul>\n<li>Step through the two sorted tables in parallel, and emit matching tuples.</li>\n<li>My need to backtrack(回溯) depending on the join type.</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort R,S on join keys</span><br><span class=\"line\">cursor(R) &lt;- R(sorted), cursor(S)&lt;- S(sorted)</span><br><span class=\"line\">while cursor(R) and cursor(S)</span><br><span class=\"line\">\tif cursor(R) &gt; cursor(S):</span><br><span class=\"line\">\t\tincrement cursor(S)</span><br><span class=\"line\">\tif cursor(R) &lt; cursor(S):</span><br><span class=\"line\">\t\tincrement cursor(R)</span><br><span class=\"line\">\telif cursor(R) and cursor(S) matcg:</span><br><span class=\"line\">\t\temit</span><br><span class=\"line\">\t\tincrement cursor(S)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-1.png\" alt=\"SORT-MERGE-JOIN-1\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-2.png\" alt=\"SORT-MERGE-JOIN-2\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-3.png\" alt=\"SORT-MERGE-JOIN-3\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-4.png\" alt=\"SORT-MERGE-JOIN-4\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-5.png\" alt=\"SORT-MERGE-JOIN-5\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-6.png\" alt=\"SORT-MERGE-JOIN-6\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-7.png\" alt=\"SORT-MERGE-JOIN-7\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-8.png\" alt=\"SORT-MERGE-JOIN-8\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-9.png\" alt=\"SORT-MERGE-JOIN-9\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-10.png\" alt=\"SORT-MERGE-JOIN-10\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-11.png\" alt=\"SORT-MERGE-JOIN-11\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-12.png\" alt=\"SORT-MERGE-JOIN-12\"></p>\n<p>Sort Cost(R): 2M * (log M / log B)</p>\n<p>Sort Cost(S): 2N * (log N / log B)</p>\n<p>Merge Cost: (M + N)</p>\n<p>Total Cost: Sort + Merge</p>\n<p>Example database:</p>\n<p>-&gt; M = 1000, m = 100,000</p>\n<p>-&gt; N= 500, n = 40,000</p>\n<p>With 100 buffer pages, both R and S can be sorted in two passes:</p>\n<ul>\n<li>Sort Cost(R) = 2000 * (log 1000 / log 100) = 3000 IOs</li>\n<li>Sort Cost(S) = 1000 * (log 500 / log 100) = 1350 IOs</li>\n<li>Merge Cost = (1000 + 500) = 1500 IOs</li>\n<li>Total Cost = 3000 + 1350 + 1500 = 5850 IOs</li>\n<li>At 0.1 ms/IO, Total time = 0.59 seconds</li>\n</ul>\n<p>Cost: (M * N) + (sort cost)</p>\n<h5 id=\"When-is-sort-merge-join-useful\"><a href=\"#When-is-sort-merge-join-useful\" class=\"headerlink\" title=\"When is sort-merge join useful?\"></a>When is sort-merge join useful?</h5><p>One or both tables are already sorted on join key.</p>\n<p>Output must be sorted on join key.</p>\n<p>The input relations may be sorted by either by an explicit(明确的) sort operator, or by scanning the relation using an index on the join key.</p>\n<h5 id=\"Hash-join\"><a href=\"#Hash-join\" class=\"headerlink\" title=\"Hash join\"></a>Hash join</h5><p>If tuple <strong>r ∈ R</strong> and a tuple <strong>s ∈ S</strong> satisfy（满足） the join condition（条件）, then they have the same value for the join attributes.</p>\n<p>If that value is hashed to some value i, the R tuple has to be in r(i) and the S tuple in s(i).</p>\n<p>Therefore, R tuples in r(i) need only to be compared with S tuples in s(i).</p>\n<h5 id=\"Basic-hash-join-algorithm\"><a href=\"#Basic-hash-join-algorithm\" class=\"headerlink\" title=\"Basic hash join algorithm\"></a>Basic hash join algorithm</h5><p>Phase #1: Build</p>\n<p>Scan the outer relation and populate a hash table using the hash function h1 on join attributes.</p>\n<p>Phase #2: Probe</p>\n<p>Scan the inner relation and use h1 on each tuple to jump to a location in the hash table and find a matching tuple.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build hash table HT(R) for R</span><br><span class=\"line\">foreach\ttuple s ∈ S</span><br><span class=\"line\">\toutput , if h1 (s) ∈ HT(R)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/BASIC-HASH-JOIN-ALGORITHM-1.png\" alt=\"BASIC-HASH-JOIN-ALGORITHM-1\"></p>\n<h5 id=\"Hash-table-contents\"><a href=\"#Hash-table-contents\" class=\"headerlink\" title=\"Hash table contents\"></a>Hash table contents</h5><p>Key: The attribute(s) that the query is joining the tables on.</p>\n<p>Value: Varies per implementation.</p>\n<p>Depends on what the operators above the join in the query plan expect as its input.</p>\n<h5 id=\"Hash-table-values\"><a href=\"#Hash-table-values\" class=\"headerlink\" title=\"Hash table values\"></a>Hash table values</h5><p>Approach #1: Full Tuple</p>\n<p>Avoid having to retrieve(检索) the outer relation’s tuple contents on a match.</p>\n<p>Takes up more space in memory.</p>\n<p>Approach #2: Tuple Identifier</p>\n<p>Ideal for column stores because the DBMS doesn’t fetch data from disk it doesn’t need.</p>\n<p>Also better if join selectivity(选择性) is low.</p>\n<h5 id=\"Hash-join-1\"><a href=\"#Hash-join-1\" class=\"headerlink\" title=\"Hash join\"></a>Hash join</h5><p>What happens if we do not have enough memory to fit the entire hash table?</p>\n<p>We do not want to let the buffer pool manager swap out the hash table pages at a random.</p>\n<h5 id=\"Grace-hash-join\"><a href=\"#Grace-hash-join\" class=\"headerlink\" title=\"Grace hash join\"></a>Grace hash join</h5><p>Hash join when tables don’t fit in memory.</p>\n<p>Build Phase: Hash both tables on the join attribute into partitions(分区)</p>\n<p>Probe(查看) Phase: Compares tuples in corresponding(相应的) partitions for each table.</p>\n<p>Named after the GRACE database machine from Japan.</p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-1.png\" alt=\"GRACE-HASH-JOIN-1\"></p>\n<p>Hash R into (0,1,…,max) buckets.</p>\n<p>Hash S into the same # of buckets with the same hash fuction.</p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-2.png\" alt=\"GRACE-HASH-JOIN-2\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-3.png\" alt=\"GRACE-HASH-JOIN-3\"></p>\n<p>If the buckets do not fit in memory, then use recursive(递归的) partitioning to split the tables into chunks that will fit.</p>\n<p>Build another hash table for bucket(R,i) using hash function h2 (with h2 != h1)</p>\n<p>Then probe it for each tuple of the other table’s bucket at that level.</p>\n<h5 id=\"Recursive-partitioning\"><a href=\"#Recursive-partitioning\" class=\"headerlink\" title=\"Recursive partitioning\"></a>Recursive partitioning</h5><p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-1.png\" alt=\"RECURSIVE-PARTITIONING-1\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-2.png\" alt=\"RECURSIVE-PARTITIONING-2\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-3.png\" alt=\"RECURSIVE-PARTITIONING-3\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-4.png\" alt=\"RECURSIVE-PARTITIONING-4\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-5.png\" alt=\"RECURSIVE-PARTITIONING-5\"></p>\n<p><img src=\"/2019/06/09/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-6.png\" alt=\"RECURSIVE-PARTITIONING-6\"></p>\n<p>Cost of hash join?</p>\n<p>Assume that we have enough buffers.</p>\n<p>Cost: 3(M + N)</p>\n<p>Partitioning Phase:</p>\n<p>Read + Write both tables</p>\n<p>2(M + N) IOs</p>\n<p>Probing Phase:</p>\n<p>Read both tables</p>\n<p>M + N IOs</p>\n<p>Example database:</p>\n<p>M = 1000, m = 100,000</p>\n<p>N = 500, n = 40,000</p>\n<p>Cost analysis:</p>\n<p>3 <em> (M + N) = 3 </em> (1000 + 500) = 4,500 IOs</p>\n<p>At 0.1 ms/IO, Total time = 0.45 seconds</p>\n<h5 id=\"Join-algorithms-summary\"><a href=\"#Join-algorithms-summary\" class=\"headerlink\" title=\"Join algorithms: summary\"></a>Join algorithms: summary</h5><table>\n<thead>\n<tr>\n<th><strong>Algorithm</strong></th>\n<th><strong>IO Cost</strong></th>\n<th><strong>Example</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Simple Nested Loop Join</td>\n<td><strong>M+ (m * N)</strong></td>\n<td>1.3 hours</td>\n</tr>\n<tr>\n<td>Block Nested Loop Join</td>\n<td><strong>M+ (M * N)</strong></td>\n<td>50 seconds</td>\n</tr>\n<tr>\n<td>Index Nested Loop Join</td>\n<td><strong>M+ (m * C)</strong></td>\n<td>~20 seconds</td>\n</tr>\n<tr>\n<td>Sort-Merge Join</td>\n<td><strong>M+ N+ (sort cost)</strong></td>\n<td>0.59 seconds</td>\n</tr>\n<tr>\n<td>Hash Join</td>\n<td><strong>3(M+ N)</strong></td>\n<td>0.45 seconds</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"CMU-DBMS-COURSE-13-NOTES","date":"2019-06-13T04:27:50.000Z","_content":"\n##### IBM SYSTEM R\n\nFirst implementation of a query optimizer.\n\nPeople argued that the DBMS could never choose a query plan better than what a human could write.\n\nA lot of the concepts from System R's optimizer are still used today.\n\n##### Query optimization\n\nHeuristics(启发) / Rules\n\nRewrite the query to remove stupid / inefficient things.\n\nDoes not require a cost model.\n\nCost-based Search\n\nUse a cost model to evaluate multiple equivalent（相同）plans and pick the one with the lowest cost.\n\n##### Query planning overview\n\n![QUERY-PLANNING-OVERVIEW](CMU-DBMS-COURSE-13-NOTES/QUERY-PLANNING-OVERVIEW.png)\n\n##### Relational algebra equivalences（关系代数等价）\n\nTwo relational algebra expressions are equivalent if they generate the same set of tuples.\n\nThe DBMS can identify better query plans without a cost model.\n\nThis is often called query rewriting\n\n##### Predicate pushdown（谓词下推）\n\n```\nSELECT s.name, e.cid\nFROM student AS a, enrolled AS e\nWHERE a.sid = e.sid\nAND e.grade = 'A'\n```\n\n![PREDICATE-PUSHDOWN](CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN.png)\n\n\n\n![PREDICATE-PUSHDOWN-2](CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN-2.png)\n\n##### Relational algebra equivalences（关系代数等价）\n\nSelections\n\nPerform filters as early as possible\n\nRecorder predicates so that the DBMS applies the most selective one first.\n\nBreak a complex predicate, and push down\n\n![关系代数等价](CMU-DBMS-COURSE-13-NOTES/关系代数等价.png)\n\nSimplify a complex predicate（谓词）\n\n(X = Y AND Y = 3) -> X = 3 AND Y = 3\n\n**Projections(预测)**\n\n- Perform them early to create smaller tuples and reduce intermediate(中间的) results (if duplicates are eliminated（消除）)\n- Project out all attributes except(除了) the ones requested or required(e.g., joining keys)\n\n##### Predicate pushdown（谓词下推）\n\n```\nSELECT s.name, e.cid\nFROM student AS s, enrolled AS e\nWHERE s.sid = e.sid\nAND e.grade = 'A'\n```\n\n![PROJECTION-PUSHDOWN-2](CMU-DBMS-COURSE-13-NOTES/PROJECTION-PUSHDOWN-2.png)\n\nImpossible / Unnecessary Predicates\n\n```\nSELECT * FROM A WHERE 1 = 0;\n```\n\n```\nSELECT * FROM A WHERE 1 = 1;\n```\n\nJoin Elimination\n\n```\nSELECT A1.*\nFROM A AS A1 JOIN A AS A2\nON A1.id = A2.id;\n```\n\n```\nSELECT * FROM A;\n```\n\nMerging Predicates\n\n```\nSELECT * FROM A\nWHERE val BETWEEN 1 AND 100\nOR val BETWEEN 50 AND 150;\n```\n\n```\nSELECT * FROM A\nWHERE val BETWEEN 1 AND 150;\n```\n\n##### Relational algebra equivalences（关系代数等价）\n\n**Joins**\n\nCommutative(交换的)，associative(结合的)\n\n##### Cost estimation (估算)\n\nHow long will a query take?\n\n-> CPU: Small cost; tough to estimate\n\n-> Disk: #of block transfers\n\n-> Memory: Amount of DRAM used\n\n-> Network: # of messages\n\n##### Statistics(统计信息)\n\nThe DBMS stores internal statistic about tables, attributes, and indexes in its internal catalog.\n\nDifferent systems update them at different times.\n\nManual invocations: （手动调用）\n\n-> Postgres / SQLite: ANALYZE\n\n-> Oracle / MySQL: ANALYZE TABLE\n\n-> SQL Server: UPDATE STATISTICS\n\n-> DB2: RUNSTATS\n\nFor each relation R , the DBMS maintains the following information:\n\n-> N(R) : Number of tuples in R.\n\n-> V(A, R) : Number of distinct(有区别的) values for attribute A\n\n##### Derivable statistics (可推导的统计)\n\nThe selection cardinality (选择基数) SC (A, R) is the average number of records with a value for an attribute A given N(R) / V(A, R)\n\n##### Selection statistics\n\nEquality predicates on unique keys are easy to estimate.\n\n```\nSELECT * FROM people WHERE id = 123\n```\n\n```\nSELECT * FROM people WHERE val > 1000\n```\n\n```\nSELECT * FROM people WHERE age = 30 AND status = 'Lit'\n```\n\nThe selectivity (选择性) (sel) of a predicate P is the fraction(分数) of tuples that qualify(符合条件)\n\nFormula(公式) depends on type of predicate:\n\n-> Equality \n\n-> Range\n\n-> Negation （取反）\n\n-> Conjunction （连接词）\n\n-> Disjunction （逻辑或）\n\n##### Selections - complex predicates\n\nAssume that V(age, people) has five distinct values (0-4) and N(R) = 5\n\n**Equality Predicate: A = constant**\n\nsel(A = constant) = SC(P) / V(A, R)\n\nExample: sel(age = 2) =\n\n```\nSELECT * FROM people WHERE age = 2\n```\n\n![SC-1](CMU-DBMS-COURSE-13-NOTES/SC-1.png)\n\n**Range Query**\n\nsel(A >= a) = (A(max) - a) / (A(max) - A(min))\n\nExample: sel(age >= 2) = (4 - 2) / (4 - 0) = 1 / 2\n\n```\nSELECT * FROM people WHERE age >= 2\n```\n\n![SC-2](CMU-DBMS-COURSE-13-NOTES/SC-2.png)\n\n**Negation Query**\n\nsel ( not P ) = 1 - sel( p )\n\nExample: sel ( age != 2 )\n\n```\nSELECT * FROM people WHERE age != 2\n```\n\n![SC-3](CMU-DBMS-COURSE-13-NOTES/SC-3.png)\n\n![SC-4](CMU-DBMS-COURSE-13-NOTES/SC-4.png)\n\n*Observation: Selectivity ~= Probability*\n\n**Conjunction**\n\nsel (P1 ^ P2) = sel(P1) * sel(P2)\n\nsel (age = 2 ^ name LIKE 'A%' )\n\n```\nSELECT * FROM people WHERE age = 2 AND name LIKE 'A%'\n```\n\n![Conjunction](CMU-DBMS-COURSE-13-NOTES/Conjunction.png)\n\n**Disjunction**\n\nsel(P1 U P2) \n\n= sel(P1) + sel(P2) - sel(P1 ^ P2)\n\n= sel(P1) + sel(P2) - sel(P1) * sel(P2)\n\n-> sel(age = 2 OR name LIKE 'A%')\n\n```\nSELECT * FROM people WHERE age = 2 OR name LIKE 'A%'\n```\n\n![Disjunction](CMU-DBMS-COURSE-13-NOTES/Disjunction.png)\n\n##### Query Optimization\n\nAfter performing rule-based rewriting, the DBMS will enumerate(列举) different plans for the query and estimate(估计) their costs.\n\nSingle relations\n\nMultiple relations\n\nNested(嵌套) sub-queries\n\nIt chooses the best plan it has been for query after exhausting(用尽) all plans or some timeout\n\nSimple heuristics(启发式) are often good enough for this\n\nOLTP queries are especially easy\n\n##### OLTP Query planning\n\nQuery planning for OLTP queries is easy because they are sargable（可分析的）\n\nSearch Argument Able\n\nIt is usually just picking the best index\n\nJoins are almost always on foreign key relationships with a small cardinality（基数）\n\nCan be implementation with simple heuristics\n\n","source":"_posts/CMU-DBMS-COURSE-13-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-13-NOTES\ndate: 2019-06-13 12:27:50\ntags:\n---\n\n##### IBM SYSTEM R\n\nFirst implementation of a query optimizer.\n\nPeople argued that the DBMS could never choose a query plan better than what a human could write.\n\nA lot of the concepts from System R's optimizer are still used today.\n\n##### Query optimization\n\nHeuristics(启发) / Rules\n\nRewrite the query to remove stupid / inefficient things.\n\nDoes not require a cost model.\n\nCost-based Search\n\nUse a cost model to evaluate multiple equivalent（相同）plans and pick the one with the lowest cost.\n\n##### Query planning overview\n\n![QUERY-PLANNING-OVERVIEW](CMU-DBMS-COURSE-13-NOTES/QUERY-PLANNING-OVERVIEW.png)\n\n##### Relational algebra equivalences（关系代数等价）\n\nTwo relational algebra expressions are equivalent if they generate the same set of tuples.\n\nThe DBMS can identify better query plans without a cost model.\n\nThis is often called query rewriting\n\n##### Predicate pushdown（谓词下推）\n\n```\nSELECT s.name, e.cid\nFROM student AS a, enrolled AS e\nWHERE a.sid = e.sid\nAND e.grade = 'A'\n```\n\n![PREDICATE-PUSHDOWN](CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN.png)\n\n\n\n![PREDICATE-PUSHDOWN-2](CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN-2.png)\n\n##### Relational algebra equivalences（关系代数等价）\n\nSelections\n\nPerform filters as early as possible\n\nRecorder predicates so that the DBMS applies the most selective one first.\n\nBreak a complex predicate, and push down\n\n![关系代数等价](CMU-DBMS-COURSE-13-NOTES/关系代数等价.png)\n\nSimplify a complex predicate（谓词）\n\n(X = Y AND Y = 3) -> X = 3 AND Y = 3\n\n**Projections(预测)**\n\n- Perform them early to create smaller tuples and reduce intermediate(中间的) results (if duplicates are eliminated（消除）)\n- Project out all attributes except(除了) the ones requested or required(e.g., joining keys)\n\n##### Predicate pushdown（谓词下推）\n\n```\nSELECT s.name, e.cid\nFROM student AS s, enrolled AS e\nWHERE s.sid = e.sid\nAND e.grade = 'A'\n```\n\n![PROJECTION-PUSHDOWN-2](CMU-DBMS-COURSE-13-NOTES/PROJECTION-PUSHDOWN-2.png)\n\nImpossible / Unnecessary Predicates\n\n```\nSELECT * FROM A WHERE 1 = 0;\n```\n\n```\nSELECT * FROM A WHERE 1 = 1;\n```\n\nJoin Elimination\n\n```\nSELECT A1.*\nFROM A AS A1 JOIN A AS A2\nON A1.id = A2.id;\n```\n\n```\nSELECT * FROM A;\n```\n\nMerging Predicates\n\n```\nSELECT * FROM A\nWHERE val BETWEEN 1 AND 100\nOR val BETWEEN 50 AND 150;\n```\n\n```\nSELECT * FROM A\nWHERE val BETWEEN 1 AND 150;\n```\n\n##### Relational algebra equivalences（关系代数等价）\n\n**Joins**\n\nCommutative(交换的)，associative(结合的)\n\n##### Cost estimation (估算)\n\nHow long will a query take?\n\n-> CPU: Small cost; tough to estimate\n\n-> Disk: #of block transfers\n\n-> Memory: Amount of DRAM used\n\n-> Network: # of messages\n\n##### Statistics(统计信息)\n\nThe DBMS stores internal statistic about tables, attributes, and indexes in its internal catalog.\n\nDifferent systems update them at different times.\n\nManual invocations: （手动调用）\n\n-> Postgres / SQLite: ANALYZE\n\n-> Oracle / MySQL: ANALYZE TABLE\n\n-> SQL Server: UPDATE STATISTICS\n\n-> DB2: RUNSTATS\n\nFor each relation R , the DBMS maintains the following information:\n\n-> N(R) : Number of tuples in R.\n\n-> V(A, R) : Number of distinct(有区别的) values for attribute A\n\n##### Derivable statistics (可推导的统计)\n\nThe selection cardinality (选择基数) SC (A, R) is the average number of records with a value for an attribute A given N(R) / V(A, R)\n\n##### Selection statistics\n\nEquality predicates on unique keys are easy to estimate.\n\n```\nSELECT * FROM people WHERE id = 123\n```\n\n```\nSELECT * FROM people WHERE val > 1000\n```\n\n```\nSELECT * FROM people WHERE age = 30 AND status = 'Lit'\n```\n\nThe selectivity (选择性) (sel) of a predicate P is the fraction(分数) of tuples that qualify(符合条件)\n\nFormula(公式) depends on type of predicate:\n\n-> Equality \n\n-> Range\n\n-> Negation （取反）\n\n-> Conjunction （连接词）\n\n-> Disjunction （逻辑或）\n\n##### Selections - complex predicates\n\nAssume that V(age, people) has five distinct values (0-4) and N(R) = 5\n\n**Equality Predicate: A = constant**\n\nsel(A = constant) = SC(P) / V(A, R)\n\nExample: sel(age = 2) =\n\n```\nSELECT * FROM people WHERE age = 2\n```\n\n![SC-1](CMU-DBMS-COURSE-13-NOTES/SC-1.png)\n\n**Range Query**\n\nsel(A >= a) = (A(max) - a) / (A(max) - A(min))\n\nExample: sel(age >= 2) = (4 - 2) / (4 - 0) = 1 / 2\n\n```\nSELECT * FROM people WHERE age >= 2\n```\n\n![SC-2](CMU-DBMS-COURSE-13-NOTES/SC-2.png)\n\n**Negation Query**\n\nsel ( not P ) = 1 - sel( p )\n\nExample: sel ( age != 2 )\n\n```\nSELECT * FROM people WHERE age != 2\n```\n\n![SC-3](CMU-DBMS-COURSE-13-NOTES/SC-3.png)\n\n![SC-4](CMU-DBMS-COURSE-13-NOTES/SC-4.png)\n\n*Observation: Selectivity ~= Probability*\n\n**Conjunction**\n\nsel (P1 ^ P2) = sel(P1) * sel(P2)\n\nsel (age = 2 ^ name LIKE 'A%' )\n\n```\nSELECT * FROM people WHERE age = 2 AND name LIKE 'A%'\n```\n\n![Conjunction](CMU-DBMS-COURSE-13-NOTES/Conjunction.png)\n\n**Disjunction**\n\nsel(P1 U P2) \n\n= sel(P1) + sel(P2) - sel(P1 ^ P2)\n\n= sel(P1) + sel(P2) - sel(P1) * sel(P2)\n\n-> sel(age = 2 OR name LIKE 'A%')\n\n```\nSELECT * FROM people WHERE age = 2 OR name LIKE 'A%'\n```\n\n![Disjunction](CMU-DBMS-COURSE-13-NOTES/Disjunction.png)\n\n##### Query Optimization\n\nAfter performing rule-based rewriting, the DBMS will enumerate(列举) different plans for the query and estimate(估计) their costs.\n\nSingle relations\n\nMultiple relations\n\nNested(嵌套) sub-queries\n\nIt chooses the best plan it has been for query after exhausting(用尽) all plans or some timeout\n\nSimple heuristics(启发式) are often good enough for this\n\nOLTP queries are especially easy\n\n##### OLTP Query planning\n\nQuery planning for OLTP queries is easy because they are sargable（可分析的）\n\nSearch Argument Able\n\nIt is usually just picking the best index\n\nJoins are almost always on foreign key relationships with a small cardinality（基数）\n\nCan be implementation with simple heuristics\n\n","slug":"CMU-DBMS-COURSE-13-NOTES","published":1,"updated":"2019-06-26T11:56:34.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyn4000fvkqpxiv07rqp","content":"<h5 id=\"IBM-SYSTEM-R\"><a href=\"#IBM-SYSTEM-R\" class=\"headerlink\" title=\"IBM SYSTEM R\"></a>IBM SYSTEM R</h5><p>First implementation of a query optimizer.</p>\n<p>People argued that the DBMS could never choose a query plan better than what a human could write.</p>\n<p>A lot of the concepts from System R’s optimizer are still used today.</p>\n<h5 id=\"Query-optimization\"><a href=\"#Query-optimization\" class=\"headerlink\" title=\"Query optimization\"></a>Query optimization</h5><p>Heuristics(启发) / Rules</p>\n<p>Rewrite the query to remove stupid / inefficient things.</p>\n<p>Does not require a cost model.</p>\n<p>Cost-based Search</p>\n<p>Use a cost model to evaluate multiple equivalent（相同）plans and pick the one with the lowest cost.</p>\n<h5 id=\"Query-planning-overview\"><a href=\"#Query-planning-overview\" class=\"headerlink\" title=\"Query planning overview\"></a>Query planning overview</h5><p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/QUERY-PLANNING-OVERVIEW.png\" alt=\"QUERY-PLANNING-OVERVIEW\"></p>\n<h5 id=\"Relational-algebra-equivalences（关系代数等价）\"><a href=\"#Relational-algebra-equivalences（关系代数等价）\" class=\"headerlink\" title=\"Relational algebra equivalences（关系代数等价）\"></a>Relational algebra equivalences（关系代数等价）</h5><p>Two relational algebra expressions are equivalent if they generate the same set of tuples.</p>\n<p>The DBMS can identify better query plans without a cost model.</p>\n<p>This is often called query rewriting</p>\n<h5 id=\"Predicate-pushdown（谓词下推）\"><a href=\"#Predicate-pushdown（谓词下推）\" class=\"headerlink\" title=\"Predicate pushdown（谓词下推）\"></a>Predicate pushdown（谓词下推）</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT s.name, e.cid</span><br><span class=\"line\">FROM student AS a, enrolled AS e</span><br><span class=\"line\">WHERE a.sid = e.sid</span><br><span class=\"line\">AND e.grade = &apos;A&apos;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN.png\" alt=\"PREDICATE-PUSHDOWN\"></p>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN-2.png\" alt=\"PREDICATE-PUSHDOWN-2\"></p>\n<h5 id=\"Relational-algebra-equivalences（关系代数等价）-1\"><a href=\"#Relational-algebra-equivalences（关系代数等价）-1\" class=\"headerlink\" title=\"Relational algebra equivalences（关系代数等价）\"></a>Relational algebra equivalences（关系代数等价）</h5><p>Selections</p>\n<p>Perform filters as early as possible</p>\n<p>Recorder predicates so that the DBMS applies the most selective one first.</p>\n<p>Break a complex predicate, and push down</p>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/关系代数等价.png\" alt=\"关系代数等价\"></p>\n<p>Simplify a complex predicate（谓词）</p>\n<p>(X = Y AND Y = 3) -&gt; X = 3 AND Y = 3</p>\n<p><strong>Projections(预测)</strong></p>\n<ul>\n<li>Perform them early to create smaller tuples and reduce intermediate(中间的) results (if duplicates are eliminated（消除）)</li>\n<li>Project out all attributes except(除了) the ones requested or required(e.g., joining keys)</li>\n</ul>\n<h5 id=\"Predicate-pushdown（谓词下推）-1\"><a href=\"#Predicate-pushdown（谓词下推）-1\" class=\"headerlink\" title=\"Predicate pushdown（谓词下推）\"></a>Predicate pushdown（谓词下推）</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT s.name, e.cid</span><br><span class=\"line\">FROM student AS s, enrolled AS e</span><br><span class=\"line\">WHERE s.sid = e.sid</span><br><span class=\"line\">AND e.grade = &apos;A&apos;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/PROJECTION-PUSHDOWN-2.png\" alt=\"PROJECTION-PUSHDOWN-2\"></p>\n<p>Impossible / Unnecessary Predicates</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM A WHERE 1 = 0;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM A WHERE 1 = 1;</span><br></pre></td></tr></table></figure>\n<p>Join Elimination</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT A1.*</span><br><span class=\"line\">FROM A AS A1 JOIN A AS A2</span><br><span class=\"line\">ON A1.id = A2.id;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM A;</span><br></pre></td></tr></table></figure>\n<p>Merging Predicates</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM A</span><br><span class=\"line\">WHERE val BETWEEN 1 AND 100</span><br><span class=\"line\">OR val BETWEEN 50 AND 150;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM A</span><br><span class=\"line\">WHERE val BETWEEN 1 AND 150;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Relational-algebra-equivalences（关系代数等价）-2\"><a href=\"#Relational-algebra-equivalences（关系代数等价）-2\" class=\"headerlink\" title=\"Relational algebra equivalences（关系代数等价）\"></a>Relational algebra equivalences（关系代数等价）</h5><p><strong>Joins</strong></p>\n<p>Commutative(交换的)，associative(结合的)</p>\n<h5 id=\"Cost-estimation-估算\"><a href=\"#Cost-estimation-估算\" class=\"headerlink\" title=\"Cost estimation (估算)\"></a>Cost estimation (估算)</h5><p>How long will a query take?</p>\n<p>-&gt; CPU: Small cost; tough to estimate</p>\n<p>-&gt; Disk: #of block transfers</p>\n<p>-&gt; Memory: Amount of DRAM used</p>\n<p>-&gt; Network: # of messages</p>\n<h5 id=\"Statistics-统计信息\"><a href=\"#Statistics-统计信息\" class=\"headerlink\" title=\"Statistics(统计信息)\"></a>Statistics(统计信息)</h5><p>The DBMS stores internal statistic about tables, attributes, and indexes in its internal catalog.</p>\n<p>Different systems update them at different times.</p>\n<p>Manual invocations: （手动调用）</p>\n<p>-&gt; Postgres / SQLite: ANALYZE</p>\n<p>-&gt; Oracle / MySQL: ANALYZE TABLE</p>\n<p>-&gt; SQL Server: UPDATE STATISTICS</p>\n<p>-&gt; DB2: RUNSTATS</p>\n<p>For each relation R , the DBMS maintains the following information:</p>\n<p>-&gt; N(R) : Number of tuples in R.</p>\n<p>-&gt; V(A, R) : Number of distinct(有区别的) values for attribute A</p>\n<h5 id=\"Derivable-statistics-可推导的统计\"><a href=\"#Derivable-statistics-可推导的统计\" class=\"headerlink\" title=\"Derivable statistics (可推导的统计)\"></a>Derivable statistics (可推导的统计)</h5><p>The selection cardinality (选择基数) SC (A, R) is the average number of records with a value for an attribute A given N(R) / V(A, R)</p>\n<h5 id=\"Selection-statistics\"><a href=\"#Selection-statistics\" class=\"headerlink\" title=\"Selection statistics\"></a>Selection statistics</h5><p>Equality predicates on unique keys are easy to estimate.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE id = 123</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE val &gt; 1000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age = 30 AND status = &apos;Lit&apos;</span><br></pre></td></tr></table></figure>\n<p>The selectivity (选择性) (sel) of a predicate P is the fraction(分数) of tuples that qualify(符合条件)</p>\n<p>Formula(公式) depends on type of predicate:</p>\n<p>-&gt; Equality </p>\n<p>-&gt; Range</p>\n<p>-&gt; Negation （取反）</p>\n<p>-&gt; Conjunction （连接词）</p>\n<p>-&gt; Disjunction （逻辑或）</p>\n<h5 id=\"Selections-complex-predicates\"><a href=\"#Selections-complex-predicates\" class=\"headerlink\" title=\"Selections - complex predicates\"></a>Selections - complex predicates</h5><p>Assume that V(age, people) has five distinct values (0-4) and N(R) = 5</p>\n<p><strong>Equality Predicate: A = constant</strong></p>\n<p>sel(A = constant) = SC(P) / V(A, R)</p>\n<p>Example: sel(age = 2) =</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age = 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/SC-1.png\" alt=\"SC-1\"></p>\n<p><strong>Range Query</strong></p>\n<p>sel(A &gt;= a) = (A(max) - a) / (A(max) - A(min))</p>\n<p>Example: sel(age &gt;= 2) = (4 - 2) / (4 - 0) = 1 / 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age &gt;= 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/SC-2.png\" alt=\"SC-2\"></p>\n<p><strong>Negation Query</strong></p>\n<p>sel ( not P ) = 1 - sel( p )</p>\n<p>Example: sel ( age != 2 )</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age != 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/SC-3.png\" alt=\"SC-3\"></p>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/SC-4.png\" alt=\"SC-4\"></p>\n<p><em>Observation: Selectivity ~= Probability</em></p>\n<p><strong>Conjunction</strong></p>\n<p>sel (P1 ^ P2) = sel(P1) * sel(P2)</p>\n<p>sel (age = 2 ^ name LIKE ‘A%’ )</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age = 2 AND name LIKE &apos;A%&apos;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/Conjunction.png\" alt=\"Conjunction\"></p>\n<p><strong>Disjunction</strong></p>\n<p>sel(P1 U P2) </p>\n<p>= sel(P1) + sel(P2) - sel(P1 ^ P2)</p>\n<p>= sel(P1) + sel(P2) - sel(P1) * sel(P2)</p>\n<p>-&gt; sel(age = 2 OR name LIKE ‘A%’)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age = 2 OR name LIKE &apos;A%&apos;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/Disjunction.png\" alt=\"Disjunction\"></p>\n<h5 id=\"Query-Optimization\"><a href=\"#Query-Optimization\" class=\"headerlink\" title=\"Query Optimization\"></a>Query Optimization</h5><p>After performing rule-based rewriting, the DBMS will enumerate(列举) different plans for the query and estimate(估计) their costs.</p>\n<p>Single relations</p>\n<p>Multiple relations</p>\n<p>Nested(嵌套) sub-queries</p>\n<p>It chooses the best plan it has been for query after exhausting(用尽) all plans or some timeout</p>\n<p>Simple heuristics(启发式) are often good enough for this</p>\n<p>OLTP queries are especially easy</p>\n<h5 id=\"OLTP-Query-planning\"><a href=\"#OLTP-Query-planning\" class=\"headerlink\" title=\"OLTP Query planning\"></a>OLTP Query planning</h5><p>Query planning for OLTP queries is easy because they are sargable（可分析的）</p>\n<p>Search Argument Able</p>\n<p>It is usually just picking the best index</p>\n<p>Joins are almost always on foreign key relationships with a small cardinality（基数）</p>\n<p>Can be implementation with simple heuristics</p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"IBM-SYSTEM-R\"><a href=\"#IBM-SYSTEM-R\" class=\"headerlink\" title=\"IBM SYSTEM R\"></a>IBM SYSTEM R</h5><p>First implementation of a query optimizer.</p>\n<p>People argued that the DBMS could never choose a query plan better than what a human could write.</p>\n<p>A lot of the concepts from System R’s optimizer are still used today.</p>\n<h5 id=\"Query-optimization\"><a href=\"#Query-optimization\" class=\"headerlink\" title=\"Query optimization\"></a>Query optimization</h5><p>Heuristics(启发) / Rules</p>\n<p>Rewrite the query to remove stupid / inefficient things.</p>\n<p>Does not require a cost model.</p>\n<p>Cost-based Search</p>\n<p>Use a cost model to evaluate multiple equivalent（相同）plans and pick the one with the lowest cost.</p>\n<h5 id=\"Query-planning-overview\"><a href=\"#Query-planning-overview\" class=\"headerlink\" title=\"Query planning overview\"></a>Query planning overview</h5><p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/QUERY-PLANNING-OVERVIEW.png\" alt=\"QUERY-PLANNING-OVERVIEW\"></p>\n<h5 id=\"Relational-algebra-equivalences（关系代数等价）\"><a href=\"#Relational-algebra-equivalences（关系代数等价）\" class=\"headerlink\" title=\"Relational algebra equivalences（关系代数等价）\"></a>Relational algebra equivalences（关系代数等价）</h5><p>Two relational algebra expressions are equivalent if they generate the same set of tuples.</p>\n<p>The DBMS can identify better query plans without a cost model.</p>\n<p>This is often called query rewriting</p>\n<h5 id=\"Predicate-pushdown（谓词下推）\"><a href=\"#Predicate-pushdown（谓词下推）\" class=\"headerlink\" title=\"Predicate pushdown（谓词下推）\"></a>Predicate pushdown（谓词下推）</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT s.name, e.cid</span><br><span class=\"line\">FROM student AS a, enrolled AS e</span><br><span class=\"line\">WHERE a.sid = e.sid</span><br><span class=\"line\">AND e.grade = &apos;A&apos;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN.png\" alt=\"PREDICATE-PUSHDOWN\"></p>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN-2.png\" alt=\"PREDICATE-PUSHDOWN-2\"></p>\n<h5 id=\"Relational-algebra-equivalences（关系代数等价）-1\"><a href=\"#Relational-algebra-equivalences（关系代数等价）-1\" class=\"headerlink\" title=\"Relational algebra equivalences（关系代数等价）\"></a>Relational algebra equivalences（关系代数等价）</h5><p>Selections</p>\n<p>Perform filters as early as possible</p>\n<p>Recorder predicates so that the DBMS applies the most selective one first.</p>\n<p>Break a complex predicate, and push down</p>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/关系代数等价.png\" alt=\"关系代数等价\"></p>\n<p>Simplify a complex predicate（谓词）</p>\n<p>(X = Y AND Y = 3) -&gt; X = 3 AND Y = 3</p>\n<p><strong>Projections(预测)</strong></p>\n<ul>\n<li>Perform them early to create smaller tuples and reduce intermediate(中间的) results (if duplicates are eliminated（消除）)</li>\n<li>Project out all attributes except(除了) the ones requested or required(e.g., joining keys)</li>\n</ul>\n<h5 id=\"Predicate-pushdown（谓词下推）-1\"><a href=\"#Predicate-pushdown（谓词下推）-1\" class=\"headerlink\" title=\"Predicate pushdown（谓词下推）\"></a>Predicate pushdown（谓词下推）</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT s.name, e.cid</span><br><span class=\"line\">FROM student AS s, enrolled AS e</span><br><span class=\"line\">WHERE s.sid = e.sid</span><br><span class=\"line\">AND e.grade = &apos;A&apos;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/PROJECTION-PUSHDOWN-2.png\" alt=\"PROJECTION-PUSHDOWN-2\"></p>\n<p>Impossible / Unnecessary Predicates</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM A WHERE 1 = 0;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM A WHERE 1 = 1;</span><br></pre></td></tr></table></figure>\n<p>Join Elimination</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT A1.*</span><br><span class=\"line\">FROM A AS A1 JOIN A AS A2</span><br><span class=\"line\">ON A1.id = A2.id;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM A;</span><br></pre></td></tr></table></figure>\n<p>Merging Predicates</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM A</span><br><span class=\"line\">WHERE val BETWEEN 1 AND 100</span><br><span class=\"line\">OR val BETWEEN 50 AND 150;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM A</span><br><span class=\"line\">WHERE val BETWEEN 1 AND 150;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Relational-algebra-equivalences（关系代数等价）-2\"><a href=\"#Relational-algebra-equivalences（关系代数等价）-2\" class=\"headerlink\" title=\"Relational algebra equivalences（关系代数等价）\"></a>Relational algebra equivalences（关系代数等价）</h5><p><strong>Joins</strong></p>\n<p>Commutative(交换的)，associative(结合的)</p>\n<h5 id=\"Cost-estimation-估算\"><a href=\"#Cost-estimation-估算\" class=\"headerlink\" title=\"Cost estimation (估算)\"></a>Cost estimation (估算)</h5><p>How long will a query take?</p>\n<p>-&gt; CPU: Small cost; tough to estimate</p>\n<p>-&gt; Disk: #of block transfers</p>\n<p>-&gt; Memory: Amount of DRAM used</p>\n<p>-&gt; Network: # of messages</p>\n<h5 id=\"Statistics-统计信息\"><a href=\"#Statistics-统计信息\" class=\"headerlink\" title=\"Statistics(统计信息)\"></a>Statistics(统计信息)</h5><p>The DBMS stores internal statistic about tables, attributes, and indexes in its internal catalog.</p>\n<p>Different systems update them at different times.</p>\n<p>Manual invocations: （手动调用）</p>\n<p>-&gt; Postgres / SQLite: ANALYZE</p>\n<p>-&gt; Oracle / MySQL: ANALYZE TABLE</p>\n<p>-&gt; SQL Server: UPDATE STATISTICS</p>\n<p>-&gt; DB2: RUNSTATS</p>\n<p>For each relation R , the DBMS maintains the following information:</p>\n<p>-&gt; N(R) : Number of tuples in R.</p>\n<p>-&gt; V(A, R) : Number of distinct(有区别的) values for attribute A</p>\n<h5 id=\"Derivable-statistics-可推导的统计\"><a href=\"#Derivable-statistics-可推导的统计\" class=\"headerlink\" title=\"Derivable statistics (可推导的统计)\"></a>Derivable statistics (可推导的统计)</h5><p>The selection cardinality (选择基数) SC (A, R) is the average number of records with a value for an attribute A given N(R) / V(A, R)</p>\n<h5 id=\"Selection-statistics\"><a href=\"#Selection-statistics\" class=\"headerlink\" title=\"Selection statistics\"></a>Selection statistics</h5><p>Equality predicates on unique keys are easy to estimate.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE id = 123</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE val &gt; 1000</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age = 30 AND status = &apos;Lit&apos;</span><br></pre></td></tr></table></figure>\n<p>The selectivity (选择性) (sel) of a predicate P is the fraction(分数) of tuples that qualify(符合条件)</p>\n<p>Formula(公式) depends on type of predicate:</p>\n<p>-&gt; Equality </p>\n<p>-&gt; Range</p>\n<p>-&gt; Negation （取反）</p>\n<p>-&gt; Conjunction （连接词）</p>\n<p>-&gt; Disjunction （逻辑或）</p>\n<h5 id=\"Selections-complex-predicates\"><a href=\"#Selections-complex-predicates\" class=\"headerlink\" title=\"Selections - complex predicates\"></a>Selections - complex predicates</h5><p>Assume that V(age, people) has five distinct values (0-4) and N(R) = 5</p>\n<p><strong>Equality Predicate: A = constant</strong></p>\n<p>sel(A = constant) = SC(P) / V(A, R)</p>\n<p>Example: sel(age = 2) =</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age = 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/SC-1.png\" alt=\"SC-1\"></p>\n<p><strong>Range Query</strong></p>\n<p>sel(A &gt;= a) = (A(max) - a) / (A(max) - A(min))</p>\n<p>Example: sel(age &gt;= 2) = (4 - 2) / (4 - 0) = 1 / 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age &gt;= 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/SC-2.png\" alt=\"SC-2\"></p>\n<p><strong>Negation Query</strong></p>\n<p>sel ( not P ) = 1 - sel( p )</p>\n<p>Example: sel ( age != 2 )</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age != 2</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/SC-3.png\" alt=\"SC-3\"></p>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/SC-4.png\" alt=\"SC-4\"></p>\n<p><em>Observation: Selectivity ~= Probability</em></p>\n<p><strong>Conjunction</strong></p>\n<p>sel (P1 ^ P2) = sel(P1) * sel(P2)</p>\n<p>sel (age = 2 ^ name LIKE ‘A%’ )</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age = 2 AND name LIKE &apos;A%&apos;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/Conjunction.png\" alt=\"Conjunction\"></p>\n<p><strong>Disjunction</strong></p>\n<p>sel(P1 U P2) </p>\n<p>= sel(P1) + sel(P2) - sel(P1 ^ P2)</p>\n<p>= sel(P1) + sel(P2) - sel(P1) * sel(P2)</p>\n<p>-&gt; sel(age = 2 OR name LIKE ‘A%’)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT * FROM people WHERE age = 2 OR name LIKE &apos;A%&apos;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/13/CMU-DBMS-COURSE-13-NOTES/Disjunction.png\" alt=\"Disjunction\"></p>\n<h5 id=\"Query-Optimization\"><a href=\"#Query-Optimization\" class=\"headerlink\" title=\"Query Optimization\"></a>Query Optimization</h5><p>After performing rule-based rewriting, the DBMS will enumerate(列举) different plans for the query and estimate(估计) their costs.</p>\n<p>Single relations</p>\n<p>Multiple relations</p>\n<p>Nested(嵌套) sub-queries</p>\n<p>It chooses the best plan it has been for query after exhausting(用尽) all plans or some timeout</p>\n<p>Simple heuristics(启发式) are often good enough for this</p>\n<p>OLTP queries are especially easy</p>\n<h5 id=\"OLTP-Query-planning\"><a href=\"#OLTP-Query-planning\" class=\"headerlink\" title=\"OLTP Query planning\"></a>OLTP Query planning</h5><p>Query planning for OLTP queries is easy because they are sargable（可分析的）</p>\n<p>Search Argument Able</p>\n<p>It is usually just picking the best index</p>\n<p>Joins are almost always on foreign key relationships with a small cardinality（基数）</p>\n<p>Can be implementation with simple heuristics</p>\n"},{"title":"CMU-DBMS-COURSE-14-NOTES","date":"2019-06-18T04:32:26.000Z","_content":"\n##### Parallel VS distributed\n\nDatabase is spread out(分散) across multiple resources to improve parallelism.\n\nAppears as a single database instance to the application.\n\n- SQL query for a single-node DBMS should generate same result on a parallel or distributed DBMS.\n\n**Parallel DBMSs**\n\n- Nodes are physically close to each other.\n- Nodes connected with high-speed LAN.\n- Communication cost is assumed to be small.\n\n**Distributed DBMSs**\n\n- Nodes can be far from each other.\n- Nodes connected using public network.\n- Communication cost and problems cannot be ignored.\n\n##### Inter- vs. Intra-query parallelism(查询间并行，查询内并行)\n\n**Inter-Query**  Different queries are executed concurrently.\n\nIncreases throughput & reduces latency.\n\n**Intra-Query** Execute the operations of a single query in parallel.\n\nDecreases latency for long-running queries.\n\nA DBMS's process model defines how the system in architected to support concurrent requests from a multi-user application.\n\nA worker is the DBMS component that is responsible for executing tasks on behalf of the client and returning the results.\n\n##### Process per worker\n\nEach worker is a separate OS process.\n\n- Relies on OS scheduler.\n- Use shared-memory for global data structures.\n- A process crash doesn't take down entire system.\n- Examples: IBM DB2, Postgres, Oracle\n\n![PROCESS-PER-WORKER](CMU-DBMS-COURSE-14-NOTES/PROCESS-PER-WORKER.png)\n\n##### Process pool\n\nA worker uses any process that is free in a pool \n\n- Still relies on OS scheduler and shared memory.\n- Bad for CPU cache locality.\n- Example: IBM DB2, Postgres\n\n![PROCESS-POOL](CMU-DBMS-COURSE-14-NOTES/PROCESS-POOL.png)\n\n##### Thread per worker\n\nSingle process with multiple worker threads.\n\n- DBMS has to manage its own scheduling.\n- May or may not use a dispatcher thread.\n- Thread crash(may) kill the entire system.\n- Example: IBM DB2, MSSQL, MySQL, Oracle (2014)\n\n![THREAD-PER-WORKER](CMU-DBMS-COURSE-14-NOTES/THREAD-PER-WORKER.png)\n\n##### Process models\n\nUsing a multi-threaded architecture has several advantages:\n\n- Less overhead per context switch\n\n- Don't have to manage shared memory\n\nThe thread per worker model does not  mean that you have intra-query parallelism.\n\nI am not aware of any new DBMS built in the last 10 years that doesn't use threads.\n\n##### Scheduling\n\nFor each query plan, the DBMS has to decide where, when, and how to execute it.\n\n- How many tasks should it use?\n- How many CPU cores should it use?\n- What CPU core should the tasks execute on?\n- Where should a task store its output?\n\nThe DBMS always knows more than the OS.\n\n##### Inter-query parallelism\n\nImprove overall performance by allowing multiple queries to execute simultaneously(同时的).\n\nIf queries are read-only, then this requires little coordination(协调) between queries.\n\nIf queries are updating the database at the same time, then this is hard to fo this correctly.\n\n- Need to provide the illusion(假象) of isolation\n\nImprove the performance of a single query by executing its operators in parallel\n\nThere are parallel algorithms for every relational operator.\n\n**Approach #1: Intra-Operator(Horizontal-水平)**\n\n- Operators are decomposed(分解) into independent instances that perform(执行) the same function on different subsets of data.\n\nThe DBMS inserts an exchange operator into the query plan to coalesce(合并) results from children operators.\n\n![INTRA-OPERATOR-H-1](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-1.png)\n\n![INTRA-OPERATOR-H-2](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-2.png)\n\n![INTRA-OPERATOR-H-3](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-3.png)\n\n![INTRA-OPERATOR-H-4](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-4.png)\n\n![INTRA-OPERATOR-H-5](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-5.png)\n\n![INTRA-OPERATOR-H-6](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-6.png)\n\n**Approach #2: Inter-Operator(Vertical-垂直)**\n\n- Operations are overlapped(重叠的) in order to pipeline data from one stage to the next without materialization(实现)，It also called pipelined parallelism\n\n![INTER-OPERATOR-V-1](CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-1.png)\n\n![INTER-OPERATOR-V-2](CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-2.png)\n\n![INTER-OPERATOR-V-3](CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-3.png)\n\nAFAIK(据我所知), this approach is not widely used in traditional relational DBMSs.\n\n- Not all operators can emit output until they have seen all of the tuples from their children\n\nThis is more common in stream processing systems\n\n![stream](CMU-DBMS-COURSE-14-NOTES/stream.png)\n\nUsing additional processes/threads to execute queries in parallel won't help help if the disk is always the main bottleneck(瓶颈)\n\n- Can actually make things worse if each worker is reading different segments of disk\n\n##### I/O Parallelism\n\nSplit the DBMS installation across multiple storage devices\n\n- Multiple Disk per Database\n- One Database per Disk\n- One Relation per Disk\n- Split Relation across Multiple Disks\n\n##### Multi-disk parallelism\n\nConfigure OS/hardware to store the DBMS's files across multiple storage devices.\n\n- Storage Appliances\n- RAID Configuration\n- This is transparent(透明的) to the DBMS\n\n![MULTI-DISK-PARALLELISM](CMU-DBMS-COURSE-14-NOTES/MULTI-DISK-PARALLELISM.png)\n\n![RAID-1-Mirroring](CMU-DBMS-COURSE-14-NOTES/RAID-1-Mirroring.png)\n\n##### DataBase partitioning\n\nSome DBMSs allow you specify the disk location of each individual（独立的） database.\n\n- The buffer pool manager maps a page to a disk location\n\nThis is also easy to do at the filesystem level if the DBMS stores each database in a separate directory.\n\n- The log file might be shared though\n\nSplit single logical table into disjoint(不相交的) physical segments that are stored/managed separately(单独的).\n\nIdeally partitioning is transparent to the application.\n\n- The application  accesses logical tables and doesn't care how things are stored.\n- Not always true.\n\n##### Vertical(垂直) partitioning\n\nStore a table's attributes in a separate location(e.g, file, disk volume)\n\nHave to store tuple information to reconstruct(重建) the original record\n\n```\nCREATE TABLE foo (\nattr1 INT,\nattr2 INT,\nattr3 INT,\nattr4 TEXT\n);\n```\n\n![VERTICAL-PARTITIONING](CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING.png)\n\n![VERTICAL-PARTITIONING-2](CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING-2.png)\n\n##### Horizontal partitioning\n\nDivide the tuples of a table up into disjoint segments based on some partitioning key\n\n- Hash Partitioning\n- Range Partitioning\n- Predicate(谓词) Partitioning\n\n![HORIZONTAL-PARTITIONING-1](CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-1.png)\n\n![HORIZONTAL-PARTITIONING-2](CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-2.png)\n\nParallel execution is important (Almost) every DBMS support this.\n\nThis is really hard to get right.\n\n- Coordination Overhead（协调开销）\n- Scheduling \n- Concurrency Issues\n- Resource Contention\n\n","source":"_posts/CMU-DBMS-COURSE-14-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-14-NOTES\ndate: 2019-06-18 12:32:26\ntags: Parallel Execution\n---\n\n##### Parallel VS distributed\n\nDatabase is spread out(分散) across multiple resources to improve parallelism.\n\nAppears as a single database instance to the application.\n\n- SQL query for a single-node DBMS should generate same result on a parallel or distributed DBMS.\n\n**Parallel DBMSs**\n\n- Nodes are physically close to each other.\n- Nodes connected with high-speed LAN.\n- Communication cost is assumed to be small.\n\n**Distributed DBMSs**\n\n- Nodes can be far from each other.\n- Nodes connected using public network.\n- Communication cost and problems cannot be ignored.\n\n##### Inter- vs. Intra-query parallelism(查询间并行，查询内并行)\n\n**Inter-Query**  Different queries are executed concurrently.\n\nIncreases throughput & reduces latency.\n\n**Intra-Query** Execute the operations of a single query in parallel.\n\nDecreases latency for long-running queries.\n\nA DBMS's process model defines how the system in architected to support concurrent requests from a multi-user application.\n\nA worker is the DBMS component that is responsible for executing tasks on behalf of the client and returning the results.\n\n##### Process per worker\n\nEach worker is a separate OS process.\n\n- Relies on OS scheduler.\n- Use shared-memory for global data structures.\n- A process crash doesn't take down entire system.\n- Examples: IBM DB2, Postgres, Oracle\n\n![PROCESS-PER-WORKER](CMU-DBMS-COURSE-14-NOTES/PROCESS-PER-WORKER.png)\n\n##### Process pool\n\nA worker uses any process that is free in a pool \n\n- Still relies on OS scheduler and shared memory.\n- Bad for CPU cache locality.\n- Example: IBM DB2, Postgres\n\n![PROCESS-POOL](CMU-DBMS-COURSE-14-NOTES/PROCESS-POOL.png)\n\n##### Thread per worker\n\nSingle process with multiple worker threads.\n\n- DBMS has to manage its own scheduling.\n- May or may not use a dispatcher thread.\n- Thread crash(may) kill the entire system.\n- Example: IBM DB2, MSSQL, MySQL, Oracle (2014)\n\n![THREAD-PER-WORKER](CMU-DBMS-COURSE-14-NOTES/THREAD-PER-WORKER.png)\n\n##### Process models\n\nUsing a multi-threaded architecture has several advantages:\n\n- Less overhead per context switch\n\n- Don't have to manage shared memory\n\nThe thread per worker model does not  mean that you have intra-query parallelism.\n\nI am not aware of any new DBMS built in the last 10 years that doesn't use threads.\n\n##### Scheduling\n\nFor each query plan, the DBMS has to decide where, when, and how to execute it.\n\n- How many tasks should it use?\n- How many CPU cores should it use?\n- What CPU core should the tasks execute on?\n- Where should a task store its output?\n\nThe DBMS always knows more than the OS.\n\n##### Inter-query parallelism\n\nImprove overall performance by allowing multiple queries to execute simultaneously(同时的).\n\nIf queries are read-only, then this requires little coordination(协调) between queries.\n\nIf queries are updating the database at the same time, then this is hard to fo this correctly.\n\n- Need to provide the illusion(假象) of isolation\n\nImprove the performance of a single query by executing its operators in parallel\n\nThere are parallel algorithms for every relational operator.\n\n**Approach #1: Intra-Operator(Horizontal-水平)**\n\n- Operators are decomposed(分解) into independent instances that perform(执行) the same function on different subsets of data.\n\nThe DBMS inserts an exchange operator into the query plan to coalesce(合并) results from children operators.\n\n![INTRA-OPERATOR-H-1](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-1.png)\n\n![INTRA-OPERATOR-H-2](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-2.png)\n\n![INTRA-OPERATOR-H-3](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-3.png)\n\n![INTRA-OPERATOR-H-4](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-4.png)\n\n![INTRA-OPERATOR-H-5](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-5.png)\n\n![INTRA-OPERATOR-H-6](CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-6.png)\n\n**Approach #2: Inter-Operator(Vertical-垂直)**\n\n- Operations are overlapped(重叠的) in order to pipeline data from one stage to the next without materialization(实现)，It also called pipelined parallelism\n\n![INTER-OPERATOR-V-1](CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-1.png)\n\n![INTER-OPERATOR-V-2](CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-2.png)\n\n![INTER-OPERATOR-V-3](CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-3.png)\n\nAFAIK(据我所知), this approach is not widely used in traditional relational DBMSs.\n\n- Not all operators can emit output until they have seen all of the tuples from their children\n\nThis is more common in stream processing systems\n\n![stream](CMU-DBMS-COURSE-14-NOTES/stream.png)\n\nUsing additional processes/threads to execute queries in parallel won't help help if the disk is always the main bottleneck(瓶颈)\n\n- Can actually make things worse if each worker is reading different segments of disk\n\n##### I/O Parallelism\n\nSplit the DBMS installation across multiple storage devices\n\n- Multiple Disk per Database\n- One Database per Disk\n- One Relation per Disk\n- Split Relation across Multiple Disks\n\n##### Multi-disk parallelism\n\nConfigure OS/hardware to store the DBMS's files across multiple storage devices.\n\n- Storage Appliances\n- RAID Configuration\n- This is transparent(透明的) to the DBMS\n\n![MULTI-DISK-PARALLELISM](CMU-DBMS-COURSE-14-NOTES/MULTI-DISK-PARALLELISM.png)\n\n![RAID-1-Mirroring](CMU-DBMS-COURSE-14-NOTES/RAID-1-Mirroring.png)\n\n##### DataBase partitioning\n\nSome DBMSs allow you specify the disk location of each individual（独立的） database.\n\n- The buffer pool manager maps a page to a disk location\n\nThis is also easy to do at the filesystem level if the DBMS stores each database in a separate directory.\n\n- The log file might be shared though\n\nSplit single logical table into disjoint(不相交的) physical segments that are stored/managed separately(单独的).\n\nIdeally partitioning is transparent to the application.\n\n- The application  accesses logical tables and doesn't care how things are stored.\n- Not always true.\n\n##### Vertical(垂直) partitioning\n\nStore a table's attributes in a separate location(e.g, file, disk volume)\n\nHave to store tuple information to reconstruct(重建) the original record\n\n```\nCREATE TABLE foo (\nattr1 INT,\nattr2 INT,\nattr3 INT,\nattr4 TEXT\n);\n```\n\n![VERTICAL-PARTITIONING](CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING.png)\n\n![VERTICAL-PARTITIONING-2](CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING-2.png)\n\n##### Horizontal partitioning\n\nDivide the tuples of a table up into disjoint segments based on some partitioning key\n\n- Hash Partitioning\n- Range Partitioning\n- Predicate(谓词) Partitioning\n\n![HORIZONTAL-PARTITIONING-1](CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-1.png)\n\n![HORIZONTAL-PARTITIONING-2](CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-2.png)\n\nParallel execution is important (Almost) every DBMS support this.\n\nThis is really hard to get right.\n\n- Coordination Overhead（协调开销）\n- Scheduling \n- Concurrency Issues\n- Resource Contention\n\n","slug":"CMU-DBMS-COURSE-14-NOTES","published":1,"updated":"2019-06-26T11:56:34.557Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvynd000hvkqpm5meui2n","content":"<h5 id=\"Parallel-VS-distributed\"><a href=\"#Parallel-VS-distributed\" class=\"headerlink\" title=\"Parallel VS distributed\"></a>Parallel VS distributed</h5><p>Database is spread out(分散) across multiple resources to improve parallelism.</p>\n<p>Appears as a single database instance to the application.</p>\n<ul>\n<li>SQL query for a single-node DBMS should generate same result on a parallel or distributed DBMS.</li>\n</ul>\n<p><strong>Parallel DBMSs</strong></p>\n<ul>\n<li>Nodes are physically close to each other.</li>\n<li>Nodes connected with high-speed LAN.</li>\n<li>Communication cost is assumed to be small.</li>\n</ul>\n<p><strong>Distributed DBMSs</strong></p>\n<ul>\n<li>Nodes can be far from each other.</li>\n<li>Nodes connected using public network.</li>\n<li>Communication cost and problems cannot be ignored.</li>\n</ul>\n<h5 id=\"Inter-vs-Intra-query-parallelism-查询间并行，查询内并行\"><a href=\"#Inter-vs-Intra-query-parallelism-查询间并行，查询内并行\" class=\"headerlink\" title=\"Inter- vs. Intra-query parallelism(查询间并行，查询内并行)\"></a>Inter- vs. Intra-query parallelism(查询间并行，查询内并行)</h5><p><strong>Inter-Query</strong>  Different queries are executed concurrently.</p>\n<p>Increases throughput &amp; reduces latency.</p>\n<p><strong>Intra-Query</strong> Execute the operations of a single query in parallel.</p>\n<p>Decreases latency for long-running queries.</p>\n<p>A DBMS’s process model defines how the system in architected to support concurrent requests from a multi-user application.</p>\n<p>A worker is the DBMS component that is responsible for executing tasks on behalf of the client and returning the results.</p>\n<h5 id=\"Process-per-worker\"><a href=\"#Process-per-worker\" class=\"headerlink\" title=\"Process per worker\"></a>Process per worker</h5><p>Each worker is a separate OS process.</p>\n<ul>\n<li>Relies on OS scheduler.</li>\n<li>Use shared-memory for global data structures.</li>\n<li>A process crash doesn’t take down entire system.</li>\n<li>Examples: IBM DB2, Postgres, Oracle</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/PROCESS-PER-WORKER.png\" alt=\"PROCESS-PER-WORKER\"></p>\n<h5 id=\"Process-pool\"><a href=\"#Process-pool\" class=\"headerlink\" title=\"Process pool\"></a>Process pool</h5><p>A worker uses any process that is free in a pool </p>\n<ul>\n<li>Still relies on OS scheduler and shared memory.</li>\n<li>Bad for CPU cache locality.</li>\n<li>Example: IBM DB2, Postgres</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/PROCESS-POOL.png\" alt=\"PROCESS-POOL\"></p>\n<h5 id=\"Thread-per-worker\"><a href=\"#Thread-per-worker\" class=\"headerlink\" title=\"Thread per worker\"></a>Thread per worker</h5><p>Single process with multiple worker threads.</p>\n<ul>\n<li>DBMS has to manage its own scheduling.</li>\n<li>May or may not use a dispatcher thread.</li>\n<li>Thread crash(may) kill the entire system.</li>\n<li>Example: IBM DB2, MSSQL, MySQL, Oracle (2014)</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/THREAD-PER-WORKER.png\" alt=\"THREAD-PER-WORKER\"></p>\n<h5 id=\"Process-models\"><a href=\"#Process-models\" class=\"headerlink\" title=\"Process models\"></a>Process models</h5><p>Using a multi-threaded architecture has several advantages:</p>\n<ul>\n<li><p>Less overhead per context switch</p>\n</li>\n<li><p>Don’t have to manage shared memory</p>\n</li>\n</ul>\n<p>The thread per worker model does not  mean that you have intra-query parallelism.</p>\n<p>I am not aware of any new DBMS built in the last 10 years that doesn’t use threads.</p>\n<h5 id=\"Scheduling\"><a href=\"#Scheduling\" class=\"headerlink\" title=\"Scheduling\"></a>Scheduling</h5><p>For each query plan, the DBMS has to decide where, when, and how to execute it.</p>\n<ul>\n<li>How many tasks should it use?</li>\n<li>How many CPU cores should it use?</li>\n<li>What CPU core should the tasks execute on?</li>\n<li>Where should a task store its output?</li>\n</ul>\n<p>The DBMS always knows more than the OS.</p>\n<h5 id=\"Inter-query-parallelism\"><a href=\"#Inter-query-parallelism\" class=\"headerlink\" title=\"Inter-query parallelism\"></a>Inter-query parallelism</h5><p>Improve overall performance by allowing multiple queries to execute simultaneously(同时的).</p>\n<p>If queries are read-only, then this requires little coordination(协调) between queries.</p>\n<p>If queries are updating the database at the same time, then this is hard to fo this correctly.</p>\n<ul>\n<li>Need to provide the illusion(假象) of isolation</li>\n</ul>\n<p>Improve the performance of a single query by executing its operators in parallel</p>\n<p>There are parallel algorithms for every relational operator.</p>\n<p><strong>Approach #1: Intra-Operator(Horizontal-水平)</strong></p>\n<ul>\n<li>Operators are decomposed(分解) into independent instances that perform(执行) the same function on different subsets of data.</li>\n</ul>\n<p>The DBMS inserts an exchange operator into the query plan to coalesce(合并) results from children operators.</p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-1.png\" alt=\"INTRA-OPERATOR-H-1\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-2.png\" alt=\"INTRA-OPERATOR-H-2\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-3.png\" alt=\"INTRA-OPERATOR-H-3\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-4.png\" alt=\"INTRA-OPERATOR-H-4\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-5.png\" alt=\"INTRA-OPERATOR-H-5\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-6.png\" alt=\"INTRA-OPERATOR-H-6\"></p>\n<p><strong>Approach #2: Inter-Operator(Vertical-垂直)</strong></p>\n<ul>\n<li>Operations are overlapped(重叠的) in order to pipeline data from one stage to the next without materialization(实现)，It also called pipelined parallelism</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-1.png\" alt=\"INTER-OPERATOR-V-1\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-2.png\" alt=\"INTER-OPERATOR-V-2\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-3.png\" alt=\"INTER-OPERATOR-V-3\"></p>\n<p>AFAIK(据我所知), this approach is not widely used in traditional relational DBMSs.</p>\n<ul>\n<li>Not all operators can emit output until they have seen all of the tuples from their children</li>\n</ul>\n<p>This is more common in stream processing systems</p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/stream.png\" alt=\"stream\"></p>\n<p>Using additional processes/threads to execute queries in parallel won’t help help if the disk is always the main bottleneck(瓶颈)</p>\n<ul>\n<li>Can actually make things worse if each worker is reading different segments of disk</li>\n</ul>\n<h5 id=\"I-O-Parallelism\"><a href=\"#I-O-Parallelism\" class=\"headerlink\" title=\"I/O Parallelism\"></a>I/O Parallelism</h5><p>Split the DBMS installation across multiple storage devices</p>\n<ul>\n<li>Multiple Disk per Database</li>\n<li>One Database per Disk</li>\n<li>One Relation per Disk</li>\n<li>Split Relation across Multiple Disks</li>\n</ul>\n<h5 id=\"Multi-disk-parallelism\"><a href=\"#Multi-disk-parallelism\" class=\"headerlink\" title=\"Multi-disk parallelism\"></a>Multi-disk parallelism</h5><p>Configure OS/hardware to store the DBMS’s files across multiple storage devices.</p>\n<ul>\n<li>Storage Appliances</li>\n<li>RAID Configuration</li>\n<li>This is transparent(透明的) to the DBMS</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/MULTI-DISK-PARALLELISM.png\" alt=\"MULTI-DISK-PARALLELISM\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/RAID-1-Mirroring.png\" alt=\"RAID-1-Mirroring\"></p>\n<h5 id=\"DataBase-partitioning\"><a href=\"#DataBase-partitioning\" class=\"headerlink\" title=\"DataBase partitioning\"></a>DataBase partitioning</h5><p>Some DBMSs allow you specify the disk location of each individual（独立的） database.</p>\n<ul>\n<li>The buffer pool manager maps a page to a disk location</li>\n</ul>\n<p>This is also easy to do at the filesystem level if the DBMS stores each database in a separate directory.</p>\n<ul>\n<li>The log file might be shared though</li>\n</ul>\n<p>Split single logical table into disjoint(不相交的) physical segments that are stored/managed separately(单独的).</p>\n<p>Ideally partitioning is transparent to the application.</p>\n<ul>\n<li>The application  accesses logical tables and doesn’t care how things are stored.</li>\n<li>Not always true.</li>\n</ul>\n<h5 id=\"Vertical-垂直-partitioning\"><a href=\"#Vertical-垂直-partitioning\" class=\"headerlink\" title=\"Vertical(垂直) partitioning\"></a>Vertical(垂直) partitioning</h5><p>Store a table’s attributes in a separate location(e.g, file, disk volume)</p>\n<p>Have to store tuple information to reconstruct(重建) the original record</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE foo (</span><br><span class=\"line\">attr1 INT,</span><br><span class=\"line\">attr2 INT,</span><br><span class=\"line\">attr3 INT,</span><br><span class=\"line\">attr4 TEXT</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING.png\" alt=\"VERTICAL-PARTITIONING\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING-2.png\" alt=\"VERTICAL-PARTITIONING-2\"></p>\n<h5 id=\"Horizontal-partitioning\"><a href=\"#Horizontal-partitioning\" class=\"headerlink\" title=\"Horizontal partitioning\"></a>Horizontal partitioning</h5><p>Divide the tuples of a table up into disjoint segments based on some partitioning key</p>\n<ul>\n<li>Hash Partitioning</li>\n<li>Range Partitioning</li>\n<li>Predicate(谓词) Partitioning</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-1.png\" alt=\"HORIZONTAL-PARTITIONING-1\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-2.png\" alt=\"HORIZONTAL-PARTITIONING-2\"></p>\n<p>Parallel execution is important (Almost) every DBMS support this.</p>\n<p>This is really hard to get right.</p>\n<ul>\n<li>Coordination Overhead（协调开销）</li>\n<li>Scheduling </li>\n<li>Concurrency Issues</li>\n<li>Resource Contention</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"Parallel-VS-distributed\"><a href=\"#Parallel-VS-distributed\" class=\"headerlink\" title=\"Parallel VS distributed\"></a>Parallel VS distributed</h5><p>Database is spread out(分散) across multiple resources to improve parallelism.</p>\n<p>Appears as a single database instance to the application.</p>\n<ul>\n<li>SQL query for a single-node DBMS should generate same result on a parallel or distributed DBMS.</li>\n</ul>\n<p><strong>Parallel DBMSs</strong></p>\n<ul>\n<li>Nodes are physically close to each other.</li>\n<li>Nodes connected with high-speed LAN.</li>\n<li>Communication cost is assumed to be small.</li>\n</ul>\n<p><strong>Distributed DBMSs</strong></p>\n<ul>\n<li>Nodes can be far from each other.</li>\n<li>Nodes connected using public network.</li>\n<li>Communication cost and problems cannot be ignored.</li>\n</ul>\n<h5 id=\"Inter-vs-Intra-query-parallelism-查询间并行，查询内并行\"><a href=\"#Inter-vs-Intra-query-parallelism-查询间并行，查询内并行\" class=\"headerlink\" title=\"Inter- vs. Intra-query parallelism(查询间并行，查询内并行)\"></a>Inter- vs. Intra-query parallelism(查询间并行，查询内并行)</h5><p><strong>Inter-Query</strong>  Different queries are executed concurrently.</p>\n<p>Increases throughput &amp; reduces latency.</p>\n<p><strong>Intra-Query</strong> Execute the operations of a single query in parallel.</p>\n<p>Decreases latency for long-running queries.</p>\n<p>A DBMS’s process model defines how the system in architected to support concurrent requests from a multi-user application.</p>\n<p>A worker is the DBMS component that is responsible for executing tasks on behalf of the client and returning the results.</p>\n<h5 id=\"Process-per-worker\"><a href=\"#Process-per-worker\" class=\"headerlink\" title=\"Process per worker\"></a>Process per worker</h5><p>Each worker is a separate OS process.</p>\n<ul>\n<li>Relies on OS scheduler.</li>\n<li>Use shared-memory for global data structures.</li>\n<li>A process crash doesn’t take down entire system.</li>\n<li>Examples: IBM DB2, Postgres, Oracle</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/PROCESS-PER-WORKER.png\" alt=\"PROCESS-PER-WORKER\"></p>\n<h5 id=\"Process-pool\"><a href=\"#Process-pool\" class=\"headerlink\" title=\"Process pool\"></a>Process pool</h5><p>A worker uses any process that is free in a pool </p>\n<ul>\n<li>Still relies on OS scheduler and shared memory.</li>\n<li>Bad for CPU cache locality.</li>\n<li>Example: IBM DB2, Postgres</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/PROCESS-POOL.png\" alt=\"PROCESS-POOL\"></p>\n<h5 id=\"Thread-per-worker\"><a href=\"#Thread-per-worker\" class=\"headerlink\" title=\"Thread per worker\"></a>Thread per worker</h5><p>Single process with multiple worker threads.</p>\n<ul>\n<li>DBMS has to manage its own scheduling.</li>\n<li>May or may not use a dispatcher thread.</li>\n<li>Thread crash(may) kill the entire system.</li>\n<li>Example: IBM DB2, MSSQL, MySQL, Oracle (2014)</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/THREAD-PER-WORKER.png\" alt=\"THREAD-PER-WORKER\"></p>\n<h5 id=\"Process-models\"><a href=\"#Process-models\" class=\"headerlink\" title=\"Process models\"></a>Process models</h5><p>Using a multi-threaded architecture has several advantages:</p>\n<ul>\n<li><p>Less overhead per context switch</p>\n</li>\n<li><p>Don’t have to manage shared memory</p>\n</li>\n</ul>\n<p>The thread per worker model does not  mean that you have intra-query parallelism.</p>\n<p>I am not aware of any new DBMS built in the last 10 years that doesn’t use threads.</p>\n<h5 id=\"Scheduling\"><a href=\"#Scheduling\" class=\"headerlink\" title=\"Scheduling\"></a>Scheduling</h5><p>For each query plan, the DBMS has to decide where, when, and how to execute it.</p>\n<ul>\n<li>How many tasks should it use?</li>\n<li>How many CPU cores should it use?</li>\n<li>What CPU core should the tasks execute on?</li>\n<li>Where should a task store its output?</li>\n</ul>\n<p>The DBMS always knows more than the OS.</p>\n<h5 id=\"Inter-query-parallelism\"><a href=\"#Inter-query-parallelism\" class=\"headerlink\" title=\"Inter-query parallelism\"></a>Inter-query parallelism</h5><p>Improve overall performance by allowing multiple queries to execute simultaneously(同时的).</p>\n<p>If queries are read-only, then this requires little coordination(协调) between queries.</p>\n<p>If queries are updating the database at the same time, then this is hard to fo this correctly.</p>\n<ul>\n<li>Need to provide the illusion(假象) of isolation</li>\n</ul>\n<p>Improve the performance of a single query by executing its operators in parallel</p>\n<p>There are parallel algorithms for every relational operator.</p>\n<p><strong>Approach #1: Intra-Operator(Horizontal-水平)</strong></p>\n<ul>\n<li>Operators are decomposed(分解) into independent instances that perform(执行) the same function on different subsets of data.</li>\n</ul>\n<p>The DBMS inserts an exchange operator into the query plan to coalesce(合并) results from children operators.</p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-1.png\" alt=\"INTRA-OPERATOR-H-1\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-2.png\" alt=\"INTRA-OPERATOR-H-2\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-3.png\" alt=\"INTRA-OPERATOR-H-3\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-4.png\" alt=\"INTRA-OPERATOR-H-4\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-5.png\" alt=\"INTRA-OPERATOR-H-5\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-6.png\" alt=\"INTRA-OPERATOR-H-6\"></p>\n<p><strong>Approach #2: Inter-Operator(Vertical-垂直)</strong></p>\n<ul>\n<li>Operations are overlapped(重叠的) in order to pipeline data from one stage to the next without materialization(实现)，It also called pipelined parallelism</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-1.png\" alt=\"INTER-OPERATOR-V-1\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-2.png\" alt=\"INTER-OPERATOR-V-2\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-3.png\" alt=\"INTER-OPERATOR-V-3\"></p>\n<p>AFAIK(据我所知), this approach is not widely used in traditional relational DBMSs.</p>\n<ul>\n<li>Not all operators can emit output until they have seen all of the tuples from their children</li>\n</ul>\n<p>This is more common in stream processing systems</p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/stream.png\" alt=\"stream\"></p>\n<p>Using additional processes/threads to execute queries in parallel won’t help help if the disk is always the main bottleneck(瓶颈)</p>\n<ul>\n<li>Can actually make things worse if each worker is reading different segments of disk</li>\n</ul>\n<h5 id=\"I-O-Parallelism\"><a href=\"#I-O-Parallelism\" class=\"headerlink\" title=\"I/O Parallelism\"></a>I/O Parallelism</h5><p>Split the DBMS installation across multiple storage devices</p>\n<ul>\n<li>Multiple Disk per Database</li>\n<li>One Database per Disk</li>\n<li>One Relation per Disk</li>\n<li>Split Relation across Multiple Disks</li>\n</ul>\n<h5 id=\"Multi-disk-parallelism\"><a href=\"#Multi-disk-parallelism\" class=\"headerlink\" title=\"Multi-disk parallelism\"></a>Multi-disk parallelism</h5><p>Configure OS/hardware to store the DBMS’s files across multiple storage devices.</p>\n<ul>\n<li>Storage Appliances</li>\n<li>RAID Configuration</li>\n<li>This is transparent(透明的) to the DBMS</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/MULTI-DISK-PARALLELISM.png\" alt=\"MULTI-DISK-PARALLELISM\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/RAID-1-Mirroring.png\" alt=\"RAID-1-Mirroring\"></p>\n<h5 id=\"DataBase-partitioning\"><a href=\"#DataBase-partitioning\" class=\"headerlink\" title=\"DataBase partitioning\"></a>DataBase partitioning</h5><p>Some DBMSs allow you specify the disk location of each individual（独立的） database.</p>\n<ul>\n<li>The buffer pool manager maps a page to a disk location</li>\n</ul>\n<p>This is also easy to do at the filesystem level if the DBMS stores each database in a separate directory.</p>\n<ul>\n<li>The log file might be shared though</li>\n</ul>\n<p>Split single logical table into disjoint(不相交的) physical segments that are stored/managed separately(单独的).</p>\n<p>Ideally partitioning is transparent to the application.</p>\n<ul>\n<li>The application  accesses logical tables and doesn’t care how things are stored.</li>\n<li>Not always true.</li>\n</ul>\n<h5 id=\"Vertical-垂直-partitioning\"><a href=\"#Vertical-垂直-partitioning\" class=\"headerlink\" title=\"Vertical(垂直) partitioning\"></a>Vertical(垂直) partitioning</h5><p>Store a table’s attributes in a separate location(e.g, file, disk volume)</p>\n<p>Have to store tuple information to reconstruct(重建) the original record</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE foo (</span><br><span class=\"line\">attr1 INT,</span><br><span class=\"line\">attr2 INT,</span><br><span class=\"line\">attr3 INT,</span><br><span class=\"line\">attr4 TEXT</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING.png\" alt=\"VERTICAL-PARTITIONING\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING-2.png\" alt=\"VERTICAL-PARTITIONING-2\"></p>\n<h5 id=\"Horizontal-partitioning\"><a href=\"#Horizontal-partitioning\" class=\"headerlink\" title=\"Horizontal partitioning\"></a>Horizontal partitioning</h5><p>Divide the tuples of a table up into disjoint segments based on some partitioning key</p>\n<ul>\n<li>Hash Partitioning</li>\n<li>Range Partitioning</li>\n<li>Predicate(谓词) Partitioning</li>\n</ul>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-1.png\" alt=\"HORIZONTAL-PARTITIONING-1\"></p>\n<p><img src=\"/2019/06/18/CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-2.png\" alt=\"HORIZONTAL-PARTITIONING-2\"></p>\n<p>Parallel execution is important (Almost) every DBMS support this.</p>\n<p>This is really hard to get right.</p>\n<ul>\n<li>Coordination Overhead（协调开销）</li>\n<li>Scheduling </li>\n<li>Concurrency Issues</li>\n<li>Resource Contention</li>\n</ul>\n"},{"title":"CMU-DBMS-COURSE-15-NOTES","date":"2019-06-19T15:47:30.000Z","_content":"","source":"_posts/CMU-DBMS-COURSE-15-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-15-NOTES\ndate: 2019-06-19 23:47:30\ntags:\n---\n","slug":"CMU-DBMS-COURSE-15-NOTES","published":1,"updated":"2019-06-26T11:56:34.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvynh000ivkqpcmchvo9e","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"CMU-DBMS-COURSE-11-NOTES","date":"2019-05-12T11:15:41.000Z","_content":"\n- Tip 感觉很多话中文翻译过来很别扭，后续就全部用原文做笔记了\n\n#### Sorting And Aggregations（聚合）\n\n##### Why do we need to sort?\n\nThe tuples in a table have no specific order, But users often want to retrieve(检索) tuples in a specific order.\n\n- to support DISTINCT Operation\n- Bulk(大部分) loading sorted tuples into a B+ tree index is faster\n- Aggragations(GROUP BY)\n\n##### Think about sorting algorithms\n\nIf data fits in memory, then we can use a standard sorting algorithm like quick-sort.\n\nIf data does not fit in memory, then we need to use a technique that is aware of *the cost of writing data out to disk*.\n\n##### External merge sort abstract\n\n- Sorting Phase\n\nSort small chunks of  of data that fit in main-memory, and then write back the sorted data to a file on disk.\n\n- Merge Phase\n\nCombine sorted sub-files into a single larger file.\n\n##### 2-WAY EXTERNAL MERGE SORT\n\nFiles are broken up(分裂) into N pages.\n\nThe DBMS has a finite(限定的) number of B fixed-size(固定大小) buffers.\n\n**Pass #0**\n\n- Reads every B pages of the table into memory\n- Sorts them, and writes them back to disk\n- Each sorted set of pages is called a run\n\n**Pass #1,2,3**\n\n- Recursively merges pairs of runs into runs twice as long\n- Uses three buffer pages (2 for input pages, 1 for output)\n\n![External-merge-sort1](CMU-DBMS-COURSE-11-NOTES/External-merge-sort1.png)\n\n![External-merge-sort2](CMU-DBMS-COURSE-11-NOTES/External-merge-sort2.png)\n\n![External-merge-sort3](CMU-DBMS-COURSE-11-NOTES/External-merge-sort3.png)\n\n![External-merge-sort4](CMU-DBMS-COURSE-11-NOTES/External-merge-sort4.png)\n\n![External-merge-sort5](CMU-DBMS-COURSE-11-NOTES/External-merge-sort5.png)\n\nIn each pass, we read and write each page in file.\n\nNumber of passes: \n$$\n1 + \\log_{2}{N}\n$$\nTotal I/O cost：\n$$\n2N * (\\# of-passes)\n$$\n![EXTERNAL-MERGE-SORT-1](CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-1.png)\n\n![EXTERNAL-MERGE-SORT-2](CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-2.png)\n\n![EXTERNAL-MERGE-SORT-3](CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-3.png)\n\n![EXTERNAL-MERGE-SORT-4](CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-4.png)\n\n![EXTERNAL-MERGE-SORT-5](CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-5.png)\n\nThis algorithm only requires three buffer pages（B=3）\n\nEven if we have more buffer space available (B > 3)， it does not effectively utilize them\n\n##### General external merge sort\n\n**Pass #0**\n\n- Use B buffer pages\n- Produce [N/B] sorted runs of size B\n\n**Pass #1,2,3**\n\n- Merge B-1 runs\n\nNumber of passes:\n$$\n1+ log_{B-1}{N/B}\n$$\nTips：N/B和log运算的值都是向上取整\n\nTotal I/O Cost:\n$$\n2N * (\\# of—passes)\n$$\n\n##### Using B+ Trees\n\nIf the table that must be sorted already has a B+ tree index on the sort attribute(s)，then we can use that to accelerate sorting\n\nRetrieve tuples in desired sort order by simply traversing the leaf pages of the tree\n\n##### Clustered B+ Tree\n\n![Clustered-bplus-tree](CMU-DBMS-COURSE-11-NOTES/Clustered-bplus-tree.png)\n\nTraverse to the left-most leaf page, and then retrieve tuples from all leaf pages. This will always better than external sorting.\n\n##### Unclustered B+ Tree\n\n![Unclustered-bplus-tree](CMU-DBMS-COURSE-11-NOTES/Unclustered-bplus-tree.png)\n\nChase each pointer to the page that contains the data.\n\nThis is almost always a bad idea. In general，one I/O per data record.\n\n##### Aggregations\n\nCollapse multiple tuples into a single scalar(标量) value\n\nTwo implementation choices:\n\nSorting, Hashing\n\n##### Sorting aggregation\n\n```\nSELECT DISTINCT cid\nFROM enrolled\nWHERE grade IN('B', ''C)\n```\n\n![SORTING-AGGREGATION-1](CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-1.png)\n\n![SORTING-AGGREGATION-2](CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-2.png)\n\n![SORTING-AGGREGATION-3](CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-3.png)\n\n![SORTING-AGGREGATION-4](CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-4.png)\n\n![SORTING-AGGREGATION-5](CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-5.png)\n\n##### Alternatives（选择） to sorting\n\nWhat if we don't need the data to be ordered?\n\n- Forming groups in GROUP BY(no ordering)\n- Removing duplicates in DISTINCT(no ordering)\n\nHashing is a better alternative in this scenario(方案).\n\n- Only need to remove duplicates, no need for ordering.\n- Can be computationally cheaper than sorting.\n\n##### Hashing aggregate\n\nPopulate an ephemeral(临时的) hash table as the DBMS scans the table. For each record，check whether there is already an entry in the hash table:\n\n- DISTINCT: Discard duplicate\n- GROUP BY: Perform aggregate computation\n\nIf everything fits in memory, then it's easy. If we have to spill(溢出) to disk, then we need to be smarter...\n\nPartition Phase: Divide tuples into buckets based on hash key\n\nReHash Phase: Build in-memory hash table for each partition and compute the aggregation.\n\n##### Hashing aggregate phase #1: partition\n\nUse a hash function h1 to split tuples into partitions on disk.\n\n- We know that all matches live in the same partition.\n- Partitions are \"spilled\" to disk via output buffers.\n\nAssume that we have B buffers.\n\n```\nSELECT DISTINCT cid\nFROM\tenrolled\nWHERE\tgrade IN('B','C')\n```\n\n![HASHING-AGGREGATE-1](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-1.png)\n\n![HASHING-AGGREGATE-2](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-2.png)\n\n![HASHING-AGGREGATE-3](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-3.png)\n\n![HASHING-AGGREGATE-4](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-4.png)\n\n##### Hashing aggregate phase #2: rehash\n\nFor each partition on disk:\n\n- Read it into memory and build an in-memory hash table based on a second hash function h2.\n- Then go through each bucket of this hash table to bring together matching tuples.\n\nThis assumes that  each partition fits in memory.\n\n```\nSELECT DISTINCT cid FROM enrolled WHERE grade IN ('B', 'C')\n```\n\n![HASHING-AGGREGATE-5](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-5.png)\n\n![HASHING-AGGREGATE-6](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-6.png)\n\n![HASHING-AGGREGATE-7](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-7.png)\n\n##### Hashing summarization\n\nDuring the ReHash phase, store pairs of the form\n\n (GroupKey -> RunningVal)\n\nWhen we want to insert a new tuple into the hash table:\n\n- If we find a matching GroupKey, just update the RunningVal appropriately\n- Else insert a new GroupKey->RunningVal\n\n```\nSELECT cid, AVG(s.gpa)\nFROM student AS s, enrolled AS e\nWHERE s.sid = e.sid\nGROUP BY cid\n```\n\n![HASHING-SUMMARIZATION-1](CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-1.png)\n\n![HASHING-SUMMARIZATION-2](CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-2.png)\n\n![HASHING-SUMMARIZATION-3](CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-3.png)\n\n##### Cost analysis\n\nHow big of a table can we hash using this approach?\n\n- B-1 \"spill partitions\" in Phase #1\n- Each should be no more than B block big\n\nAnswer: B*(B-1)\n\n- A table of N pages needs about sqrt(N) buffers Use a \"fudge factor\" f > 1 for that: we need B*sqrt(f * N)\n\n##### Concusion\n\nChoice of sorting vs. hashing is subtle(微妙的) and depends on optimizations done in each case.\n\nWe already discussed the optimizations for sorting:\n\n- Chunk I/O into large blocks to amortize(摊销) seek+RD costs\n- Double-buffering to overlap CPU and I/O","source":"_posts/CMU-DBMS-COURSE-11-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-11-NOTES\ndate: 2019-05-12 19:15:41\ntags: \n---\n\n- Tip 感觉很多话中文翻译过来很别扭，后续就全部用原文做笔记了\n\n#### Sorting And Aggregations（聚合）\n\n##### Why do we need to sort?\n\nThe tuples in a table have no specific order, But users often want to retrieve(检索) tuples in a specific order.\n\n- to support DISTINCT Operation\n- Bulk(大部分) loading sorted tuples into a B+ tree index is faster\n- Aggragations(GROUP BY)\n\n##### Think about sorting algorithms\n\nIf data fits in memory, then we can use a standard sorting algorithm like quick-sort.\n\nIf data does not fit in memory, then we need to use a technique that is aware of *the cost of writing data out to disk*.\n\n##### External merge sort abstract\n\n- Sorting Phase\n\nSort small chunks of  of data that fit in main-memory, and then write back the sorted data to a file on disk.\n\n- Merge Phase\n\nCombine sorted sub-files into a single larger file.\n\n##### 2-WAY EXTERNAL MERGE SORT\n\nFiles are broken up(分裂) into N pages.\n\nThe DBMS has a finite(限定的) number of B fixed-size(固定大小) buffers.\n\n**Pass #0**\n\n- Reads every B pages of the table into memory\n- Sorts them, and writes them back to disk\n- Each sorted set of pages is called a run\n\n**Pass #1,2,3**\n\n- Recursively merges pairs of runs into runs twice as long\n- Uses three buffer pages (2 for input pages, 1 for output)\n\n![External-merge-sort1](CMU-DBMS-COURSE-11-NOTES/External-merge-sort1.png)\n\n![External-merge-sort2](CMU-DBMS-COURSE-11-NOTES/External-merge-sort2.png)\n\n![External-merge-sort3](CMU-DBMS-COURSE-11-NOTES/External-merge-sort3.png)\n\n![External-merge-sort4](CMU-DBMS-COURSE-11-NOTES/External-merge-sort4.png)\n\n![External-merge-sort5](CMU-DBMS-COURSE-11-NOTES/External-merge-sort5.png)\n\nIn each pass, we read and write each page in file.\n\nNumber of passes: \n$$\n1 + \\log_{2}{N}\n$$\nTotal I/O cost：\n$$\n2N * (\\# of-passes)\n$$\n![EXTERNAL-MERGE-SORT-1](CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-1.png)\n\n![EXTERNAL-MERGE-SORT-2](CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-2.png)\n\n![EXTERNAL-MERGE-SORT-3](CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-3.png)\n\n![EXTERNAL-MERGE-SORT-4](CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-4.png)\n\n![EXTERNAL-MERGE-SORT-5](CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-5.png)\n\nThis algorithm only requires three buffer pages（B=3）\n\nEven if we have more buffer space available (B > 3)， it does not effectively utilize them\n\n##### General external merge sort\n\n**Pass #0**\n\n- Use B buffer pages\n- Produce [N/B] sorted runs of size B\n\n**Pass #1,2,3**\n\n- Merge B-1 runs\n\nNumber of passes:\n$$\n1+ log_{B-1}{N/B}\n$$\nTips：N/B和log运算的值都是向上取整\n\nTotal I/O Cost:\n$$\n2N * (\\# of—passes)\n$$\n\n##### Using B+ Trees\n\nIf the table that must be sorted already has a B+ tree index on the sort attribute(s)，then we can use that to accelerate sorting\n\nRetrieve tuples in desired sort order by simply traversing the leaf pages of the tree\n\n##### Clustered B+ Tree\n\n![Clustered-bplus-tree](CMU-DBMS-COURSE-11-NOTES/Clustered-bplus-tree.png)\n\nTraverse to the left-most leaf page, and then retrieve tuples from all leaf pages. This will always better than external sorting.\n\n##### Unclustered B+ Tree\n\n![Unclustered-bplus-tree](CMU-DBMS-COURSE-11-NOTES/Unclustered-bplus-tree.png)\n\nChase each pointer to the page that contains the data.\n\nThis is almost always a bad idea. In general，one I/O per data record.\n\n##### Aggregations\n\nCollapse multiple tuples into a single scalar(标量) value\n\nTwo implementation choices:\n\nSorting, Hashing\n\n##### Sorting aggregation\n\n```\nSELECT DISTINCT cid\nFROM enrolled\nWHERE grade IN('B', ''C)\n```\n\n![SORTING-AGGREGATION-1](CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-1.png)\n\n![SORTING-AGGREGATION-2](CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-2.png)\n\n![SORTING-AGGREGATION-3](CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-3.png)\n\n![SORTING-AGGREGATION-4](CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-4.png)\n\n![SORTING-AGGREGATION-5](CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-5.png)\n\n##### Alternatives（选择） to sorting\n\nWhat if we don't need the data to be ordered?\n\n- Forming groups in GROUP BY(no ordering)\n- Removing duplicates in DISTINCT(no ordering)\n\nHashing is a better alternative in this scenario(方案).\n\n- Only need to remove duplicates, no need for ordering.\n- Can be computationally cheaper than sorting.\n\n##### Hashing aggregate\n\nPopulate an ephemeral(临时的) hash table as the DBMS scans the table. For each record，check whether there is already an entry in the hash table:\n\n- DISTINCT: Discard duplicate\n- GROUP BY: Perform aggregate computation\n\nIf everything fits in memory, then it's easy. If we have to spill(溢出) to disk, then we need to be smarter...\n\nPartition Phase: Divide tuples into buckets based on hash key\n\nReHash Phase: Build in-memory hash table for each partition and compute the aggregation.\n\n##### Hashing aggregate phase #1: partition\n\nUse a hash function h1 to split tuples into partitions on disk.\n\n- We know that all matches live in the same partition.\n- Partitions are \"spilled\" to disk via output buffers.\n\nAssume that we have B buffers.\n\n```\nSELECT DISTINCT cid\nFROM\tenrolled\nWHERE\tgrade IN('B','C')\n```\n\n![HASHING-AGGREGATE-1](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-1.png)\n\n![HASHING-AGGREGATE-2](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-2.png)\n\n![HASHING-AGGREGATE-3](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-3.png)\n\n![HASHING-AGGREGATE-4](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-4.png)\n\n##### Hashing aggregate phase #2: rehash\n\nFor each partition on disk:\n\n- Read it into memory and build an in-memory hash table based on a second hash function h2.\n- Then go through each bucket of this hash table to bring together matching tuples.\n\nThis assumes that  each partition fits in memory.\n\n```\nSELECT DISTINCT cid FROM enrolled WHERE grade IN ('B', 'C')\n```\n\n![HASHING-AGGREGATE-5](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-5.png)\n\n![HASHING-AGGREGATE-6](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-6.png)\n\n![HASHING-AGGREGATE-7](CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-7.png)\n\n##### Hashing summarization\n\nDuring the ReHash phase, store pairs of the form\n\n (GroupKey -> RunningVal)\n\nWhen we want to insert a new tuple into the hash table:\n\n- If we find a matching GroupKey, just update the RunningVal appropriately\n- Else insert a new GroupKey->RunningVal\n\n```\nSELECT cid, AVG(s.gpa)\nFROM student AS s, enrolled AS e\nWHERE s.sid = e.sid\nGROUP BY cid\n```\n\n![HASHING-SUMMARIZATION-1](CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-1.png)\n\n![HASHING-SUMMARIZATION-2](CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-2.png)\n\n![HASHING-SUMMARIZATION-3](CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-3.png)\n\n##### Cost analysis\n\nHow big of a table can we hash using this approach?\n\n- B-1 \"spill partitions\" in Phase #1\n- Each should be no more than B block big\n\nAnswer: B*(B-1)\n\n- A table of N pages needs about sqrt(N) buffers Use a \"fudge factor\" f > 1 for that: we need B*sqrt(f * N)\n\n##### Concusion\n\nChoice of sorting vs. hashing is subtle(微妙的) and depends on optimizations done in each case.\n\nWe already discussed the optimizations for sorting:\n\n- Chunk I/O into large blocks to amortize(摊销) seek+RD costs\n- Double-buffering to overlap CPU and I/O","slug":"CMU-DBMS-COURSE-11-NOTES","published":1,"updated":"2019-06-26T11:56:34.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvynm000jvkqpig8sdl37","content":"<ul>\n<li>Tip 感觉很多话中文翻译过来很别扭，后续就全部用原文做笔记了</li>\n</ul>\n<h4 id=\"Sorting-And-Aggregations（聚合）\"><a href=\"#Sorting-And-Aggregations（聚合）\" class=\"headerlink\" title=\"Sorting And Aggregations（聚合）\"></a>Sorting And Aggregations（聚合）</h4><h5 id=\"Why-do-we-need-to-sort\"><a href=\"#Why-do-we-need-to-sort\" class=\"headerlink\" title=\"Why do we need to sort?\"></a>Why do we need to sort?</h5><p>The tuples in a table have no specific order, But users often want to retrieve(检索) tuples in a specific order.</p>\n<ul>\n<li>to support DISTINCT Operation</li>\n<li>Bulk(大部分) loading sorted tuples into a B+ tree index is faster</li>\n<li>Aggragations(GROUP BY)</li>\n</ul>\n<h5 id=\"Think-about-sorting-algorithms\"><a href=\"#Think-about-sorting-algorithms\" class=\"headerlink\" title=\"Think about sorting algorithms\"></a>Think about sorting algorithms</h5><p>If data fits in memory, then we can use a standard sorting algorithm like quick-sort.</p>\n<p>If data does not fit in memory, then we need to use a technique that is aware of <em>the cost of writing data out to disk</em>.</p>\n<h5 id=\"External-merge-sort-abstract\"><a href=\"#External-merge-sort-abstract\" class=\"headerlink\" title=\"External merge sort abstract\"></a>External merge sort abstract</h5><ul>\n<li>Sorting Phase</li>\n</ul>\n<p>Sort small chunks of  of data that fit in main-memory, and then write back the sorted data to a file on disk.</p>\n<ul>\n<li>Merge Phase</li>\n</ul>\n<p>Combine sorted sub-files into a single larger file.</p>\n<h5 id=\"2-WAY-EXTERNAL-MERGE-SORT\"><a href=\"#2-WAY-EXTERNAL-MERGE-SORT\" class=\"headerlink\" title=\"2-WAY EXTERNAL MERGE SORT\"></a>2-WAY EXTERNAL MERGE SORT</h5><p>Files are broken up(分裂) into N pages.</p>\n<p>The DBMS has a finite(限定的) number of B fixed-size(固定大小) buffers.</p>\n<p><strong>Pass #0</strong></p>\n<ul>\n<li>Reads every B pages of the table into memory</li>\n<li>Sorts them, and writes them back to disk</li>\n<li>Each sorted set of pages is called a run</li>\n</ul>\n<p><strong>Pass #1,2,3</strong></p>\n<ul>\n<li>Recursively merges pairs of runs into runs twice as long</li>\n<li>Uses three buffer pages (2 for input pages, 1 for output)</li>\n</ul>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/External-merge-sort1.png\" alt=\"External-merge-sort1\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/External-merge-sort2.png\" alt=\"External-merge-sort2\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/External-merge-sort3.png\" alt=\"External-merge-sort3\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/External-merge-sort4.png\" alt=\"External-merge-sort4\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/External-merge-sort5.png\" alt=\"External-merge-sort5\"></p>\n<p>In each pass, we read and write each page in file.</p>\n<p>Number of passes:<br>$$<br>1 + \\log_{2}{N}<br>$$<br>Total I/O cost：<br>$$<br>2N * (# of-passes)<br>$$<br><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-1.png\" alt=\"EXTERNAL-MERGE-SORT-1\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-2.png\" alt=\"EXTERNAL-MERGE-SORT-2\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-3.png\" alt=\"EXTERNAL-MERGE-SORT-3\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-4.png\" alt=\"EXTERNAL-MERGE-SORT-4\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-5.png\" alt=\"EXTERNAL-MERGE-SORT-5\"></p>\n<p>This algorithm only requires three buffer pages（B=3）</p>\n<p>Even if we have more buffer space available (B &gt; 3)， it does not effectively utilize them</p>\n<h5 id=\"General-external-merge-sort\"><a href=\"#General-external-merge-sort\" class=\"headerlink\" title=\"General external merge sort\"></a>General external merge sort</h5><p><strong>Pass #0</strong></p>\n<ul>\n<li>Use B buffer pages</li>\n<li>Produce [N/B] sorted runs of size B</li>\n</ul>\n<p><strong>Pass #1,2,3</strong></p>\n<ul>\n<li>Merge B-1 runs</li>\n</ul>\n<p>Number of passes:<br>$$<br>1+ log_{B-1}{N/B}<br>$$<br>Tips：N/B和log运算的值都是向上取整</p>\n<p>Total I/O Cost:<br>$$<br>2N * (# of—passes)<br>$$</p>\n<h5 id=\"Using-B-Trees\"><a href=\"#Using-B-Trees\" class=\"headerlink\" title=\"Using B+ Trees\"></a>Using B+ Trees</h5><p>If the table that must be sorted already has a B+ tree index on the sort attribute(s)，then we can use that to accelerate sorting</p>\n<p>Retrieve tuples in desired sort order by simply traversing the leaf pages of the tree</p>\n<h5 id=\"Clustered-B-Tree\"><a href=\"#Clustered-B-Tree\" class=\"headerlink\" title=\"Clustered B+ Tree\"></a>Clustered B+ Tree</h5><p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/Clustered-bplus-tree.png\" alt=\"Clustered-bplus-tree\"></p>\n<p>Traverse to the left-most leaf page, and then retrieve tuples from all leaf pages. This will always better than external sorting.</p>\n<h5 id=\"Unclustered-B-Tree\"><a href=\"#Unclustered-B-Tree\" class=\"headerlink\" title=\"Unclustered B+ Tree\"></a>Unclustered B+ Tree</h5><p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/Unclustered-bplus-tree.png\" alt=\"Unclustered-bplus-tree\"></p>\n<p>Chase each pointer to the page that contains the data.</p>\n<p>This is almost always a bad idea. In general，one I/O per data record.</p>\n<h5 id=\"Aggregations\"><a href=\"#Aggregations\" class=\"headerlink\" title=\"Aggregations\"></a>Aggregations</h5><p>Collapse multiple tuples into a single scalar(标量) value</p>\n<p>Two implementation choices:</p>\n<p>Sorting, Hashing</p>\n<h5 id=\"Sorting-aggregation\"><a href=\"#Sorting-aggregation\" class=\"headerlink\" title=\"Sorting aggregation\"></a>Sorting aggregation</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT DISTINCT cid</span><br><span class=\"line\">FROM enrolled</span><br><span class=\"line\">WHERE grade IN(&apos;B&apos;, &apos;&apos;C)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-1.png\" alt=\"SORTING-AGGREGATION-1\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-2.png\" alt=\"SORTING-AGGREGATION-2\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-3.png\" alt=\"SORTING-AGGREGATION-3\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-4.png\" alt=\"SORTING-AGGREGATION-4\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-5.png\" alt=\"SORTING-AGGREGATION-5\"></p>\n<h5 id=\"Alternatives（选择）-to-sorting\"><a href=\"#Alternatives（选择）-to-sorting\" class=\"headerlink\" title=\"Alternatives（选择） to sorting\"></a>Alternatives（选择） to sorting</h5><p>What if we don’t need the data to be ordered?</p>\n<ul>\n<li>Forming groups in GROUP BY(no ordering)</li>\n<li>Removing duplicates in DISTINCT(no ordering)</li>\n</ul>\n<p>Hashing is a better alternative in this scenario(方案).</p>\n<ul>\n<li>Only need to remove duplicates, no need for ordering.</li>\n<li>Can be computationally cheaper than sorting.</li>\n</ul>\n<h5 id=\"Hashing-aggregate\"><a href=\"#Hashing-aggregate\" class=\"headerlink\" title=\"Hashing aggregate\"></a>Hashing aggregate</h5><p>Populate an ephemeral(临时的) hash table as the DBMS scans the table. For each record，check whether there is already an entry in the hash table:</p>\n<ul>\n<li>DISTINCT: Discard duplicate</li>\n<li>GROUP BY: Perform aggregate computation</li>\n</ul>\n<p>If everything fits in memory, then it’s easy. If we have to spill(溢出) to disk, then we need to be smarter…</p>\n<p>Partition Phase: Divide tuples into buckets based on hash key</p>\n<p>ReHash Phase: Build in-memory hash table for each partition and compute the aggregation.</p>\n<h5 id=\"Hashing-aggregate-phase-1-partition\"><a href=\"#Hashing-aggregate-phase-1-partition\" class=\"headerlink\" title=\"Hashing aggregate phase #1: partition\"></a>Hashing aggregate phase #1: partition</h5><p>Use a hash function h1 to split tuples into partitions on disk.</p>\n<ul>\n<li>We know that all matches live in the same partition.</li>\n<li>Partitions are “spilled” to disk via output buffers.</li>\n</ul>\n<p>Assume that we have B buffers.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT DISTINCT cid</span><br><span class=\"line\">FROM\tenrolled</span><br><span class=\"line\">WHERE\tgrade IN(&apos;B&apos;,&apos;C&apos;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-1.png\" alt=\"HASHING-AGGREGATE-1\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-2.png\" alt=\"HASHING-AGGREGATE-2\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-3.png\" alt=\"HASHING-AGGREGATE-3\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-4.png\" alt=\"HASHING-AGGREGATE-4\"></p>\n<h5 id=\"Hashing-aggregate-phase-2-rehash\"><a href=\"#Hashing-aggregate-phase-2-rehash\" class=\"headerlink\" title=\"Hashing aggregate phase #2: rehash\"></a>Hashing aggregate phase #2: rehash</h5><p>For each partition on disk:</p>\n<ul>\n<li>Read it into memory and build an in-memory hash table based on a second hash function h2.</li>\n<li>Then go through each bucket of this hash table to bring together matching tuples.</li>\n</ul>\n<p>This assumes that  each partition fits in memory.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT DISTINCT cid FROM enrolled WHERE grade IN (&apos;B&apos;, &apos;C&apos;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-5.png\" alt=\"HASHING-AGGREGATE-5\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-6.png\" alt=\"HASHING-AGGREGATE-6\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-7.png\" alt=\"HASHING-AGGREGATE-7\"></p>\n<h5 id=\"Hashing-summarization\"><a href=\"#Hashing-summarization\" class=\"headerlink\" title=\"Hashing summarization\"></a>Hashing summarization</h5><p>During the ReHash phase, store pairs of the form</p>\n<p> (GroupKey -&gt; RunningVal)</p>\n<p>When we want to insert a new tuple into the hash table:</p>\n<ul>\n<li>If we find a matching GroupKey, just update the RunningVal appropriately</li>\n<li>Else insert a new GroupKey-&gt;RunningVal</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT cid, AVG(s.gpa)</span><br><span class=\"line\">FROM student AS s, enrolled AS e</span><br><span class=\"line\">WHERE s.sid = e.sid</span><br><span class=\"line\">GROUP BY cid</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-1.png\" alt=\"HASHING-SUMMARIZATION-1\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-2.png\" alt=\"HASHING-SUMMARIZATION-2\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-3.png\" alt=\"HASHING-SUMMARIZATION-3\"></p>\n<h5 id=\"Cost-analysis\"><a href=\"#Cost-analysis\" class=\"headerlink\" title=\"Cost analysis\"></a>Cost analysis</h5><p>How big of a table can we hash using this approach?</p>\n<ul>\n<li>B-1 “spill partitions” in Phase #1</li>\n<li>Each should be no more than B block big</li>\n</ul>\n<p>Answer: B*(B-1)</p>\n<ul>\n<li>A table of N pages needs about sqrt(N) buffers Use a “fudge factor” f &gt; 1 for that: we need B<em>sqrt(f </em> N)</li>\n</ul>\n<h5 id=\"Concusion\"><a href=\"#Concusion\" class=\"headerlink\" title=\"Concusion\"></a>Concusion</h5><p>Choice of sorting vs. hashing is subtle(微妙的) and depends on optimizations done in each case.</p>\n<p>We already discussed the optimizations for sorting:</p>\n<ul>\n<li>Chunk I/O into large blocks to amortize(摊销) seek+RD costs</li>\n<li>Double-buffering to overlap CPU and I/O</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>Tip 感觉很多话中文翻译过来很别扭，后续就全部用原文做笔记了</li>\n</ul>\n<h4 id=\"Sorting-And-Aggregations（聚合）\"><a href=\"#Sorting-And-Aggregations（聚合）\" class=\"headerlink\" title=\"Sorting And Aggregations（聚合）\"></a>Sorting And Aggregations（聚合）</h4><h5 id=\"Why-do-we-need-to-sort\"><a href=\"#Why-do-we-need-to-sort\" class=\"headerlink\" title=\"Why do we need to sort?\"></a>Why do we need to sort?</h5><p>The tuples in a table have no specific order, But users often want to retrieve(检索) tuples in a specific order.</p>\n<ul>\n<li>to support DISTINCT Operation</li>\n<li>Bulk(大部分) loading sorted tuples into a B+ tree index is faster</li>\n<li>Aggragations(GROUP BY)</li>\n</ul>\n<h5 id=\"Think-about-sorting-algorithms\"><a href=\"#Think-about-sorting-algorithms\" class=\"headerlink\" title=\"Think about sorting algorithms\"></a>Think about sorting algorithms</h5><p>If data fits in memory, then we can use a standard sorting algorithm like quick-sort.</p>\n<p>If data does not fit in memory, then we need to use a technique that is aware of <em>the cost of writing data out to disk</em>.</p>\n<h5 id=\"External-merge-sort-abstract\"><a href=\"#External-merge-sort-abstract\" class=\"headerlink\" title=\"External merge sort abstract\"></a>External merge sort abstract</h5><ul>\n<li>Sorting Phase</li>\n</ul>\n<p>Sort small chunks of  of data that fit in main-memory, and then write back the sorted data to a file on disk.</p>\n<ul>\n<li>Merge Phase</li>\n</ul>\n<p>Combine sorted sub-files into a single larger file.</p>\n<h5 id=\"2-WAY-EXTERNAL-MERGE-SORT\"><a href=\"#2-WAY-EXTERNAL-MERGE-SORT\" class=\"headerlink\" title=\"2-WAY EXTERNAL MERGE SORT\"></a>2-WAY EXTERNAL MERGE SORT</h5><p>Files are broken up(分裂) into N pages.</p>\n<p>The DBMS has a finite(限定的) number of B fixed-size(固定大小) buffers.</p>\n<p><strong>Pass #0</strong></p>\n<ul>\n<li>Reads every B pages of the table into memory</li>\n<li>Sorts them, and writes them back to disk</li>\n<li>Each sorted set of pages is called a run</li>\n</ul>\n<p><strong>Pass #1,2,3</strong></p>\n<ul>\n<li>Recursively merges pairs of runs into runs twice as long</li>\n<li>Uses three buffer pages (2 for input pages, 1 for output)</li>\n</ul>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/External-merge-sort1.png\" alt=\"External-merge-sort1\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/External-merge-sort2.png\" alt=\"External-merge-sort2\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/External-merge-sort3.png\" alt=\"External-merge-sort3\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/External-merge-sort4.png\" alt=\"External-merge-sort4\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/External-merge-sort5.png\" alt=\"External-merge-sort5\"></p>\n<p>In each pass, we read and write each page in file.</p>\n<p>Number of passes:<br>$$<br>1 + \\log_{2}{N}<br>$$<br>Total I/O cost：<br>$$<br>2N * (# of-passes)<br>$$<br><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-1.png\" alt=\"EXTERNAL-MERGE-SORT-1\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-2.png\" alt=\"EXTERNAL-MERGE-SORT-2\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-3.png\" alt=\"EXTERNAL-MERGE-SORT-3\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-4.png\" alt=\"EXTERNAL-MERGE-SORT-4\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-5.png\" alt=\"EXTERNAL-MERGE-SORT-5\"></p>\n<p>This algorithm only requires three buffer pages（B=3）</p>\n<p>Even if we have more buffer space available (B &gt; 3)， it does not effectively utilize them</p>\n<h5 id=\"General-external-merge-sort\"><a href=\"#General-external-merge-sort\" class=\"headerlink\" title=\"General external merge sort\"></a>General external merge sort</h5><p><strong>Pass #0</strong></p>\n<ul>\n<li>Use B buffer pages</li>\n<li>Produce [N/B] sorted runs of size B</li>\n</ul>\n<p><strong>Pass #1,2,3</strong></p>\n<ul>\n<li>Merge B-1 runs</li>\n</ul>\n<p>Number of passes:<br>$$<br>1+ log_{B-1}{N/B}<br>$$<br>Tips：N/B和log运算的值都是向上取整</p>\n<p>Total I/O Cost:<br>$$<br>2N * (# of—passes)<br>$$</p>\n<h5 id=\"Using-B-Trees\"><a href=\"#Using-B-Trees\" class=\"headerlink\" title=\"Using B+ Trees\"></a>Using B+ Trees</h5><p>If the table that must be sorted already has a B+ tree index on the sort attribute(s)，then we can use that to accelerate sorting</p>\n<p>Retrieve tuples in desired sort order by simply traversing the leaf pages of the tree</p>\n<h5 id=\"Clustered-B-Tree\"><a href=\"#Clustered-B-Tree\" class=\"headerlink\" title=\"Clustered B+ Tree\"></a>Clustered B+ Tree</h5><p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/Clustered-bplus-tree.png\" alt=\"Clustered-bplus-tree\"></p>\n<p>Traverse to the left-most leaf page, and then retrieve tuples from all leaf pages. This will always better than external sorting.</p>\n<h5 id=\"Unclustered-B-Tree\"><a href=\"#Unclustered-B-Tree\" class=\"headerlink\" title=\"Unclustered B+ Tree\"></a>Unclustered B+ Tree</h5><p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/Unclustered-bplus-tree.png\" alt=\"Unclustered-bplus-tree\"></p>\n<p>Chase each pointer to the page that contains the data.</p>\n<p>This is almost always a bad idea. In general，one I/O per data record.</p>\n<h5 id=\"Aggregations\"><a href=\"#Aggregations\" class=\"headerlink\" title=\"Aggregations\"></a>Aggregations</h5><p>Collapse multiple tuples into a single scalar(标量) value</p>\n<p>Two implementation choices:</p>\n<p>Sorting, Hashing</p>\n<h5 id=\"Sorting-aggregation\"><a href=\"#Sorting-aggregation\" class=\"headerlink\" title=\"Sorting aggregation\"></a>Sorting aggregation</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT DISTINCT cid</span><br><span class=\"line\">FROM enrolled</span><br><span class=\"line\">WHERE grade IN(&apos;B&apos;, &apos;&apos;C)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-1.png\" alt=\"SORTING-AGGREGATION-1\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-2.png\" alt=\"SORTING-AGGREGATION-2\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-3.png\" alt=\"SORTING-AGGREGATION-3\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-4.png\" alt=\"SORTING-AGGREGATION-4\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-5.png\" alt=\"SORTING-AGGREGATION-5\"></p>\n<h5 id=\"Alternatives（选择）-to-sorting\"><a href=\"#Alternatives（选择）-to-sorting\" class=\"headerlink\" title=\"Alternatives（选择） to sorting\"></a>Alternatives（选择） to sorting</h5><p>What if we don’t need the data to be ordered?</p>\n<ul>\n<li>Forming groups in GROUP BY(no ordering)</li>\n<li>Removing duplicates in DISTINCT(no ordering)</li>\n</ul>\n<p>Hashing is a better alternative in this scenario(方案).</p>\n<ul>\n<li>Only need to remove duplicates, no need for ordering.</li>\n<li>Can be computationally cheaper than sorting.</li>\n</ul>\n<h5 id=\"Hashing-aggregate\"><a href=\"#Hashing-aggregate\" class=\"headerlink\" title=\"Hashing aggregate\"></a>Hashing aggregate</h5><p>Populate an ephemeral(临时的) hash table as the DBMS scans the table. For each record，check whether there is already an entry in the hash table:</p>\n<ul>\n<li>DISTINCT: Discard duplicate</li>\n<li>GROUP BY: Perform aggregate computation</li>\n</ul>\n<p>If everything fits in memory, then it’s easy. If we have to spill(溢出) to disk, then we need to be smarter…</p>\n<p>Partition Phase: Divide tuples into buckets based on hash key</p>\n<p>ReHash Phase: Build in-memory hash table for each partition and compute the aggregation.</p>\n<h5 id=\"Hashing-aggregate-phase-1-partition\"><a href=\"#Hashing-aggregate-phase-1-partition\" class=\"headerlink\" title=\"Hashing aggregate phase #1: partition\"></a>Hashing aggregate phase #1: partition</h5><p>Use a hash function h1 to split tuples into partitions on disk.</p>\n<ul>\n<li>We know that all matches live in the same partition.</li>\n<li>Partitions are “spilled” to disk via output buffers.</li>\n</ul>\n<p>Assume that we have B buffers.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT DISTINCT cid</span><br><span class=\"line\">FROM\tenrolled</span><br><span class=\"line\">WHERE\tgrade IN(&apos;B&apos;,&apos;C&apos;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-1.png\" alt=\"HASHING-AGGREGATE-1\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-2.png\" alt=\"HASHING-AGGREGATE-2\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-3.png\" alt=\"HASHING-AGGREGATE-3\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-4.png\" alt=\"HASHING-AGGREGATE-4\"></p>\n<h5 id=\"Hashing-aggregate-phase-2-rehash\"><a href=\"#Hashing-aggregate-phase-2-rehash\" class=\"headerlink\" title=\"Hashing aggregate phase #2: rehash\"></a>Hashing aggregate phase #2: rehash</h5><p>For each partition on disk:</p>\n<ul>\n<li>Read it into memory and build an in-memory hash table based on a second hash function h2.</li>\n<li>Then go through each bucket of this hash table to bring together matching tuples.</li>\n</ul>\n<p>This assumes that  each partition fits in memory.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT DISTINCT cid FROM enrolled WHERE grade IN (&apos;B&apos;, &apos;C&apos;)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-5.png\" alt=\"HASHING-AGGREGATE-5\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-6.png\" alt=\"HASHING-AGGREGATE-6\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-7.png\" alt=\"HASHING-AGGREGATE-7\"></p>\n<h5 id=\"Hashing-summarization\"><a href=\"#Hashing-summarization\" class=\"headerlink\" title=\"Hashing summarization\"></a>Hashing summarization</h5><p>During the ReHash phase, store pairs of the form</p>\n<p> (GroupKey -&gt; RunningVal)</p>\n<p>When we want to insert a new tuple into the hash table:</p>\n<ul>\n<li>If we find a matching GroupKey, just update the RunningVal appropriately</li>\n<li>Else insert a new GroupKey-&gt;RunningVal</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT cid, AVG(s.gpa)</span><br><span class=\"line\">FROM student AS s, enrolled AS e</span><br><span class=\"line\">WHERE s.sid = e.sid</span><br><span class=\"line\">GROUP BY cid</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-1.png\" alt=\"HASHING-SUMMARIZATION-1\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-2.png\" alt=\"HASHING-SUMMARIZATION-2\"></p>\n<p><img src=\"/2019/05/12/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-3.png\" alt=\"HASHING-SUMMARIZATION-3\"></p>\n<h5 id=\"Cost-analysis\"><a href=\"#Cost-analysis\" class=\"headerlink\" title=\"Cost analysis\"></a>Cost analysis</h5><p>How big of a table can we hash using this approach?</p>\n<ul>\n<li>B-1 “spill partitions” in Phase #1</li>\n<li>Each should be no more than B block big</li>\n</ul>\n<p>Answer: B*(B-1)</p>\n<ul>\n<li>A table of N pages needs about sqrt(N) buffers Use a “fudge factor” f &gt; 1 for that: we need B<em>sqrt(f </em> N)</li>\n</ul>\n<h5 id=\"Concusion\"><a href=\"#Concusion\" class=\"headerlink\" title=\"Concusion\"></a>Concusion</h5><p>Choice of sorting vs. hashing is subtle(微妙的) and depends on optimizations done in each case.</p>\n<p>We already discussed the optimizations for sorting:</p>\n<ul>\n<li>Chunk I/O into large blocks to amortize(摊销) seek+RD costs</li>\n<li>Double-buffering to overlap CPU and I/O</li>\n</ul>\n"},{"title":"CMU-DBMS-COURSE-16-NOTES","date":"2019-06-19T15:47:35.000Z","_content":"\n##### Semester(学期) status \n\nA DBMS's concurrency control and recovery components permeate(渗透) throughout the design of its entire architecture.\n\n![Status](CMU-DBMS-COURSE-16-NOTES/Status.png)\n\n##### Motivation\n\nWe both change the same record in a table at the same time.\n\nHow to avoid race(竞争) condition? (Lost Updates Concurrency Control)\n\nYou transfer $100 between bank accounts but there is a power failure.\n\nWhat is the correct database state? (Durability Recovery)\n\n##### Concurrency control & recovery\n\nValuable properties of DBMSs (DBMS的重要特性)\n\nBased on concept of transactions with ACID properties.\n\n##### Transactions\n\nA transaction is the execution of a sequence of one or more operations (e.g., SQL queries) on a shared database to perform some higher-level function.\n\nIt is the basic unit of change in DBMS\n\n**Example**\n\nMove $100 from Andy' bank account to his bookie's account.\n\nTransaction:\n\n- Check whether Andy has $100.\n\n- Deduct $100 from his account.\n\n- Add $100 to his bookie's account.\n\n##### Strawman System\n\nExecute each txn one-by-one(i.e., serial order) as they arrive at the DBMS.\n\n- One and only one txn can be running at the same time in the DBMS.\n\nBefore a txn starts, copy the entire database to a new file and make all changes to that file.\n\n- If the txn completes successfully, overwrite the original file with the new one.\n- If the txn fails, just remove the dirty copy.\n\n##### Definitions\n\nA txn may carry out many operations on the data retrieved from the database\n\nHowever, the DBMS is only concerned about what data is read/written from/to the database.\n\n- Changes to the \"outside world\" are beyond the scope of the DBMS.\n\n##### Formal Definitions\n\nDatabase: A fixed set of named data objects(e.g., A,B,C,...)\n\n- We do not need to define what these objects are now\n\nTransaction: A sequence of read and write operations(R(A), W(B), ...)\n\n- DBMS's abstract view of a user program\n\n##### Transactions in SQL\n\nA new txn starts with the BEGIN command.\n\nThe txn stops with either COMMIT or ABORT:\n\n- If commit, all changes are saved.\n- If abort, all changes are undone so that it's like as if the txn never executed at all.\n- Abort can be either self-inflicted or caused by the DBMS.\n\n##### Correnctness criteria: ACID\n\n**Atomicity:** All actions in the txn happen, or none happen.\n\n**Consistency:** If each txn is consistent and the DB starts consistent, then it ends up consistent.\n\n**Isolation:** Execution of one txn is isolated from that of other txns.\n\n**Durability:** If a txn commits, its effects persist.\n\n##### Atomicity of transactions\n\nTwo possible outcomes of executing a txn:\n\n- Commit after completing all its actions.\n- Abort(or be aborted by the DBMS) after executing some actions.\n\nDBMS guarantees that txns are atomic.\n\n- From user's point of view: txn always either executes all its actions, or executes no actions at all.\n\nWe take $100 out of Andy's account but then there is a power failure before we transfer it to his bookie.\n\n*When the database comes back on-line, what should be the correct state of Andy's account?*\n\n##### Mechanisms(机制) for ensuring atomicity\n\n**Approach #1: Logging**\n\n- DBMS logs all actions so that it can undo the actions of aborted transactions.\n- Think of the like the black box in airplanes...\n\nLogging used by all modern systems.\n\n- Audit Trail(审计跟踪) & Efficiency Reasons\n\n**Approach #2: Shadow Paging**\n\n- DBMS makes copies of pages and txns make changes to those copies. Only when the txn commits it the page made visible to others.\n- Originally from System R.\n\nFew systems do this:\n\n- CouchDB\n- LMDB(OpenLDAP)\n\n##### Consistency\n\nThe \"world\" represented by the database is logically correct. All questions asked about the data are given logically correct answers.\n\n##### Database consistency\n\nThe database accurately models the real world and follows integrity(完整性) constraints.\n\nTransactions in the future see the effects of transactions committed in the past inside of the database.\n\n##### Transaction consistency\n\nIf the database is consistent before the transaction starts(running alone), it will also be consistent after.\n\nTransaction consistency is the application's responsibility.\n\n##### Isolatin of transactions\n\nUsers submit txns, and each txn executes as if it was running by itself.\n\nConcurrency is achieved by DBMS, which interleaves(交错) actions (reads/writes of DB objects) of various transactions.\n\n##### Mechanisms(机制) for ensuring isolation\n\nA concurrency control protocol is how the DBMS decides the proper interleaving of operations from multiple transactions.\n\nTwo categories of protocols:\n\n**Pessimistic:** Don't let problems arise in the first place.\n\n**Optimistic: **Assume conflicts are rare, deal with them after they happen.\n\n##### Example![Exmple](CMU-DBMS-COURSE-16-NOTES/Exmple.png)\n\nAssume at first A and B each have $1000.\n\nT1 transfers $100 from A's account to B's \n\nT2 credits both accounts with 6% interest.\n\n*What are the possible outcomes of running T1 and T2?*\n\nMany! But A+B should be:\n\n- $2000 * 1.06 = 2120$\n\nThere is no guarantee that T1 will execute before T2 or vice-versa(反之亦然), if both are submitted together. But, the net effect must be equivalent to these two transactions running serially(连续的) in some order.\n\n![SERIAL-EXECUTION-EXAMPLE](CMU-DBMS-COURSE-16-NOTES/SERIAL-EXECUTION-EXAMPLE.png)\n\n##### Interleaving transactions\n\nWe interleave txns to maximize concurrency.\n\n- Slow disk/network I/O.\n- Multi-core CPUs.\n\nWhen one txn stalls(暂停) because of a resource (e.g., page fault), another txn  \n\ncan continue executing and make forward progress.\n\n##### Interleaving example(GOOD)\n\n![INTERLEAVING-EXAMPLE-(GOOD)-1](CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD)-1.png)\n\n![INTERLEAVING-EXAMPLE-(GOOD)-2](CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD)-2.png)\n\n##### Interleaving example(BAD)\n\n![INTERLEAVING-EXAMPLE-(BAD)-1](CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-1.png)\n\n![INTERLEAVING-EXAMPLE-(BAD)-2](CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-2.png)\n\n![INTERLEAVING-EXAMPLE-(BAD)-3](CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-3.png)\n\nTips：2014算错了 应该为 A=954, B=1160, A+B = 2114\n\n##### Correctness\n\n*How do we judge whether a schedule is correct?*\n\nIf the schedule is equivalent to some serial execution.\n\n##### Formal(正式的) properties of schedules\n\n**Serial Schedule**\n\n- A schedule that does not interleave the actions of different transactions.\n\n**Equivalent Schedules**\n\n- For any database state, the effect of executing the first schedule is identical to the effect of executing the second schedule.\n- Doesn't matter what the arithmetic operations are!\n\n##### Serializable(可串行化的) Schedule\n\n- A schedule that is equivalent to some serial execution of the transactions.\n\nIf each transaction preserves consistency, every serializable schedule preserves consistency.\n\nSerializability is a less intuitive(直观) notion(概念) of correctness compared to txn initiation time or commit order, but it provides the DBMS with additional flexibility in scheduling operations.\n\nMore flexibility means better parallelism.\n\n##### Conflicting operations\n\nWe need a formal notion of equivalence that can be implemented efficiently based on the notion of \"conflicting\" operations.\n\nTwo operations conflict if:\n\n- They are by different transactions\n- They are on the same object and at least one of them is a write.\n\n##### Interleaved execution anomalies(异常)\n\n*Read-Write conflicts*\n\nUnrepeatable Reads \n\n![Unrepeatable-Reads](CMU-DBMS-COURSE-16-NOTES/Unrepeatable-Reads.png)\n\nReading Uncommitted Data (\"Dirty Reads\")\n\n![Reading-Uncommitted-Data](CMU-DBMS-COURSE-16-NOTES/Reading-Uncommitted-Data.png)\n\nOverwriting Uncommitted Data\n\n![Overwriting-Uncommitted-Data](CMU-DBMS-COURSE-16-NOTES/Overwriting-Uncommitted-Data.png)\n\n##### Formal properties of schedules\n\nGiven these conflicts, we now can understand what it means for a schedule to be serializable.\n\n- This is to check whether schedules are correct.\n- This is not how to generate a correct schedule.\n\nThere are different levels of serializability:\n\n- Conflict Serializability - Most DBMSs try to support this.\n- View Serializability - No DBMS can do this.\n\n##### Conflict serializability intuition\n\nSchedule S is conflict serializable if you are able to transform S into a serial schedule by swapping consecutive(连续不断的) non-conflicting operations of different transactions.\n\n![CONFLICT-SERIALIZABILITY-INTUITION-1](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-1.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-2](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-2.png)![CONFLICT-SERIALIZABILITY-INTUITION-3](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-3.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-4](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-4.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-5](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-5.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-6](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-6.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-7](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-7.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-8](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-8.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-9](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-9.png)\n\n##### Serializability\n\nSwapping operations is easy when there are only two tens in the schedule. It's cumbersome(麻烦) when there many txns.\n\n##### Dependency graphs\n\nOne node per txn\n\nEdge from Ti to Tj if:\n\n- And operation Oi of Ti conflicts with an operation Oj of Tj \n- Oi appears earlier in the schedule than Oj\n\nAlso known as a precedence(优先) graph\n\nA schedule is conflict serializable if its dependency graph is acyclic(无环的).\n\n##### Example #1\n\n![EXAMPLE-1-1](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-1.png)\n\n![EXAMPLE-1-2](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-2.png)\n\n##### Example #2 Threesome\n\n![EXAMPLE-2-1](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-1.png)\n\n![EXAMPLE-2-2](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-2.png)\n\n![EXAMPLE-2-3](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-3.png)\n\n##### Example #3 Inconsistenct analysis\n\n![EXAMPLE-3-1](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-1.png)\n\n![EXAMPLE-3-2](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-2.png)\n\n![EXAMPLE-3-3](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-3.png)\n\n![EXAMPLE-3-4](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-4.png)\n\n##### View serializability\n\n![VIEW-SERIALIZABILITY-1](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-1.png)\n\n![VIEW-SERIALIZABILITY-2](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-2.png)\n\n![VIEW-SERIALIZABILITY-3](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-3.png)\n\n![VIEW-SERIALIZABILITY-4](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-4.png)\n\n![VIEW-SERIALIZABILITY-5](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-5.png)\n\n![VIEW-SERIALIZABILITY-6](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-6.png)\n\n","source":"_posts/CMU-DBMS-COURSE-16-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-16-NOTES\ndate: 2019-06-19 23:47:35\ntags: Concurrency control theory \n---\n\n##### Semester(学期) status \n\nA DBMS's concurrency control and recovery components permeate(渗透) throughout the design of its entire architecture.\n\n![Status](CMU-DBMS-COURSE-16-NOTES/Status.png)\n\n##### Motivation\n\nWe both change the same record in a table at the same time.\n\nHow to avoid race(竞争) condition? (Lost Updates Concurrency Control)\n\nYou transfer $100 between bank accounts but there is a power failure.\n\nWhat is the correct database state? (Durability Recovery)\n\n##### Concurrency control & recovery\n\nValuable properties of DBMSs (DBMS的重要特性)\n\nBased on concept of transactions with ACID properties.\n\n##### Transactions\n\nA transaction is the execution of a sequence of one or more operations (e.g., SQL queries) on a shared database to perform some higher-level function.\n\nIt is the basic unit of change in DBMS\n\n**Example**\n\nMove $100 from Andy' bank account to his bookie's account.\n\nTransaction:\n\n- Check whether Andy has $100.\n\n- Deduct $100 from his account.\n\n- Add $100 to his bookie's account.\n\n##### Strawman System\n\nExecute each txn one-by-one(i.e., serial order) as they arrive at the DBMS.\n\n- One and only one txn can be running at the same time in the DBMS.\n\nBefore a txn starts, copy the entire database to a new file and make all changes to that file.\n\n- If the txn completes successfully, overwrite the original file with the new one.\n- If the txn fails, just remove the dirty copy.\n\n##### Definitions\n\nA txn may carry out many operations on the data retrieved from the database\n\nHowever, the DBMS is only concerned about what data is read/written from/to the database.\n\n- Changes to the \"outside world\" are beyond the scope of the DBMS.\n\n##### Formal Definitions\n\nDatabase: A fixed set of named data objects(e.g., A,B,C,...)\n\n- We do not need to define what these objects are now\n\nTransaction: A sequence of read and write operations(R(A), W(B), ...)\n\n- DBMS's abstract view of a user program\n\n##### Transactions in SQL\n\nA new txn starts with the BEGIN command.\n\nThe txn stops with either COMMIT or ABORT:\n\n- If commit, all changes are saved.\n- If abort, all changes are undone so that it's like as if the txn never executed at all.\n- Abort can be either self-inflicted or caused by the DBMS.\n\n##### Correnctness criteria: ACID\n\n**Atomicity:** All actions in the txn happen, or none happen.\n\n**Consistency:** If each txn is consistent and the DB starts consistent, then it ends up consistent.\n\n**Isolation:** Execution of one txn is isolated from that of other txns.\n\n**Durability:** If a txn commits, its effects persist.\n\n##### Atomicity of transactions\n\nTwo possible outcomes of executing a txn:\n\n- Commit after completing all its actions.\n- Abort(or be aborted by the DBMS) after executing some actions.\n\nDBMS guarantees that txns are atomic.\n\n- From user's point of view: txn always either executes all its actions, or executes no actions at all.\n\nWe take $100 out of Andy's account but then there is a power failure before we transfer it to his bookie.\n\n*When the database comes back on-line, what should be the correct state of Andy's account?*\n\n##### Mechanisms(机制) for ensuring atomicity\n\n**Approach #1: Logging**\n\n- DBMS logs all actions so that it can undo the actions of aborted transactions.\n- Think of the like the black box in airplanes...\n\nLogging used by all modern systems.\n\n- Audit Trail(审计跟踪) & Efficiency Reasons\n\n**Approach #2: Shadow Paging**\n\n- DBMS makes copies of pages and txns make changes to those copies. Only when the txn commits it the page made visible to others.\n- Originally from System R.\n\nFew systems do this:\n\n- CouchDB\n- LMDB(OpenLDAP)\n\n##### Consistency\n\nThe \"world\" represented by the database is logically correct. All questions asked about the data are given logically correct answers.\n\n##### Database consistency\n\nThe database accurately models the real world and follows integrity(完整性) constraints.\n\nTransactions in the future see the effects of transactions committed in the past inside of the database.\n\n##### Transaction consistency\n\nIf the database is consistent before the transaction starts(running alone), it will also be consistent after.\n\nTransaction consistency is the application's responsibility.\n\n##### Isolatin of transactions\n\nUsers submit txns, and each txn executes as if it was running by itself.\n\nConcurrency is achieved by DBMS, which interleaves(交错) actions (reads/writes of DB objects) of various transactions.\n\n##### Mechanisms(机制) for ensuring isolation\n\nA concurrency control protocol is how the DBMS decides the proper interleaving of operations from multiple transactions.\n\nTwo categories of protocols:\n\n**Pessimistic:** Don't let problems arise in the first place.\n\n**Optimistic: **Assume conflicts are rare, deal with them after they happen.\n\n##### Example![Exmple](CMU-DBMS-COURSE-16-NOTES/Exmple.png)\n\nAssume at first A and B each have $1000.\n\nT1 transfers $100 from A's account to B's \n\nT2 credits both accounts with 6% interest.\n\n*What are the possible outcomes of running T1 and T2?*\n\nMany! But A+B should be:\n\n- $2000 * 1.06 = 2120$\n\nThere is no guarantee that T1 will execute before T2 or vice-versa(反之亦然), if both are submitted together. But, the net effect must be equivalent to these two transactions running serially(连续的) in some order.\n\n![SERIAL-EXECUTION-EXAMPLE](CMU-DBMS-COURSE-16-NOTES/SERIAL-EXECUTION-EXAMPLE.png)\n\n##### Interleaving transactions\n\nWe interleave txns to maximize concurrency.\n\n- Slow disk/network I/O.\n- Multi-core CPUs.\n\nWhen one txn stalls(暂停) because of a resource (e.g., page fault), another txn  \n\ncan continue executing and make forward progress.\n\n##### Interleaving example(GOOD)\n\n![INTERLEAVING-EXAMPLE-(GOOD)-1](CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD)-1.png)\n\n![INTERLEAVING-EXAMPLE-(GOOD)-2](CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD)-2.png)\n\n##### Interleaving example(BAD)\n\n![INTERLEAVING-EXAMPLE-(BAD)-1](CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-1.png)\n\n![INTERLEAVING-EXAMPLE-(BAD)-2](CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-2.png)\n\n![INTERLEAVING-EXAMPLE-(BAD)-3](CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-3.png)\n\nTips：2014算错了 应该为 A=954, B=1160, A+B = 2114\n\n##### Correctness\n\n*How do we judge whether a schedule is correct?*\n\nIf the schedule is equivalent to some serial execution.\n\n##### Formal(正式的) properties of schedules\n\n**Serial Schedule**\n\n- A schedule that does not interleave the actions of different transactions.\n\n**Equivalent Schedules**\n\n- For any database state, the effect of executing the first schedule is identical to the effect of executing the second schedule.\n- Doesn't matter what the arithmetic operations are!\n\n##### Serializable(可串行化的) Schedule\n\n- A schedule that is equivalent to some serial execution of the transactions.\n\nIf each transaction preserves consistency, every serializable schedule preserves consistency.\n\nSerializability is a less intuitive(直观) notion(概念) of correctness compared to txn initiation time or commit order, but it provides the DBMS with additional flexibility in scheduling operations.\n\nMore flexibility means better parallelism.\n\n##### Conflicting operations\n\nWe need a formal notion of equivalence that can be implemented efficiently based on the notion of \"conflicting\" operations.\n\nTwo operations conflict if:\n\n- They are by different transactions\n- They are on the same object and at least one of them is a write.\n\n##### Interleaved execution anomalies(异常)\n\n*Read-Write conflicts*\n\nUnrepeatable Reads \n\n![Unrepeatable-Reads](CMU-DBMS-COURSE-16-NOTES/Unrepeatable-Reads.png)\n\nReading Uncommitted Data (\"Dirty Reads\")\n\n![Reading-Uncommitted-Data](CMU-DBMS-COURSE-16-NOTES/Reading-Uncommitted-Data.png)\n\nOverwriting Uncommitted Data\n\n![Overwriting-Uncommitted-Data](CMU-DBMS-COURSE-16-NOTES/Overwriting-Uncommitted-Data.png)\n\n##### Formal properties of schedules\n\nGiven these conflicts, we now can understand what it means for a schedule to be serializable.\n\n- This is to check whether schedules are correct.\n- This is not how to generate a correct schedule.\n\nThere are different levels of serializability:\n\n- Conflict Serializability - Most DBMSs try to support this.\n- View Serializability - No DBMS can do this.\n\n##### Conflict serializability intuition\n\nSchedule S is conflict serializable if you are able to transform S into a serial schedule by swapping consecutive(连续不断的) non-conflicting operations of different transactions.\n\n![CONFLICT-SERIALIZABILITY-INTUITION-1](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-1.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-2](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-2.png)![CONFLICT-SERIALIZABILITY-INTUITION-3](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-3.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-4](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-4.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-5](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-5.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-6](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-6.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-7](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-7.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-8](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-8.png)\n\n![CONFLICT-SERIALIZABILITY-INTUITION-9](CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-9.png)\n\n##### Serializability\n\nSwapping operations is easy when there are only two tens in the schedule. It's cumbersome(麻烦) when there many txns.\n\n##### Dependency graphs\n\nOne node per txn\n\nEdge from Ti to Tj if:\n\n- And operation Oi of Ti conflicts with an operation Oj of Tj \n- Oi appears earlier in the schedule than Oj\n\nAlso known as a precedence(优先) graph\n\nA schedule is conflict serializable if its dependency graph is acyclic(无环的).\n\n##### Example #1\n\n![EXAMPLE-1-1](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-1.png)\n\n![EXAMPLE-1-2](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-2.png)\n\n##### Example #2 Threesome\n\n![EXAMPLE-2-1](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-1.png)\n\n![EXAMPLE-2-2](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-2.png)\n\n![EXAMPLE-2-3](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-3.png)\n\n##### Example #3 Inconsistenct analysis\n\n![EXAMPLE-3-1](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-1.png)\n\n![EXAMPLE-3-2](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-2.png)\n\n![EXAMPLE-3-3](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-3.png)\n\n![EXAMPLE-3-4](CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-4.png)\n\n##### View serializability\n\n![VIEW-SERIALIZABILITY-1](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-1.png)\n\n![VIEW-SERIALIZABILITY-2](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-2.png)\n\n![VIEW-SERIALIZABILITY-3](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-3.png)\n\n![VIEW-SERIALIZABILITY-4](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-4.png)\n\n![VIEW-SERIALIZABILITY-5](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-5.png)\n\n![VIEW-SERIALIZABILITY-6](CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-6.png)\n\n","slug":"CMU-DBMS-COURSE-16-NOTES","published":1,"updated":"2019-06-29T06:00:39.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvynr000mvkqpq8z2sv51","content":"<h5 id=\"Semester-学期-status\"><a href=\"#Semester-学期-status\" class=\"headerlink\" title=\"Semester(学期) status\"></a>Semester(学期) status</h5><p>A DBMS’s concurrency control and recovery components permeate(渗透) throughout the design of its entire architecture.</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/Status.png\" alt=\"Status\"></p>\n<h5 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h5><p>We both change the same record in a table at the same time.</p>\n<p>How to avoid race(竞争) condition? (Lost Updates Concurrency Control)</p>\n<p>You transfer $100 between bank accounts but there is a power failure.</p>\n<p>What is the correct database state? (Durability Recovery)</p>\n<h5 id=\"Concurrency-control-amp-recovery\"><a href=\"#Concurrency-control-amp-recovery\" class=\"headerlink\" title=\"Concurrency control &amp; recovery\"></a>Concurrency control &amp; recovery</h5><p>Valuable properties of DBMSs (DBMS的重要特性)</p>\n<p>Based on concept of transactions with ACID properties.</p>\n<h5 id=\"Transactions\"><a href=\"#Transactions\" class=\"headerlink\" title=\"Transactions\"></a>Transactions</h5><p>A transaction is the execution of a sequence of one or more operations (e.g., SQL queries) on a shared database to perform some higher-level function.</p>\n<p>It is the basic unit of change in DBMS</p>\n<p><strong>Example</strong></p>\n<p>Move $100 from Andy’ bank account to his bookie’s account.</p>\n<p>Transaction:</p>\n<ul>\n<li><p>Check whether Andy has $100.</p>\n</li>\n<li><p>Deduct $100 from his account.</p>\n</li>\n<li><p>Add $100 to his bookie’s account.</p>\n</li>\n</ul>\n<h5 id=\"Strawman-System\"><a href=\"#Strawman-System\" class=\"headerlink\" title=\"Strawman System\"></a>Strawman System</h5><p>Execute each txn one-by-one(i.e., serial order) as they arrive at the DBMS.</p>\n<ul>\n<li>One and only one txn can be running at the same time in the DBMS.</li>\n</ul>\n<p>Before a txn starts, copy the entire database to a new file and make all changes to that file.</p>\n<ul>\n<li>If the txn completes successfully, overwrite the original file with the new one.</li>\n<li>If the txn fails, just remove the dirty copy.</li>\n</ul>\n<h5 id=\"Definitions\"><a href=\"#Definitions\" class=\"headerlink\" title=\"Definitions\"></a>Definitions</h5><p>A txn may carry out many operations on the data retrieved from the database</p>\n<p>However, the DBMS is only concerned about what data is read/written from/to the database.</p>\n<ul>\n<li>Changes to the “outside world” are beyond the scope of the DBMS.</li>\n</ul>\n<h5 id=\"Formal-Definitions\"><a href=\"#Formal-Definitions\" class=\"headerlink\" title=\"Formal Definitions\"></a>Formal Definitions</h5><p>Database: A fixed set of named data objects(e.g., A,B,C,…)</p>\n<ul>\n<li>We do not need to define what these objects are now</li>\n</ul>\n<p>Transaction: A sequence of read and write operations(R(A), W(B), …)</p>\n<ul>\n<li>DBMS’s abstract view of a user program</li>\n</ul>\n<h5 id=\"Transactions-in-SQL\"><a href=\"#Transactions-in-SQL\" class=\"headerlink\" title=\"Transactions in SQL\"></a>Transactions in SQL</h5><p>A new txn starts with the BEGIN command.</p>\n<p>The txn stops with either COMMIT or ABORT:</p>\n<ul>\n<li>If commit, all changes are saved.</li>\n<li>If abort, all changes are undone so that it’s like as if the txn never executed at all.</li>\n<li>Abort can be either self-inflicted or caused by the DBMS.</li>\n</ul>\n<h5 id=\"Correnctness-criteria-ACID\"><a href=\"#Correnctness-criteria-ACID\" class=\"headerlink\" title=\"Correnctness criteria: ACID\"></a>Correnctness criteria: ACID</h5><p><strong>Atomicity:</strong> All actions in the txn happen, or none happen.</p>\n<p><strong>Consistency:</strong> If each txn is consistent and the DB starts consistent, then it ends up consistent.</p>\n<p><strong>Isolation:</strong> Execution of one txn is isolated from that of other txns.</p>\n<p><strong>Durability:</strong> If a txn commits, its effects persist.</p>\n<h5 id=\"Atomicity-of-transactions\"><a href=\"#Atomicity-of-transactions\" class=\"headerlink\" title=\"Atomicity of transactions\"></a>Atomicity of transactions</h5><p>Two possible outcomes of executing a txn:</p>\n<ul>\n<li>Commit after completing all its actions.</li>\n<li>Abort(or be aborted by the DBMS) after executing some actions.</li>\n</ul>\n<p>DBMS guarantees that txns are atomic.</p>\n<ul>\n<li>From user’s point of view: txn always either executes all its actions, or executes no actions at all.</li>\n</ul>\n<p>We take $100 out of Andy’s account but then there is a power failure before we transfer it to his bookie.</p>\n<p><em>When the database comes back on-line, what should be the correct state of Andy’s account?</em></p>\n<h5 id=\"Mechanisms-机制-for-ensuring-atomicity\"><a href=\"#Mechanisms-机制-for-ensuring-atomicity\" class=\"headerlink\" title=\"Mechanisms(机制) for ensuring atomicity\"></a>Mechanisms(机制) for ensuring atomicity</h5><p><strong>Approach #1: Logging</strong></p>\n<ul>\n<li>DBMS logs all actions so that it can undo the actions of aborted transactions.</li>\n<li>Think of the like the black box in airplanes…</li>\n</ul>\n<p>Logging used by all modern systems.</p>\n<ul>\n<li>Audit Trail(审计跟踪) &amp; Efficiency Reasons</li>\n</ul>\n<p><strong>Approach #2: Shadow Paging</strong></p>\n<ul>\n<li>DBMS makes copies of pages and txns make changes to those copies. Only when the txn commits it the page made visible to others.</li>\n<li>Originally from System R.</li>\n</ul>\n<p>Few systems do this:</p>\n<ul>\n<li>CouchDB</li>\n<li>LMDB(OpenLDAP)</li>\n</ul>\n<h5 id=\"Consistency\"><a href=\"#Consistency\" class=\"headerlink\" title=\"Consistency\"></a>Consistency</h5><p>The “world” represented by the database is logically correct. All questions asked about the data are given logically correct answers.</p>\n<h5 id=\"Database-consistency\"><a href=\"#Database-consistency\" class=\"headerlink\" title=\"Database consistency\"></a>Database consistency</h5><p>The database accurately models the real world and follows integrity(完整性) constraints.</p>\n<p>Transactions in the future see the effects of transactions committed in the past inside of the database.</p>\n<h5 id=\"Transaction-consistency\"><a href=\"#Transaction-consistency\" class=\"headerlink\" title=\"Transaction consistency\"></a>Transaction consistency</h5><p>If the database is consistent before the transaction starts(running alone), it will also be consistent after.</p>\n<p>Transaction consistency is the application’s responsibility.</p>\n<h5 id=\"Isolatin-of-transactions\"><a href=\"#Isolatin-of-transactions\" class=\"headerlink\" title=\"Isolatin of transactions\"></a>Isolatin of transactions</h5><p>Users submit txns, and each txn executes as if it was running by itself.</p>\n<p>Concurrency is achieved by DBMS, which interleaves(交错) actions (reads/writes of DB objects) of various transactions.</p>\n<h5 id=\"Mechanisms-机制-for-ensuring-isolation\"><a href=\"#Mechanisms-机制-for-ensuring-isolation\" class=\"headerlink\" title=\"Mechanisms(机制) for ensuring isolation\"></a>Mechanisms(机制) for ensuring isolation</h5><p>A concurrency control protocol is how the DBMS decides the proper interleaving of operations from multiple transactions.</p>\n<p>Two categories of protocols:</p>\n<p><strong>Pessimistic:</strong> Don’t let problems arise in the first place.</p>\n<p><strong>Optimistic: </strong>Assume conflicts are rare, deal with them after they happen.</p>\n<h5 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example<img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/Exmple.png\" alt=\"Exmple\"></h5><p>Assume at first A and B each have $1000.</p>\n<p>T1 transfers $100 from A’s account to B’s </p>\n<p>T2 credits both accounts with 6% interest.</p>\n<p><em>What are the possible outcomes of running T1 and T2?</em></p>\n<p>Many! But A+B should be:</p>\n<ul>\n<li>$2000 * 1.06 = 2120$</li>\n</ul>\n<p>There is no guarantee that T1 will execute before T2 or vice-versa(反之亦然), if both are submitted together. But, the net effect must be equivalent to these two transactions running serially(连续的) in some order.</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/SERIAL-EXECUTION-EXAMPLE.png\" alt=\"SERIAL-EXECUTION-EXAMPLE\"></p>\n<h5 id=\"Interleaving-transactions\"><a href=\"#Interleaving-transactions\" class=\"headerlink\" title=\"Interleaving transactions\"></a>Interleaving transactions</h5><p>We interleave txns to maximize concurrency.</p>\n<ul>\n<li>Slow disk/network I/O.</li>\n<li>Multi-core CPUs.</li>\n</ul>\n<p>When one txn stalls(暂停) because of a resource (e.g., page fault), another txn  </p>\n<p>can continue executing and make forward progress.</p>\n<h5 id=\"Interleaving-example-GOOD\"><a href=\"#Interleaving-example-GOOD\" class=\"headerlink\" title=\"Interleaving example(GOOD)\"></a>Interleaving example(GOOD)</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD\" alt=\"INTERLEAVING-EXAMPLE-(GOOD)-1\">-1.png)</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD\" alt=\"INTERLEAVING-EXAMPLE-(GOOD)-2\">-2.png)</p>\n<h5 id=\"Interleaving-example-BAD\"><a href=\"#Interleaving-example-BAD\" class=\"headerlink\" title=\"Interleaving example(BAD)\"></a>Interleaving example(BAD)</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD\" alt=\"INTERLEAVING-EXAMPLE-(BAD)-1\">-1.png)</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD\" alt=\"INTERLEAVING-EXAMPLE-(BAD)-2\">-2.png)</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD\" alt=\"INTERLEAVING-EXAMPLE-(BAD)-3\">-3.png)</p>\n<p>Tips：2014算错了 应该为 A=954, B=1160, A+B = 2114</p>\n<h5 id=\"Correctness\"><a href=\"#Correctness\" class=\"headerlink\" title=\"Correctness\"></a>Correctness</h5><p><em>How do we judge whether a schedule is correct?</em></p>\n<p>If the schedule is equivalent to some serial execution.</p>\n<h5 id=\"Formal-正式的-properties-of-schedules\"><a href=\"#Formal-正式的-properties-of-schedules\" class=\"headerlink\" title=\"Formal(正式的) properties of schedules\"></a>Formal(正式的) properties of schedules</h5><p><strong>Serial Schedule</strong></p>\n<ul>\n<li>A schedule that does not interleave the actions of different transactions.</li>\n</ul>\n<p><strong>Equivalent Schedules</strong></p>\n<ul>\n<li>For any database state, the effect of executing the first schedule is identical to the effect of executing the second schedule.</li>\n<li>Doesn’t matter what the arithmetic operations are!</li>\n</ul>\n<h5 id=\"Serializable-可串行化的-Schedule\"><a href=\"#Serializable-可串行化的-Schedule\" class=\"headerlink\" title=\"Serializable(可串行化的) Schedule\"></a>Serializable(可串行化的) Schedule</h5><ul>\n<li>A schedule that is equivalent to some serial execution of the transactions.</li>\n</ul>\n<p>If each transaction preserves consistency, every serializable schedule preserves consistency.</p>\n<p>Serializability is a less intuitive(直观) notion(概念) of correctness compared to txn initiation time or commit order, but it provides the DBMS with additional flexibility in scheduling operations.</p>\n<p>More flexibility means better parallelism.</p>\n<h5 id=\"Conflicting-operations\"><a href=\"#Conflicting-operations\" class=\"headerlink\" title=\"Conflicting operations\"></a>Conflicting operations</h5><p>We need a formal notion of equivalence that can be implemented efficiently based on the notion of “conflicting” operations.</p>\n<p>Two operations conflict if:</p>\n<ul>\n<li>They are by different transactions</li>\n<li>They are on the same object and at least one of them is a write.</li>\n</ul>\n<h5 id=\"Interleaved-execution-anomalies-异常\"><a href=\"#Interleaved-execution-anomalies-异常\" class=\"headerlink\" title=\"Interleaved execution anomalies(异常)\"></a>Interleaved execution anomalies(异常)</h5><p><em>Read-Write conflicts</em></p>\n<p>Unrepeatable Reads </p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/Unrepeatable-Reads.png\" alt=\"Unrepeatable-Reads\"></p>\n<p>Reading Uncommitted Data (“Dirty Reads”)</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/Reading-Uncommitted-Data.png\" alt=\"Reading-Uncommitted-Data\"></p>\n<p>Overwriting Uncommitted Data</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/Overwriting-Uncommitted-Data.png\" alt=\"Overwriting-Uncommitted-Data\"></p>\n<h5 id=\"Formal-properties-of-schedules\"><a href=\"#Formal-properties-of-schedules\" class=\"headerlink\" title=\"Formal properties of schedules\"></a>Formal properties of schedules</h5><p>Given these conflicts, we now can understand what it means for a schedule to be serializable.</p>\n<ul>\n<li>This is to check whether schedules are correct.</li>\n<li>This is not how to generate a correct schedule.</li>\n</ul>\n<p>There are different levels of serializability:</p>\n<ul>\n<li>Conflict Serializability - Most DBMSs try to support this.</li>\n<li>View Serializability - No DBMS can do this.</li>\n</ul>\n<h5 id=\"Conflict-serializability-intuition\"><a href=\"#Conflict-serializability-intuition\" class=\"headerlink\" title=\"Conflict serializability intuition\"></a>Conflict serializability intuition</h5><p>Schedule S is conflict serializable if you are able to transform S into a serial schedule by swapping consecutive(连续不断的) non-conflicting operations of different transactions.</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-1.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-1\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-2.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-2\"><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-3.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-3\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-4.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-4\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-5.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-5\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-6.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-6\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-7.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-7\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-8.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-8\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-9.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-9\"></p>\n<h5 id=\"Serializability\"><a href=\"#Serializability\" class=\"headerlink\" title=\"Serializability\"></a>Serializability</h5><p>Swapping operations is easy when there are only two tens in the schedule. It’s cumbersome(麻烦) when there many txns.</p>\n<h5 id=\"Dependency-graphs\"><a href=\"#Dependency-graphs\" class=\"headerlink\" title=\"Dependency graphs\"></a>Dependency graphs</h5><p>One node per txn</p>\n<p>Edge from Ti to Tj if:</p>\n<ul>\n<li>And operation Oi of Ti conflicts with an operation Oj of Tj </li>\n<li>Oi appears earlier in the schedule than Oj</li>\n</ul>\n<p>Also known as a precedence(优先) graph</p>\n<p>A schedule is conflict serializable if its dependency graph is acyclic(无环的).</p>\n<h5 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example #1\"></a>Example #1</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-1.png\" alt=\"EXAMPLE-1-1\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-2.png\" alt=\"EXAMPLE-1-2\"></p>\n<h5 id=\"Example-2-Threesome\"><a href=\"#Example-2-Threesome\" class=\"headerlink\" title=\"Example #2 Threesome\"></a>Example #2 Threesome</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-1.png\" alt=\"EXAMPLE-2-1\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-2.png\" alt=\"EXAMPLE-2-2\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-3.png\" alt=\"EXAMPLE-2-3\"></p>\n<h5 id=\"Example-3-Inconsistenct-analysis\"><a href=\"#Example-3-Inconsistenct-analysis\" class=\"headerlink\" title=\"Example #3 Inconsistenct analysis\"></a>Example #3 Inconsistenct analysis</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-1.png\" alt=\"EXAMPLE-3-1\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-2.png\" alt=\"EXAMPLE-3-2\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-3.png\" alt=\"EXAMPLE-3-3\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-4.png\" alt=\"EXAMPLE-3-4\"></p>\n<h5 id=\"View-serializability\"><a href=\"#View-serializability\" class=\"headerlink\" title=\"View serializability\"></a>View serializability</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-1.png\" alt=\"VIEW-SERIALIZABILITY-1\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-2.png\" alt=\"VIEW-SERIALIZABILITY-2\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-3.png\" alt=\"VIEW-SERIALIZABILITY-3\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-4.png\" alt=\"VIEW-SERIALIZABILITY-4\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-5.png\" alt=\"VIEW-SERIALIZABILITY-5\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-6.png\" alt=\"VIEW-SERIALIZABILITY-6\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"Semester-学期-status\"><a href=\"#Semester-学期-status\" class=\"headerlink\" title=\"Semester(学期) status\"></a>Semester(学期) status</h5><p>A DBMS’s concurrency control and recovery components permeate(渗透) throughout the design of its entire architecture.</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/Status.png\" alt=\"Status\"></p>\n<h5 id=\"Motivation\"><a href=\"#Motivation\" class=\"headerlink\" title=\"Motivation\"></a>Motivation</h5><p>We both change the same record in a table at the same time.</p>\n<p>How to avoid race(竞争) condition? (Lost Updates Concurrency Control)</p>\n<p>You transfer $100 between bank accounts but there is a power failure.</p>\n<p>What is the correct database state? (Durability Recovery)</p>\n<h5 id=\"Concurrency-control-amp-recovery\"><a href=\"#Concurrency-control-amp-recovery\" class=\"headerlink\" title=\"Concurrency control &amp; recovery\"></a>Concurrency control &amp; recovery</h5><p>Valuable properties of DBMSs (DBMS的重要特性)</p>\n<p>Based on concept of transactions with ACID properties.</p>\n<h5 id=\"Transactions\"><a href=\"#Transactions\" class=\"headerlink\" title=\"Transactions\"></a>Transactions</h5><p>A transaction is the execution of a sequence of one or more operations (e.g., SQL queries) on a shared database to perform some higher-level function.</p>\n<p>It is the basic unit of change in DBMS</p>\n<p><strong>Example</strong></p>\n<p>Move $100 from Andy’ bank account to his bookie’s account.</p>\n<p>Transaction:</p>\n<ul>\n<li><p>Check whether Andy has $100.</p>\n</li>\n<li><p>Deduct $100 from his account.</p>\n</li>\n<li><p>Add $100 to his bookie’s account.</p>\n</li>\n</ul>\n<h5 id=\"Strawman-System\"><a href=\"#Strawman-System\" class=\"headerlink\" title=\"Strawman System\"></a>Strawman System</h5><p>Execute each txn one-by-one(i.e., serial order) as they arrive at the DBMS.</p>\n<ul>\n<li>One and only one txn can be running at the same time in the DBMS.</li>\n</ul>\n<p>Before a txn starts, copy the entire database to a new file and make all changes to that file.</p>\n<ul>\n<li>If the txn completes successfully, overwrite the original file with the new one.</li>\n<li>If the txn fails, just remove the dirty copy.</li>\n</ul>\n<h5 id=\"Definitions\"><a href=\"#Definitions\" class=\"headerlink\" title=\"Definitions\"></a>Definitions</h5><p>A txn may carry out many operations on the data retrieved from the database</p>\n<p>However, the DBMS is only concerned about what data is read/written from/to the database.</p>\n<ul>\n<li>Changes to the “outside world” are beyond the scope of the DBMS.</li>\n</ul>\n<h5 id=\"Formal-Definitions\"><a href=\"#Formal-Definitions\" class=\"headerlink\" title=\"Formal Definitions\"></a>Formal Definitions</h5><p>Database: A fixed set of named data objects(e.g., A,B,C,…)</p>\n<ul>\n<li>We do not need to define what these objects are now</li>\n</ul>\n<p>Transaction: A sequence of read and write operations(R(A), W(B), …)</p>\n<ul>\n<li>DBMS’s abstract view of a user program</li>\n</ul>\n<h5 id=\"Transactions-in-SQL\"><a href=\"#Transactions-in-SQL\" class=\"headerlink\" title=\"Transactions in SQL\"></a>Transactions in SQL</h5><p>A new txn starts with the BEGIN command.</p>\n<p>The txn stops with either COMMIT or ABORT:</p>\n<ul>\n<li>If commit, all changes are saved.</li>\n<li>If abort, all changes are undone so that it’s like as if the txn never executed at all.</li>\n<li>Abort can be either self-inflicted or caused by the DBMS.</li>\n</ul>\n<h5 id=\"Correnctness-criteria-ACID\"><a href=\"#Correnctness-criteria-ACID\" class=\"headerlink\" title=\"Correnctness criteria: ACID\"></a>Correnctness criteria: ACID</h5><p><strong>Atomicity:</strong> All actions in the txn happen, or none happen.</p>\n<p><strong>Consistency:</strong> If each txn is consistent and the DB starts consistent, then it ends up consistent.</p>\n<p><strong>Isolation:</strong> Execution of one txn is isolated from that of other txns.</p>\n<p><strong>Durability:</strong> If a txn commits, its effects persist.</p>\n<h5 id=\"Atomicity-of-transactions\"><a href=\"#Atomicity-of-transactions\" class=\"headerlink\" title=\"Atomicity of transactions\"></a>Atomicity of transactions</h5><p>Two possible outcomes of executing a txn:</p>\n<ul>\n<li>Commit after completing all its actions.</li>\n<li>Abort(or be aborted by the DBMS) after executing some actions.</li>\n</ul>\n<p>DBMS guarantees that txns are atomic.</p>\n<ul>\n<li>From user’s point of view: txn always either executes all its actions, or executes no actions at all.</li>\n</ul>\n<p>We take $100 out of Andy’s account but then there is a power failure before we transfer it to his bookie.</p>\n<p><em>When the database comes back on-line, what should be the correct state of Andy’s account?</em></p>\n<h5 id=\"Mechanisms-机制-for-ensuring-atomicity\"><a href=\"#Mechanisms-机制-for-ensuring-atomicity\" class=\"headerlink\" title=\"Mechanisms(机制) for ensuring atomicity\"></a>Mechanisms(机制) for ensuring atomicity</h5><p><strong>Approach #1: Logging</strong></p>\n<ul>\n<li>DBMS logs all actions so that it can undo the actions of aborted transactions.</li>\n<li>Think of the like the black box in airplanes…</li>\n</ul>\n<p>Logging used by all modern systems.</p>\n<ul>\n<li>Audit Trail(审计跟踪) &amp; Efficiency Reasons</li>\n</ul>\n<p><strong>Approach #2: Shadow Paging</strong></p>\n<ul>\n<li>DBMS makes copies of pages and txns make changes to those copies. Only when the txn commits it the page made visible to others.</li>\n<li>Originally from System R.</li>\n</ul>\n<p>Few systems do this:</p>\n<ul>\n<li>CouchDB</li>\n<li>LMDB(OpenLDAP)</li>\n</ul>\n<h5 id=\"Consistency\"><a href=\"#Consistency\" class=\"headerlink\" title=\"Consistency\"></a>Consistency</h5><p>The “world” represented by the database is logically correct. All questions asked about the data are given logically correct answers.</p>\n<h5 id=\"Database-consistency\"><a href=\"#Database-consistency\" class=\"headerlink\" title=\"Database consistency\"></a>Database consistency</h5><p>The database accurately models the real world and follows integrity(完整性) constraints.</p>\n<p>Transactions in the future see the effects of transactions committed in the past inside of the database.</p>\n<h5 id=\"Transaction-consistency\"><a href=\"#Transaction-consistency\" class=\"headerlink\" title=\"Transaction consistency\"></a>Transaction consistency</h5><p>If the database is consistent before the transaction starts(running alone), it will also be consistent after.</p>\n<p>Transaction consistency is the application’s responsibility.</p>\n<h5 id=\"Isolatin-of-transactions\"><a href=\"#Isolatin-of-transactions\" class=\"headerlink\" title=\"Isolatin of transactions\"></a>Isolatin of transactions</h5><p>Users submit txns, and each txn executes as if it was running by itself.</p>\n<p>Concurrency is achieved by DBMS, which interleaves(交错) actions (reads/writes of DB objects) of various transactions.</p>\n<h5 id=\"Mechanisms-机制-for-ensuring-isolation\"><a href=\"#Mechanisms-机制-for-ensuring-isolation\" class=\"headerlink\" title=\"Mechanisms(机制) for ensuring isolation\"></a>Mechanisms(机制) for ensuring isolation</h5><p>A concurrency control protocol is how the DBMS decides the proper interleaving of operations from multiple transactions.</p>\n<p>Two categories of protocols:</p>\n<p><strong>Pessimistic:</strong> Don’t let problems arise in the first place.</p>\n<p><strong>Optimistic: </strong>Assume conflicts are rare, deal with them after they happen.</p>\n<h5 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example<img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/Exmple.png\" alt=\"Exmple\"></h5><p>Assume at first A and B each have $1000.</p>\n<p>T1 transfers $100 from A’s account to B’s </p>\n<p>T2 credits both accounts with 6% interest.</p>\n<p><em>What are the possible outcomes of running T1 and T2?</em></p>\n<p>Many! But A+B should be:</p>\n<ul>\n<li>$2000 * 1.06 = 2120$</li>\n</ul>\n<p>There is no guarantee that T1 will execute before T2 or vice-versa(反之亦然), if both are submitted together. But, the net effect must be equivalent to these two transactions running serially(连续的) in some order.</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/SERIAL-EXECUTION-EXAMPLE.png\" alt=\"SERIAL-EXECUTION-EXAMPLE\"></p>\n<h5 id=\"Interleaving-transactions\"><a href=\"#Interleaving-transactions\" class=\"headerlink\" title=\"Interleaving transactions\"></a>Interleaving transactions</h5><p>We interleave txns to maximize concurrency.</p>\n<ul>\n<li>Slow disk/network I/O.</li>\n<li>Multi-core CPUs.</li>\n</ul>\n<p>When one txn stalls(暂停) because of a resource (e.g., page fault), another txn  </p>\n<p>can continue executing and make forward progress.</p>\n<h5 id=\"Interleaving-example-GOOD\"><a href=\"#Interleaving-example-GOOD\" class=\"headerlink\" title=\"Interleaving example(GOOD)\"></a>Interleaving example(GOOD)</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD\" alt=\"INTERLEAVING-EXAMPLE-(GOOD)-1\">-1.png)</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD\" alt=\"INTERLEAVING-EXAMPLE-(GOOD)-2\">-2.png)</p>\n<h5 id=\"Interleaving-example-BAD\"><a href=\"#Interleaving-example-BAD\" class=\"headerlink\" title=\"Interleaving example(BAD)\"></a>Interleaving example(BAD)</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD\" alt=\"INTERLEAVING-EXAMPLE-(BAD)-1\">-1.png)</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD\" alt=\"INTERLEAVING-EXAMPLE-(BAD)-2\">-2.png)</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD\" alt=\"INTERLEAVING-EXAMPLE-(BAD)-3\">-3.png)</p>\n<p>Tips：2014算错了 应该为 A=954, B=1160, A+B = 2114</p>\n<h5 id=\"Correctness\"><a href=\"#Correctness\" class=\"headerlink\" title=\"Correctness\"></a>Correctness</h5><p><em>How do we judge whether a schedule is correct?</em></p>\n<p>If the schedule is equivalent to some serial execution.</p>\n<h5 id=\"Formal-正式的-properties-of-schedules\"><a href=\"#Formal-正式的-properties-of-schedules\" class=\"headerlink\" title=\"Formal(正式的) properties of schedules\"></a>Formal(正式的) properties of schedules</h5><p><strong>Serial Schedule</strong></p>\n<ul>\n<li>A schedule that does not interleave the actions of different transactions.</li>\n</ul>\n<p><strong>Equivalent Schedules</strong></p>\n<ul>\n<li>For any database state, the effect of executing the first schedule is identical to the effect of executing the second schedule.</li>\n<li>Doesn’t matter what the arithmetic operations are!</li>\n</ul>\n<h5 id=\"Serializable-可串行化的-Schedule\"><a href=\"#Serializable-可串行化的-Schedule\" class=\"headerlink\" title=\"Serializable(可串行化的) Schedule\"></a>Serializable(可串行化的) Schedule</h5><ul>\n<li>A schedule that is equivalent to some serial execution of the transactions.</li>\n</ul>\n<p>If each transaction preserves consistency, every serializable schedule preserves consistency.</p>\n<p>Serializability is a less intuitive(直观) notion(概念) of correctness compared to txn initiation time or commit order, but it provides the DBMS with additional flexibility in scheduling operations.</p>\n<p>More flexibility means better parallelism.</p>\n<h5 id=\"Conflicting-operations\"><a href=\"#Conflicting-operations\" class=\"headerlink\" title=\"Conflicting operations\"></a>Conflicting operations</h5><p>We need a formal notion of equivalence that can be implemented efficiently based on the notion of “conflicting” operations.</p>\n<p>Two operations conflict if:</p>\n<ul>\n<li>They are by different transactions</li>\n<li>They are on the same object and at least one of them is a write.</li>\n</ul>\n<h5 id=\"Interleaved-execution-anomalies-异常\"><a href=\"#Interleaved-execution-anomalies-异常\" class=\"headerlink\" title=\"Interleaved execution anomalies(异常)\"></a>Interleaved execution anomalies(异常)</h5><p><em>Read-Write conflicts</em></p>\n<p>Unrepeatable Reads </p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/Unrepeatable-Reads.png\" alt=\"Unrepeatable-Reads\"></p>\n<p>Reading Uncommitted Data (“Dirty Reads”)</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/Reading-Uncommitted-Data.png\" alt=\"Reading-Uncommitted-Data\"></p>\n<p>Overwriting Uncommitted Data</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/Overwriting-Uncommitted-Data.png\" alt=\"Overwriting-Uncommitted-Data\"></p>\n<h5 id=\"Formal-properties-of-schedules\"><a href=\"#Formal-properties-of-schedules\" class=\"headerlink\" title=\"Formal properties of schedules\"></a>Formal properties of schedules</h5><p>Given these conflicts, we now can understand what it means for a schedule to be serializable.</p>\n<ul>\n<li>This is to check whether schedules are correct.</li>\n<li>This is not how to generate a correct schedule.</li>\n</ul>\n<p>There are different levels of serializability:</p>\n<ul>\n<li>Conflict Serializability - Most DBMSs try to support this.</li>\n<li>View Serializability - No DBMS can do this.</li>\n</ul>\n<h5 id=\"Conflict-serializability-intuition\"><a href=\"#Conflict-serializability-intuition\" class=\"headerlink\" title=\"Conflict serializability intuition\"></a>Conflict serializability intuition</h5><p>Schedule S is conflict serializable if you are able to transform S into a serial schedule by swapping consecutive(连续不断的) non-conflicting operations of different transactions.</p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-1.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-1\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-2.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-2\"><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-3.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-3\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-4.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-4\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-5.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-5\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-6.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-6\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-7.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-7\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-8.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-8\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-9.png\" alt=\"CONFLICT-SERIALIZABILITY-INTUITION-9\"></p>\n<h5 id=\"Serializability\"><a href=\"#Serializability\" class=\"headerlink\" title=\"Serializability\"></a>Serializability</h5><p>Swapping operations is easy when there are only two tens in the schedule. It’s cumbersome(麻烦) when there many txns.</p>\n<h5 id=\"Dependency-graphs\"><a href=\"#Dependency-graphs\" class=\"headerlink\" title=\"Dependency graphs\"></a>Dependency graphs</h5><p>One node per txn</p>\n<p>Edge from Ti to Tj if:</p>\n<ul>\n<li>And operation Oi of Ti conflicts with an operation Oj of Tj </li>\n<li>Oi appears earlier in the schedule than Oj</li>\n</ul>\n<p>Also known as a precedence(优先) graph</p>\n<p>A schedule is conflict serializable if its dependency graph is acyclic(无环的).</p>\n<h5 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example #1\"></a>Example #1</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-1.png\" alt=\"EXAMPLE-1-1\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-2.png\" alt=\"EXAMPLE-1-2\"></p>\n<h5 id=\"Example-2-Threesome\"><a href=\"#Example-2-Threesome\" class=\"headerlink\" title=\"Example #2 Threesome\"></a>Example #2 Threesome</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-1.png\" alt=\"EXAMPLE-2-1\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-2.png\" alt=\"EXAMPLE-2-2\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-3.png\" alt=\"EXAMPLE-2-3\"></p>\n<h5 id=\"Example-3-Inconsistenct-analysis\"><a href=\"#Example-3-Inconsistenct-analysis\" class=\"headerlink\" title=\"Example #3 Inconsistenct analysis\"></a>Example #3 Inconsistenct analysis</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-1.png\" alt=\"EXAMPLE-3-1\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-2.png\" alt=\"EXAMPLE-3-2\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-3.png\" alt=\"EXAMPLE-3-3\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-4.png\" alt=\"EXAMPLE-3-4\"></p>\n<h5 id=\"View-serializability\"><a href=\"#View-serializability\" class=\"headerlink\" title=\"View serializability\"></a>View serializability</h5><p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-1.png\" alt=\"VIEW-SERIALIZABILITY-1\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-2.png\" alt=\"VIEW-SERIALIZABILITY-2\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-3.png\" alt=\"VIEW-SERIALIZABILITY-3\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-4.png\" alt=\"VIEW-SERIALIZABILITY-4\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-5.png\" alt=\"VIEW-SERIALIZABILITY-5\"></p>\n<p><img src=\"/2019/06/19/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-6.png\" alt=\"VIEW-SERIALIZABILITY-6\"></p>\n"},{"title":"CMU-DBMS-COURSE-17-NOTES","date":"2019-06-19T15:47:41.000Z","_content":"","source":"_posts/CMU-DBMS-COURSE-17-NOTES.md","raw":"---\ntitle: CMU-DBMS-COURSE-17-NOTES\ndate: 2019-06-19 23:47:41\ntags:\n---\n","slug":"CMU-DBMS-COURSE-17-NOTES","published":1,"updated":"2019-06-26T11:56:34.572Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyns000nvkqpg44xfks3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Google-Spanner-Paper","date":"2019-06-09T23:57:01.000Z","_content":"\n**Spanner: Google's Globally Distributed Database**\n\nJAMES C.CORBETT, JEFFREY DEAN, MICHAEL EPSTEIN, ANDREW FIKES, CHRISTOPHER FROST,  J. J. FURMAN, SANJAY GHEMAWAT, ANDREY GUBAREV, CHRISTOPHER HEISER, PETER HOCHSCHILD, WILSON HSIEH, SEBASTIAN KANTHAK, EUGENE KOGAN, HONGYI LI, ALEXANDER LLOYD, SERGEY MELNIK, DAVID MWAURA, DAVID NAGLE, SEAN QUINLAN, RAJESH RAO, LINDSAY ROLIG, YASUSHI SAITO, MICHAL SZYMANIAK, CHRISTOPHER TAYLOR, RUTH WANG, and DALE WOODFORD, Google, Inc.\n\nSpanner is Google's scalable, multiversion(多版本), globally distributed, and synchronously replicated database. It is the first system to distribute data at global scale and support externally-consistent distributed transactions. This article describes how Spanner is structured, its feature set, the rationale(理论基础) underlying various design to supporting external consistency and a variety of powerful features: nonblocking reads in the past, lock-free snapshot, and atomic shcema changes, across all of Spanner.\n\nCategories and Subject Descriptors. H.2.4 [Database Management]：Systems-Concurrency, distributed databases, transaction processing\n\nGeneral Terms: Design, Algorithms, Performance\n\nAdditional Ket Words and Phrases: Distributed databases, concurrency control, replication, transactoins, time management\n\n**ACM Reference Format:** \n\nCorbett, J. C., Dean, J., Epstein, M., Fikes, A., Frost, C., Furman, J. J., Ghemawat, S., Gubarev, A., Heiser, C., Hochschild, P., Hsieh, W., Kanthak, S., Kogan, E., Li, H., Lloyd, A., Melnik, S., Mwaura, D., Nagle, D., Quinlan, S., Rao, R., Rolig, L., Saito, Y., Szymaniak, M., Taylor, C., Wang, R., and Woodford, D. 2013. Spanner: Google’s globally distributed database. ACM Trans. Comput. Syst. 31, 3, Article 8 (August 2013), 22 pages.\n\nDOI:http://dx.doi.org/10.1145/2491245\n\n","source":"_posts/Google-Spanner-Paper.md","raw":"---\ntitle: Google-Spanner-Paper\ndate: 2019-06-10 07:57:01\ntags:\n---\n\n**Spanner: Google's Globally Distributed Database**\n\nJAMES C.CORBETT, JEFFREY DEAN, MICHAEL EPSTEIN, ANDREW FIKES, CHRISTOPHER FROST,  J. J. FURMAN, SANJAY GHEMAWAT, ANDREY GUBAREV, CHRISTOPHER HEISER, PETER HOCHSCHILD, WILSON HSIEH, SEBASTIAN KANTHAK, EUGENE KOGAN, HONGYI LI, ALEXANDER LLOYD, SERGEY MELNIK, DAVID MWAURA, DAVID NAGLE, SEAN QUINLAN, RAJESH RAO, LINDSAY ROLIG, YASUSHI SAITO, MICHAL SZYMANIAK, CHRISTOPHER TAYLOR, RUTH WANG, and DALE WOODFORD, Google, Inc.\n\nSpanner is Google's scalable, multiversion(多版本), globally distributed, and synchronously replicated database. It is the first system to distribute data at global scale and support externally-consistent distributed transactions. This article describes how Spanner is structured, its feature set, the rationale(理论基础) underlying various design to supporting external consistency and a variety of powerful features: nonblocking reads in the past, lock-free snapshot, and atomic shcema changes, across all of Spanner.\n\nCategories and Subject Descriptors. H.2.4 [Database Management]：Systems-Concurrency, distributed databases, transaction processing\n\nGeneral Terms: Design, Algorithms, Performance\n\nAdditional Ket Words and Phrases: Distributed databases, concurrency control, replication, transactoins, time management\n\n**ACM Reference Format:** \n\nCorbett, J. C., Dean, J., Epstein, M., Fikes, A., Frost, C., Furman, J. J., Ghemawat, S., Gubarev, A., Heiser, C., Hochschild, P., Hsieh, W., Kanthak, S., Kogan, E., Li, H., Lloyd, A., Melnik, S., Mwaura, D., Nagle, D., Quinlan, S., Rao, R., Rolig, L., Saito, Y., Szymaniak, M., Taylor, C., Wang, R., and Woodford, D. 2013. Spanner: Google’s globally distributed database. ACM Trans. Comput. Syst. 31, 3, Article 8 (August 2013), 22 pages.\n\nDOI:http://dx.doi.org/10.1145/2491245\n\n","slug":"Google-Spanner-Paper","published":1,"updated":"2019-06-26T11:56:34.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvynu000pvkqpakyzbrtw","content":"<p><strong>Spanner: Google’s Globally Distributed Database</strong></p>\n<p>JAMES C.CORBETT, JEFFREY DEAN, MICHAEL EPSTEIN, ANDREW FIKES, CHRISTOPHER FROST,  J. J. FURMAN, SANJAY GHEMAWAT, ANDREY GUBAREV, CHRISTOPHER HEISER, PETER HOCHSCHILD, WILSON HSIEH, SEBASTIAN KANTHAK, EUGENE KOGAN, HONGYI LI, ALEXANDER LLOYD, SERGEY MELNIK, DAVID MWAURA, DAVID NAGLE, SEAN QUINLAN, RAJESH RAO, LINDSAY ROLIG, YASUSHI SAITO, MICHAL SZYMANIAK, CHRISTOPHER TAYLOR, RUTH WANG, and DALE WOODFORD, Google, Inc.</p>\n<p>Spanner is Google’s scalable, multiversion(多版本), globally distributed, and synchronously replicated database. It is the first system to distribute data at global scale and support externally-consistent distributed transactions. This article describes how Spanner is structured, its feature set, the rationale(理论基础) underlying various design to supporting external consistency and a variety of powerful features: nonblocking reads in the past, lock-free snapshot, and atomic shcema changes, across all of Spanner.</p>\n<p>Categories and Subject Descriptors. H.2.4 [Database Management]：Systems-Concurrency, distributed databases, transaction processing</p>\n<p>General Terms: Design, Algorithms, Performance</p>\n<p>Additional Ket Words and Phrases: Distributed databases, concurrency control, replication, transactoins, time management</p>\n<p><strong>ACM Reference Format:</strong> </p>\n<p>Corbett, J. C., Dean, J., Epstein, M., Fikes, A., Frost, C., Furman, J. J., Ghemawat, S., Gubarev, A., Heiser, C., Hochschild, P., Hsieh, W., Kanthak, S., Kogan, E., Li, H., Lloyd, A., Melnik, S., Mwaura, D., Nagle, D., Quinlan, S., Rao, R., Rolig, L., Saito, Y., Szymaniak, M., Taylor, C., Wang, R., and Woodford, D. 2013. Spanner: Google’s globally distributed database. ACM Trans. Comput. Syst. 31, 3, Article 8 (August 2013), 22 pages.</p>\n<p>DOI:<a href=\"http://dx.doi.org/10.1145/2491245\" target=\"_blank\" rel=\"noopener\">http://dx.doi.org/10.1145/2491245</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Spanner: Google’s Globally Distributed Database</strong></p>\n<p>JAMES C.CORBETT, JEFFREY DEAN, MICHAEL EPSTEIN, ANDREW FIKES, CHRISTOPHER FROST,  J. J. FURMAN, SANJAY GHEMAWAT, ANDREY GUBAREV, CHRISTOPHER HEISER, PETER HOCHSCHILD, WILSON HSIEH, SEBASTIAN KANTHAK, EUGENE KOGAN, HONGYI LI, ALEXANDER LLOYD, SERGEY MELNIK, DAVID MWAURA, DAVID NAGLE, SEAN QUINLAN, RAJESH RAO, LINDSAY ROLIG, YASUSHI SAITO, MICHAL SZYMANIAK, CHRISTOPHER TAYLOR, RUTH WANG, and DALE WOODFORD, Google, Inc.</p>\n<p>Spanner is Google’s scalable, multiversion(多版本), globally distributed, and synchronously replicated database. It is the first system to distribute data at global scale and support externally-consistent distributed transactions. This article describes how Spanner is structured, its feature set, the rationale(理论基础) underlying various design to supporting external consistency and a variety of powerful features: nonblocking reads in the past, lock-free snapshot, and atomic shcema changes, across all of Spanner.</p>\n<p>Categories and Subject Descriptors. H.2.4 [Database Management]：Systems-Concurrency, distributed databases, transaction processing</p>\n<p>General Terms: Design, Algorithms, Performance</p>\n<p>Additional Ket Words and Phrases: Distributed databases, concurrency control, replication, transactoins, time management</p>\n<p><strong>ACM Reference Format:</strong> </p>\n<p>Corbett, J. C., Dean, J., Epstein, M., Fikes, A., Frost, C., Furman, J. J., Ghemawat, S., Gubarev, A., Heiser, C., Hochschild, P., Hsieh, W., Kanthak, S., Kogan, E., Li, H., Lloyd, A., Melnik, S., Mwaura, D., Nagle, D., Quinlan, S., Rao, R., Rolig, L., Saito, Y., Szymaniak, M., Taylor, C., Wang, R., and Woodford, D. 2013. Spanner: Google’s globally distributed database. ACM Trans. Comput. Syst. 31, 3, Article 8 (August 2013), 22 pages.</p>\n<p>DOI:<a href=\"http://dx.doi.org/10.1145/2491245\" target=\"_blank\" rel=\"noopener\">http://dx.doi.org/10.1145/2491245</a></p>\n"},{"title":"LEC1-vedio","date":"2019-01-16T14:03:56.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC1-vedio.md","raw":"---\ntitle: LEC1-vedio\ndate: 2019-01-16 22:03:56\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC1-vedio","published":1,"updated":"2019-06-26T11:56:34.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvynv000rvkqpcyclrl1v","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611827&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC1","date":"2019-01-15T15:03:03.000Z","_content":"\n**不敢确认的翻译给出了原文，避免误解**\n\n**什么是分布式系统**？\n\n1.多台主机合作\n\n2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的\n\n**为什么需要分布式**？\n\n1.连接物理上分离的实体\n\n2.通过隔离实现安全\n\n3.通过副本来实现容错\n\n4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量\n\n5.但是：\n\n1) 分布式系统具有复杂性，包括很多并发的部分\n\n2) 必须应对系统中部分部分失败\n\n3) 很难实现性能潜力\n\n**实验的目标**：\n\n1.更加深入的了解一些重要技术\n\n2.积累分布式系统的编程经验\n\n**主话题**\n\n1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用\n\n2.用来应用程序分布的复杂性\n\n1）三大抽象\n\n存储，交互，计算\n\n2）实现分布式系统的一些基础知识\n\nRPC，线程，并发控制\n\n3）分布式系统的性能\n\n**理想：可扩展的吞吐量**\n\n可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现\n\n所以可以通过购买更多的服务器来处理更多的负载\n\n**现实：扩展变得越来越困难**\n\n负载均衡，(stragglers)性能落后的机器\n\n很小的，不可以并行化的部分\n\n隐藏共享资源，比如网络\n\n分布式系统的容错性(fault tolerance)\n\n1000个服务器，复杂的网络连接，总是会出现一些问题\n我们想通过应用程序来隐藏(容忍)这些失败\n\n可用性：尽管失败，我仍然可以继续使用我的文件\n\n耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复\n\n一个好主意：使用副本服务器(replicated servers)\n\n如果一个服务宕机了，客户端可以选择使用其他的服务器\n\n**分布式系统的一致性**\n\n通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的\n\n1.客户端提交并行的操作\n2.服务器在尴尬的时候崩溃\n3.网络问题可能是服务器看起来像是死机了\n4.脑裂的风险(split brain)\n\n**一致性和性能是相对的**\n\n1.一致性需要交互\n2.具有令人满意(\"严格\")语以的系统通常很慢\n3.快速的系统通常可以使应用程序面对复杂的行为\n\n案例学习: MapReduce\n\n**MapReduce概述**\n\n1.Context: 对多个TB的数据集进行多个小时的计算\n\n例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的\n\n2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理\n\n3.程序员定义Map和Reduce函数的顺序代码，通常很简单\n\n4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节\n\n**MapReduce的抽象视图**\n\n输入(input)被分为M个文件\n\n[maps 生成多行 K-V对，reduces合并列]\n\n![MapReduce](LEC1/MapReduce.png)\n\nMR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。\n\nMR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 <k2, v3> 对，结果存储在R输出文件中\n\n[MapReduce API]\n\n![MapReduceApi](LEC1/MapReduceApi.png)\n\n**MapReduce隐藏了一些细节痛点**\n\n1.在服务器上启动 s/w\n\n2.跟踪哪些任务已经完成了\n\n3.数据移动\n\n4.任务失败后恢复\n\n**Mapreduce 具有很好的扩展性**\n\n1.用N台服务器可以获得Nx的吞吐量\n\n假设 M和R >= N （即：很多的输入文件和map输出的key）\n\nMaps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的\n\n唯一的交互是maps和reduces之间的 \"shuffle\"\n\n2.因此，你可以通过购买更多的服务器来获得更多的吞吐量\n\n而不是对每个应用程序做特殊，高效的并行化\n\n**限制性能的因素是什么？**\n\n1.我们关心这个因为这正是系统性能的优化点\nCPU? 内存? 磁盘? 网络？\n\n2.网络带宽的限制\n\n网络的内部总容量，通常远小于主机之间网络链路的速度总和\n\n难以建立一个比单台计算机运行速度快1000倍的网络\n\n所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动\n\n**容灾处理**\n\n如果有服务器在MR job过程中宕机怎么处理\n\n隐藏失败是实现模型简易编程一个大的部分\n\n为什么不从一开始就重启整个job\n\nMR过程只会重新运行失败的Map()和Reduce()\n\n它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果\n\nMR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要\n\n**更多的细节**\n\n1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片\n\n输入数据存在GFS中，每个分片存了3个副本\n\n2.所有的计算机同时运行GFS和MR workers\n\n3.输入分片数比workers数要多\n\n4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务\n\n5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘\n\n直到所有Maps操作结束后才会进行Reduce计算\n\n6.Master告诉Reducers从Map操作的workers那里获取中间数据分块\n\n7.Reduce操作的workers将最终输出结果写到GFS中\n\n**如何通过细节处的设计来提高网络性能**\n\n1.Map的输入从本地磁盘读取，不是通过网络\n\n2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS\n\n3.生成的中间数据分块保存很多的key，并存储在文件中\n\n4.大块的网络传输效率更高\n\n**如果更均衡的分配负载**\n\n1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益\n\n2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件\n\n3.解决方案：split的数多于workes数\n\nMaster将新的splits分发给已经完成先前任务的workers\n\n所以更快的服务器比慢速的服务器做更多的工作，并同时完成。\n\n**MR如何应对worker崩溃呢**\n\n1.Map worker 崩溃\n\nmaster重新运行，通过其他GFS的副本作为输入\n\n即使worker已经完成，因为我们仍需要磁盘上的中间数据\n\n一些Reduce workers可能已经督过workers的中间数据\n\n2.Master怎么知道worker崩溃了(通过 pings)\n\n如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行\n\n3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker\n\n4.Reduce worker在写输出的过程中崩溃\n\nGFS具有 atomic rename ,可以防止输出在完成之前可见\n\n5.所以master在其他的地方重新运行Reduce 任务是安全的\n\n","source":"_posts/LEC1.md","raw":"---\ntitle: LEC1\ndate: 2019-01-15 23:03:03\ntags: 分布式系统6.824笔记\n---\n\n**不敢确认的翻译给出了原文，避免误解**\n\n**什么是分布式系统**？\n\n1.多台主机合作\n\n2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的\n\n**为什么需要分布式**？\n\n1.连接物理上分离的实体\n\n2.通过隔离实现安全\n\n3.通过副本来实现容错\n\n4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量\n\n5.但是：\n\n1) 分布式系统具有复杂性，包括很多并发的部分\n\n2) 必须应对系统中部分部分失败\n\n3) 很难实现性能潜力\n\n**实验的目标**：\n\n1.更加深入的了解一些重要技术\n\n2.积累分布式系统的编程经验\n\n**主话题**\n\n1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用\n\n2.用来应用程序分布的复杂性\n\n1）三大抽象\n\n存储，交互，计算\n\n2）实现分布式系统的一些基础知识\n\nRPC，线程，并发控制\n\n3）分布式系统的性能\n\n**理想：可扩展的吞吐量**\n\n可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现\n\n所以可以通过购买更多的服务器来处理更多的负载\n\n**现实：扩展变得越来越困难**\n\n负载均衡，(stragglers)性能落后的机器\n\n很小的，不可以并行化的部分\n\n隐藏共享资源，比如网络\n\n分布式系统的容错性(fault tolerance)\n\n1000个服务器，复杂的网络连接，总是会出现一些问题\n我们想通过应用程序来隐藏(容忍)这些失败\n\n可用性：尽管失败，我仍然可以继续使用我的文件\n\n耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复\n\n一个好主意：使用副本服务器(replicated servers)\n\n如果一个服务宕机了，客户端可以选择使用其他的服务器\n\n**分布式系统的一致性**\n\n通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的\n\n1.客户端提交并行的操作\n2.服务器在尴尬的时候崩溃\n3.网络问题可能是服务器看起来像是死机了\n4.脑裂的风险(split brain)\n\n**一致性和性能是相对的**\n\n1.一致性需要交互\n2.具有令人满意(\"严格\")语以的系统通常很慢\n3.快速的系统通常可以使应用程序面对复杂的行为\n\n案例学习: MapReduce\n\n**MapReduce概述**\n\n1.Context: 对多个TB的数据集进行多个小时的计算\n\n例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的\n\n2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理\n\n3.程序员定义Map和Reduce函数的顺序代码，通常很简单\n\n4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节\n\n**MapReduce的抽象视图**\n\n输入(input)被分为M个文件\n\n[maps 生成多行 K-V对，reduces合并列]\n\n![MapReduce](LEC1/MapReduce.png)\n\nMR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。\n\nMR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 <k2, v3> 对，结果存储在R输出文件中\n\n[MapReduce API]\n\n![MapReduceApi](LEC1/MapReduceApi.png)\n\n**MapReduce隐藏了一些细节痛点**\n\n1.在服务器上启动 s/w\n\n2.跟踪哪些任务已经完成了\n\n3.数据移动\n\n4.任务失败后恢复\n\n**Mapreduce 具有很好的扩展性**\n\n1.用N台服务器可以获得Nx的吞吐量\n\n假设 M和R >= N （即：很多的输入文件和map输出的key）\n\nMaps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的\n\n唯一的交互是maps和reduces之间的 \"shuffle\"\n\n2.因此，你可以通过购买更多的服务器来获得更多的吞吐量\n\n而不是对每个应用程序做特殊，高效的并行化\n\n**限制性能的因素是什么？**\n\n1.我们关心这个因为这正是系统性能的优化点\nCPU? 内存? 磁盘? 网络？\n\n2.网络带宽的限制\n\n网络的内部总容量，通常远小于主机之间网络链路的速度总和\n\n难以建立一个比单台计算机运行速度快1000倍的网络\n\n所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动\n\n**容灾处理**\n\n如果有服务器在MR job过程中宕机怎么处理\n\n隐藏失败是实现模型简易编程一个大的部分\n\n为什么不从一开始就重启整个job\n\nMR过程只会重新运行失败的Map()和Reduce()\n\n它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果\n\nMR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要\n\n**更多的细节**\n\n1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片\n\n输入数据存在GFS中，每个分片存了3个副本\n\n2.所有的计算机同时运行GFS和MR workers\n\n3.输入分片数比workers数要多\n\n4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务\n\n5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘\n\n直到所有Maps操作结束后才会进行Reduce计算\n\n6.Master告诉Reducers从Map操作的workers那里获取中间数据分块\n\n7.Reduce操作的workers将最终输出结果写到GFS中\n\n**如何通过细节处的设计来提高网络性能**\n\n1.Map的输入从本地磁盘读取，不是通过网络\n\n2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS\n\n3.生成的中间数据分块保存很多的key，并存储在文件中\n\n4.大块的网络传输效率更高\n\n**如果更均衡的分配负载**\n\n1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益\n\n2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件\n\n3.解决方案：split的数多于workes数\n\nMaster将新的splits分发给已经完成先前任务的workers\n\n所以更快的服务器比慢速的服务器做更多的工作，并同时完成。\n\n**MR如何应对worker崩溃呢**\n\n1.Map worker 崩溃\n\nmaster重新运行，通过其他GFS的副本作为输入\n\n即使worker已经完成，因为我们仍需要磁盘上的中间数据\n\n一些Reduce workers可能已经督过workers的中间数据\n\n2.Master怎么知道worker崩溃了(通过 pings)\n\n如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行\n\n3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker\n\n4.Reduce worker在写输出的过程中崩溃\n\nGFS具有 atomic rename ,可以防止输出在完成之前可见\n\n5.所以master在其他的地方重新运行Reduce 任务是安全的\n\n","slug":"LEC1","published":1,"updated":"2019-06-26T11:56:34.573Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvynw000svkqpf1hznn8g","content":"<p><strong>不敢确认的翻译给出了原文，避免误解</strong></p>\n<p><strong>什么是分布式系统</strong>？</p>\n<p>1.多台主机合作</p>\n<p>2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的</p>\n<p><strong>为什么需要分布式</strong>？</p>\n<p>1.连接物理上分离的实体</p>\n<p>2.通过隔离实现安全</p>\n<p>3.通过副本来实现容错</p>\n<p>4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量</p>\n<p>5.但是：</p>\n<p>1) 分布式系统具有复杂性，包括很多并发的部分</p>\n<p>2) 必须应对系统中部分部分失败</p>\n<p>3) 很难实现性能潜力</p>\n<p><strong>实验的目标</strong>：</p>\n<p>1.更加深入的了解一些重要技术</p>\n<p>2.积累分布式系统的编程经验</p>\n<p><strong>主话题</strong></p>\n<p>1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用</p>\n<p>2.用来应用程序分布的复杂性</p>\n<p>1）三大抽象</p>\n<p>存储，交互，计算</p>\n<p>2）实现分布式系统的一些基础知识</p>\n<p>RPC，线程，并发控制</p>\n<p>3）分布式系统的性能</p>\n<p><strong>理想：可扩展的吞吐量</strong></p>\n<p>可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现</p>\n<p>所以可以通过购买更多的服务器来处理更多的负载</p>\n<p><strong>现实：扩展变得越来越困难</strong></p>\n<p>负载均衡，(stragglers)性能落后的机器</p>\n<p>很小的，不可以并行化的部分</p>\n<p>隐藏共享资源，比如网络</p>\n<p>分布式系统的容错性(fault tolerance)</p>\n<p>1000个服务器，复杂的网络连接，总是会出现一些问题<br>我们想通过应用程序来隐藏(容忍)这些失败</p>\n<p>可用性：尽管失败，我仍然可以继续使用我的文件</p>\n<p>耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复</p>\n<p>一个好主意：使用副本服务器(replicated servers)</p>\n<p>如果一个服务宕机了，客户端可以选择使用其他的服务器</p>\n<p><strong>分布式系统的一致性</strong></p>\n<p>通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的</p>\n<p>1.客户端提交并行的操作<br>2.服务器在尴尬的时候崩溃<br>3.网络问题可能是服务器看起来像是死机了<br>4.脑裂的风险(split brain)</p>\n<p><strong>一致性和性能是相对的</strong></p>\n<p>1.一致性需要交互<br>2.具有令人满意(“严格”)语以的系统通常很慢<br>3.快速的系统通常可以使应用程序面对复杂的行为</p>\n<p>案例学习: MapReduce</p>\n<p><strong>MapReduce概述</strong></p>\n<p>1.Context: 对多个TB的数据集进行多个小时的计算</p>\n<p>例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的</p>\n<p>2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理</p>\n<p>3.程序员定义Map和Reduce函数的顺序代码，通常很简单</p>\n<p>4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节</p>\n<p><strong>MapReduce的抽象视图</strong></p>\n<p>输入(input)被分为M个文件</p>\n<p>[maps 生成多行 K-V对，reduces合并列]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduce.png\" alt=\"MapReduce\"></p>\n<p>MR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。</p>\n<p>MR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 &lt;k2, v3&gt; 对，结果存储在R输出文件中</p>\n<p>[MapReduce API]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduceApi.png\" alt=\"MapReduceApi\"></p>\n<p><strong>MapReduce隐藏了一些细节痛点</strong></p>\n<p>1.在服务器上启动 s/w</p>\n<p>2.跟踪哪些任务已经完成了</p>\n<p>3.数据移动</p>\n<p>4.任务失败后恢复</p>\n<p><strong>Mapreduce 具有很好的扩展性</strong></p>\n<p>1.用N台服务器可以获得Nx的吞吐量</p>\n<p>假设 M和R &gt;= N （即：很多的输入文件和map输出的key）</p>\n<p>Maps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的</p>\n<p>唯一的交互是maps和reduces之间的 “shuffle”</p>\n<p>2.因此，你可以通过购买更多的服务器来获得更多的吞吐量</p>\n<p>而不是对每个应用程序做特殊，高效的并行化</p>\n<p><strong>限制性能的因素是什么？</strong></p>\n<p>1.我们关心这个因为这正是系统性能的优化点<br>CPU? 内存? 磁盘? 网络？</p>\n<p>2.网络带宽的限制</p>\n<p>网络的内部总容量，通常远小于主机之间网络链路的速度总和</p>\n<p>难以建立一个比单台计算机运行速度快1000倍的网络</p>\n<p>所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动</p>\n<p><strong>容灾处理</strong></p>\n<p>如果有服务器在MR job过程中宕机怎么处理</p>\n<p>隐藏失败是实现模型简易编程一个大的部分</p>\n<p>为什么不从一开始就重启整个job</p>\n<p>MR过程只会重新运行失败的Map()和Reduce()</p>\n<p>它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果</p>\n<p>MR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要</p>\n<p><strong>更多的细节</strong></p>\n<p>1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片</p>\n<p>输入数据存在GFS中，每个分片存了3个副本</p>\n<p>2.所有的计算机同时运行GFS和MR workers</p>\n<p>3.输入分片数比workers数要多</p>\n<p>4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务</p>\n<p>5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘</p>\n<p>直到所有Maps操作结束后才会进行Reduce计算</p>\n<p>6.Master告诉Reducers从Map操作的workers那里获取中间数据分块</p>\n<p>7.Reduce操作的workers将最终输出结果写到GFS中</p>\n<p><strong>如何通过细节处的设计来提高网络性能</strong></p>\n<p>1.Map的输入从本地磁盘读取，不是通过网络</p>\n<p>2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS</p>\n<p>3.生成的中间数据分块保存很多的key，并存储在文件中</p>\n<p>4.大块的网络传输效率更高</p>\n<p><strong>如果更均衡的分配负载</strong></p>\n<p>1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益</p>\n<p>2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件</p>\n<p>3.解决方案：split的数多于workes数</p>\n<p>Master将新的splits分发给已经完成先前任务的workers</p>\n<p>所以更快的服务器比慢速的服务器做更多的工作，并同时完成。</p>\n<p><strong>MR如何应对worker崩溃呢</strong></p>\n<p>1.Map worker 崩溃</p>\n<p>master重新运行，通过其他GFS的副本作为输入</p>\n<p>即使worker已经完成，因为我们仍需要磁盘上的中间数据</p>\n<p>一些Reduce workers可能已经督过workers的中间数据</p>\n<p>2.Master怎么知道worker崩溃了(通过 pings)</p>\n<p>如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行</p>\n<p>3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker</p>\n<p>4.Reduce worker在写输出的过程中崩溃</p>\n<p>GFS具有 atomic rename ,可以防止输出在完成之前可见</p>\n<p>5.所以master在其他的地方重新运行Reduce 任务是安全的</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>不敢确认的翻译给出了原文，避免误解</strong></p>\n<p><strong>什么是分布式系统</strong>？</p>\n<p>1.多台主机合作</p>\n<p>2.DNS，P2P文件共享，存储大数据的数据库，MapReduce模型，大量基础设施都是分布式的</p>\n<p><strong>为什么需要分布式</strong>？</p>\n<p>1.连接物理上分离的实体</p>\n<p>2.通过隔离实现安全</p>\n<p>3.通过副本来实现容错</p>\n<p>4.通过并行CPU/mem/disk/net 来扩展系统的吞吐量</p>\n<p>5.但是：</p>\n<p>1) 分布式系统具有复杂性，包括很多并发的部分</p>\n<p>2) 必须应对系统中部分部分失败</p>\n<p>3) 很难实现性能潜力</p>\n<p><strong>实验的目标</strong>：</p>\n<p>1.更加深入的了解一些重要技术</p>\n<p>2.积累分布式系统的编程经验</p>\n<p><strong>主话题</strong></p>\n<p>1.这是一门关于基础设施的课程，这些分布式的基础设施架设起来以供应用使用</p>\n<p>2.用来应用程序分布的复杂性</p>\n<p>1）三大抽象</p>\n<p>存储，交互，计算</p>\n<p>2）实现分布式系统的一些基础知识</p>\n<p>RPC，线程，并发控制</p>\n<p>3）分布式系统的性能</p>\n<p><strong>理想：可扩展的吞吐量</strong></p>\n<p>可扩展的吞吐量-Nx的服务器数量，Nx的总吞吐量，通过CPU/Disk/Net并行实现</p>\n<p>所以可以通过购买更多的服务器来处理更多的负载</p>\n<p><strong>现实：扩展变得越来越困难</strong></p>\n<p>负载均衡，(stragglers)性能落后的机器</p>\n<p>很小的，不可以并行化的部分</p>\n<p>隐藏共享资源，比如网络</p>\n<p>分布式系统的容错性(fault tolerance)</p>\n<p>1000个服务器，复杂的网络连接，总是会出现一些问题<br>我们想通过应用程序来隐藏(容忍)这些失败</p>\n<p>可用性：尽管失败，我仍然可以继续使用我的文件</p>\n<p>耐用性(Durability)：当故障机器得到修复时，我的数据可以被恢复</p>\n<p>一个好主意：使用副本服务器(replicated servers)</p>\n<p>如果一个服务宕机了，客户端可以选择使用其他的服务器</p>\n<p><strong>分布式系统的一致性</strong></p>\n<p>通用的基础架构需要明确定义的behavior，实现良好的behavior是困难的</p>\n<p>1.客户端提交并行的操作<br>2.服务器在尴尬的时候崩溃<br>3.网络问题可能是服务器看起来像是死机了<br>4.脑裂的风险(split brain)</p>\n<p><strong>一致性和性能是相对的</strong></p>\n<p>1.一致性需要交互<br>2.具有令人满意(“严格”)语以的系统通常很慢<br>3.快速的系统通常可以使应用程序面对复杂的行为</p>\n<p>案例学习: MapReduce</p>\n<p><strong>MapReduce概述</strong></p>\n<p>1.Context: 对多个TB的数据集进行多个小时的计算</p>\n<p>例如：分析分布在1000多台计算机上的大量图结构的数据，如果不是分布式系统专家来开发是很痛苦的</p>\n<p>2.模型目标：非专业程序员可以地在许多服务器上以合理的效率分割数据集并处理</p>\n<p>3.程序员定义Map和Reduce函数的顺序代码，通常很简单</p>\n<p>4.MapReduce在具有巨大输入的1000台服务器上运行函数并隐藏了分发处理的细节</p>\n<p><strong>MapReduce的抽象视图</strong></p>\n<p>输入(input)被分为M个文件</p>\n<p>[maps 生成多行 K-V对，reduces合并列]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduce.png\" alt=\"MapReduce\"></p>\n<p>MR（MapReduce简称）为每个输入文件调用Map()，产生一组 k2, v2 的中间顺序，每个Map() 调用是一个任务。</p>\n<p>MR为给定的k2收集所有中间v2，并将它们传递给Reduce调用最终输入设置为来自Reduce() 的 &lt;k2, v3&gt; 对，结果存储在R输出文件中</p>\n<p>[MapReduce API]</p>\n<p><img src=\"/2019/01/15/LEC1/MapReduceApi.png\" alt=\"MapReduceApi\"></p>\n<p><strong>MapReduce隐藏了一些细节痛点</strong></p>\n<p>1.在服务器上启动 s/w</p>\n<p>2.跟踪哪些任务已经完成了</p>\n<p>3.数据移动</p>\n<p>4.任务失败后恢复</p>\n<p><strong>Mapreduce 具有很好的扩展性</strong></p>\n<p>1.用N台服务器可以获得Nx的吞吐量</p>\n<p>假设 M和R &gt;= N （即：很多的输入文件和map输出的key）</p>\n<p>Maps()s可以并行的运行，因为它们之间没有交互，Reduce()s 也是同样的</p>\n<p>唯一的交互是maps和reduces之间的 “shuffle”</p>\n<p>2.因此，你可以通过购买更多的服务器来获得更多的吞吐量</p>\n<p>而不是对每个应用程序做特殊，高效的并行化</p>\n<p><strong>限制性能的因素是什么？</strong></p>\n<p>1.我们关心这个因为这正是系统性能的优化点<br>CPU? 内存? 磁盘? 网络？</p>\n<p>2.网络带宽的限制</p>\n<p>网络的内部总容量，通常远小于主机之间网络链路的速度总和</p>\n<p>难以建立一个比单台计算机运行速度快1000倍的网络</p>\n<p>所以分布式系统的设计者关心的是最大限度的减少网络上的数据移动</p>\n<p><strong>容灾处理</strong></p>\n<p>如果有服务器在MR job过程中宕机怎么处理</p>\n<p>隐藏失败是实现模型简易编程一个大的部分</p>\n<p>为什么不从一开始就重启整个job</p>\n<p>MR过程只会重新运行失败的Map()和Reduce()</p>\n<p>它们是pure fuctions,不会修改它们的输入，不保存状态，它们之间不共享内存，没有map/map 或者 reduce/reduce 之间的交互，所以重新执行会有相同的输出结果</p>\n<p>MR与其他的并行编程方案相比，pure fuctions是一个主要的限制，但这对MR编程模型的简单性至关重要</p>\n<p><strong>更多的细节</strong></p>\n<p>1.Master：给所有的worker分配任务，记住中间输出结果是M输入的分片</p>\n<p>输入数据存在GFS中，每个分片存了3个副本</p>\n<p>2.所有的计算机同时运行GFS和MR workers</p>\n<p>3.输入分片数比workers数要多</p>\n<p>4.Master在每个服务器上启动一个Map任务，当旧任务结束时，会接着处理新的任务</p>\n<p>5.Worker对通过key做hash计算，将Map数据输出到R个分区中，存储在本地磁盘</p>\n<p>直到所有Maps操作结束后才会进行Reduce计算</p>\n<p>6.Master告诉Reducers从Map操作的workers那里获取中间数据分块</p>\n<p>7.Reduce操作的workers将最终输出结果写到GFS中</p>\n<p><strong>如何通过细节处的设计来提高网络性能</strong></p>\n<p>1.Map的输入从本地磁盘读取，不是通过网络</p>\n<p>2.生成的中间数据只在网络中传输一次，存储在磁盘中，而不是GFS</p>\n<p>3.生成的中间数据分块保存很多的key，并存储在文件中</p>\n<p>4.大块的网络传输效率更高</p>\n<p><strong>如果更均衡的分配负载</strong></p>\n<p>1.scaling out是至关重要的，否则使用Nx服务器就没有得到相应的收益</p>\n<p>2.但是处理一个split或者partition的分区时间是不统一的，不同大小和内容，不同的服务器硬件</p>\n<p>3.解决方案：split的数多于workes数</p>\n<p>Master将新的splits分发给已经完成先前任务的workers</p>\n<p>所以更快的服务器比慢速的服务器做更多的工作，并同时完成。</p>\n<p><strong>MR如何应对worker崩溃呢</strong></p>\n<p>1.Map worker 崩溃</p>\n<p>master重新运行，通过其他GFS的副本作为输入</p>\n<p>即使worker已经完成，因为我们仍需要磁盘上的中间数据</p>\n<p>一些Reduce workers可能已经督过workers的中间数据</p>\n<p>2.Master怎么知道worker崩溃了(通过 pings)</p>\n<p>如果Reduces已经获取了所有Map操作生成的中间数据，那么master不再需要重新运行Map，然后Reduce崩溃必须等待Maps重新运行</p>\n<p>3.如果 reduces worker在生成结果之前崩溃，那么master将重新启动另一个worker</p>\n<p>4.Reduce worker在写输出的过程中崩溃</p>\n<p>GFS具有 atomic rename ,可以防止输出在完成之前可见</p>\n<p>5.所以master在其他的地方重新运行Reduce 任务是安全的</p>\n"},{"title":"LEC12-vedio","date":"2019-01-17T01:36:53.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC12-vedio.md","raw":"---\ntitle: LEC12-vedio\ndate: 2019-01-17 09:36:53\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC12-vedio","published":1,"updated":"2019-06-26T11:56:34.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvynx000vvkqpy2nk6h3l","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611955&page=3\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC10-vedio","date":"2019-01-17T01:36:41.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC10-vedio.md","raw":"---\ntitle: LEC10-vedio\ndate: 2019-01-17 09:36:41\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC10-vedio","published":1,"updated":"2019-06-26T11:56:34.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyny000wvkqpxiem8ffk","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40611829&page=2\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC13-vedio","date":"2019-01-17T01:36:59.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC13-vedio.md","raw":"---\ntitle: LEC13-vedio\ndate: 2019-01-17 09:36:59\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC13-vedio","published":1,"updated":"2019-06-26T11:56:34.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvynz000xvkqp88xf884v","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612128&page=4\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC15-vedio","date":"2019-01-17T01:37:08.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC15-vedio.md","raw":"---\ntitle: LEC15-vedio\ndate: 2019-01-17 09:37:08\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC15-vedio","published":1,"updated":"2019-06-26T11:56:34.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyo00010vkqp19znm6yw","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612362&page=5\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC16-vedio","date":"2019-01-17T04:36:30.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n","source":"_posts/LEC16-vedio.md","raw":"---\ntitle: LEC16-vedio\ndate: 2019-01-17 12:36:30\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n","slug":"LEC16-vedio","published":1,"updated":"2019-06-26T11:56:34.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyo10012vkqpyyewj3xp","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612608&page=6\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n"},{"title":"LEC17-vedio","date":"2019-01-17T04:36:35.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC17-vedio.md","raw":"---\ntitle: LEC17-vedio\ndate: 2019-01-17 12:36:35\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC17-vedio","published":1,"updated":"2019-06-26T11:56:34.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyo40015vkqp7x5rghz4","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612650&page=7\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC2-vedio","date":"2019-01-17T01:35:51.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC2-vedio.md","raw":"---\ntitle: LEC2-vedio\ndate: 2019-01-17 09:35:51\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC2-vedio","published":1,"updated":"2019-06-26T11:56:34.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyo50017vkqp5ane4tip","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612728&page=8\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC20-vedio","date":"2019-01-17T04:36:52.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC20-vedio.md","raw":"---\ntitle: LEC20-vedio\ndate: 2019-01-17 12:36:52\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC20-vedio","published":1,"updated":"2019-06-26T11:56:34.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyoa0019vkqpgr4hz8ul","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612848&page=9\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC3-vedio","date":"2019-01-17T01:35:58.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC3-vedio.md","raw":"---\ntitle: LEC3-vedio\ndate: 2019-01-17 09:35:58\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC3-vedio","published":1,"updated":"2019-06-26T11:56:34.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyob001bvkqpih7dfrwb","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC4-vedio","date":"2019-01-17T01:36:13.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC4-vedio.md","raw":"---\ntitle: LEC4-vedio\ndate: 2019-01-17 09:36:13\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC4-vedio","published":1,"updated":"2019-06-26T11:56:34.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyoc001dvkqpthitib6e","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40612927&page=10\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC3","date":"2019-01-24T15:33:17.000Z","_content":"\n**谷歌文件系统(GFS)**\n\n**我们读这篇论文的目的**\n\n1.它是MapReduce操作的文件系统支持\n\n2.存储故障的案例研究\n\n- 交互一致性，实现简单性和性能\n- 后续设计的动机\n\n3.性能好--并行I/O性能好\n\n4.系统方面好的论文—从应用程序到网络的详细信息\n\n5.这篇论文展示了6.824这门课的所有主要主题\n\n- 性能、容错性、一致性\n\n**什么是一致性？**\n\n1.保证正确性的条件\n\n2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要\n\n- 如果应用程序执行写操作，那么后续的读操作会观察到什么？\n- 如果读取操作是来自一个不同的应用程序呢？\n\n3.弱一致性\n\nread（）操作可能返回过时的数据 --- 不是最近写入的结果\n\n4.强一致性\n\nread（）操作总是返回最新写入的数据\n\n5.权衡\n\n- 强一致对应用写入者是有好的\n- 强一致性对性能不友好\n\n6.许多正确性的条件（通常称为一致性模型）\n\n**一致性模型的历史**\n\n1.在体系结构，系统，数据库交互中被广泛使用。\n\n- 具有访问共享内存的专用缓存的并发处理器\n- 访问分布式文件系统的并发客户端\n- 分布式数据库上的并发事务\n\n2.许多不同的模型都有不同的权衡\n\n- 可串行化\n- 顺序一致性\n- 线性化\n- entry的一致性\n- 发布一致性\n\n3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中\n\n**理想的一致性模型**\n\n1.复制文件的行为类似于非复制的文件系统\n\n场景：同一台机器上有许多客户端访问单个磁盘上的文件\n\n2.如果一个应用程序写入，以后的读取会看到写入结果\n\n3.如果两个应用程序并发的写入一个文件会怎么样\n\n在文件系统值通常未定义—文件可能会写入混合乱序的内容\n\n4.如果两个应用程序并发的写入同一个文件夹\n\n```\nOne goes first, the other goes second\n```\n\n**导致不一致的来源**\n\n1.并发操作\n\n2.机器宕机\n\n3.网络分区\n\n**为什么这些想法在一个分布式文件中很难实现**\n\n1.协议会变得很复杂---很难正确的实现系统\n\n2.协议需要客户端和服务器之前的交互，会带来性能开销\n\n**GFS的设计者放弃了同时获得更好性能和简单设计的想法**\n\n1.会使得应用程序的开发者实现更加困难\n\n2.今天的论文主要讨论下面几个特性之间的权衡\n\n- 一致性\n- 容错性\n- 性能\n- 更简单的设计\n\n**GFS的目标**\n\n1.实现一个共享的文件系统\n\n2.成百上千的物理机（以Linux为基础）\n\n3.存储海量数据集\n\n**GFS存了什么？**\n\n1.作者没有实际的说明\n\n2.2003年的猜测\n\n- 搜索索引 & 数据库\n- web上所有的HTML文件\n- web上所有的图片\n\n**文件的属性**\n\n1.多兆字节的数据集\n\n2.很多文件是特别大的\n\n3.作者建议 1M文件 * 100MB = 100TB\n\n但是这是2003年的数据\n\n4.文件都是只追加存储的\n\n**主要挑战**\n\n1.很多机器故障是常见的\n\n假设一台机器每年宕机一次\n\n1000台机器，平均每天就有3台机器宕机\n\n2.高性能：很多并发的写者和读者\n\n- Map/Reduce 任务在GFS中读取和存储最终的结果\n- 注意：不是临时，中间的文件\n\n3.高效的利用网络\n\n**高层面的设计**\n\n1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的\n\n2.100多台带磁盘的块存储(chunk servers)服务器 \n\n- 存储64MB大小的文件块（每个块都是普通的linux文件）\n\n- 每个块存储三个副本在三台服务器上\n\n- 问题：为什么是3x的副本\n\n- 问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡\n\n- 问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？\n\n  是要对整个机器进行容错，而不仅仅是存储设备\n\n- 问题：为什么一个块那么大\n\n3.GFS的Master服务器知道目录的层次结构\n\n- 对于目录，里面存储了什么文件？\n\n- 对于文件，知道每一个64MB块所在的区块服务器\n\n- master将状态保存在内存中\n\n  每个块存储64B 的元数据信息\n\n- master上有元数据的专用可恢复数据库\n\n  master针对断电状况可以迅速的恢复\n\n- Shadow master会比master落后很多，但是可以被变成master\n\n**基本操作**\n\n1.客户端读取：\n\n- 发送文件名以及偏移量给master服务器\n- master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间\n- 请求最近的拥有改文件区块的服务器\n\n2.客户端写入：\n\n- 询问master在哪里存储这个数据\n- 当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储\n- 一个区块服务器是主\n- 它选择更新顺序并转发到两个备份\n\n**两种不同的容错方案**\n\n1.一种是针对master的\n\n2.一种是针对区块服务器的\n\n**针对Master的容错方案**\n\n1.单master\n\n- 客户端总是发请求给master\n- master掌控所有的操作\n\n2.持续存储限制的信息(Stores limited information persistently)\n\n- 名称空间（文件目录）\n- file到chunk的映射\n\n3.在日志中记录对这两项的更改\n\n- 在多个备份机器上复制日志\n- 客户端对状态的在记录写到log中才返回\n- 在后续要读到的很多系统中，log扮演者一个中心角色\n- logs扮演这中心角色在后续的实验中\n\n4.限制log文件的大小\n\n- 给master的状态打一个checkpoint（快照）\n- 移除在checkpoint之前的所有操作日志\n- 将checkpoint复制到备份中\n\n5.恢复\n\n- 从最后一个checkpoint恢复日志\n- 通过询问区块服务器来重新创建区块的位置信息\n\n6.Master是有单点故障风险的\n\n- 恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用\n\n- Shadow master\n\n  落后于master，它们从复制的日志中重播来恢复\n\n  服务器进行只读操作，但是可能返回过时的数据\n\n- 如果master无法恢复，从别处启动master一定要非常小心来避免两个master\n\n- 我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到\n\n**区块的容错性**\n\n1.Master向其中一个副本授予一个租约，这个租约是主区块服务器\n\n2.主决定所有操作\n\n3.客户端将数据推送至副本\n\n- 副本形成一个链\n- 这个链考虑的网络拓扑\n- 允许快速的复制\n\n4.客户端发送写请求到主服务器\n\n- 主分配序列号\n- 主在本地应用更改\n- 主转发请求到副本服务器\n- 主在收到所有副本服务器的请求响应后返回响应客户端\n\n5.如果一个副本没有响应，客户端将重试\n\n6.如果副本数量降到某个数字以下后，则主会重新复制区块\n\n7.主重新平衡副本\n\n**区块的一致性**\n\n1.一些区块可能会过时，它们错过的系统变化的操作\n\n2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器\n\n3.master和区块服务器持久化存储这个版本信息\n\n4.区块的版本信息也会发送给客户端\n\n5.版本号允许master和客户端检测过时数据\n\n**并发写/追加**\n\n1.客户端将并发的写文件的同一Region\n\n2.写入的结果是混合这些写入的--没有保证顺序\n\n- 很少有应用这样做，所以是没问题的\n- UNIX上的并发写入也会导致奇怪的结果\n\n3.许多客户端可能想要并发的追加一个日志文件\n\n- GFS支持原子操作\n- 主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器\n- 如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。\n- 客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）\n- 文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界\n\n**一致性模型**\n\n1.对于文件目录的操作是强一致的\n\n- master对元数据的操作是原子性的\n- 目录的操作遵循下面的想法\n  - 当master伟offline状态时，只有shadow master\n  - 只允许读操作，将有可能返回过期的数据\n\n2.区块的操作是弱一致性的\n\n- 一个失败的操作会导致区块的不一致\n\n  主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的\n\n- 客户端读到的可能不是最新的区块数据\n\n- 当客户端刷新租凭(lease)时，它将了解到新的版本号\n\n3.作者声称弱一致性对于应用来说不是大问题\n\n- 大部分的文件更新操作都是追加的\n- 应用程序可以再附加记录中使用UID来检查重复项\n- 应用程序可能只是读取较少的数据（但不是陈旧的数据）\n- 应用程序可以使用临时文件，或者原子的执行重命名操作\n\n**性能**\n\n1.读取有巨大的吞吐量（3副本）\n\n- 总计125MB/秒\n- 网络链路饱和\n\n2.写入不同文件的次数可能低于最大值\n\n- 作者吐槽了他们的网络栈\n- 网络失效导致了从一个副本传播到下一个副本中间有延迟\n\n3.并发的追加单个文件\n\n受限于存储最后一个区块的服务器\n\n**总结**\n\n1.GFS使用的重要FT技术\n\n- 日志&还原点(checkpoint)\n- 区块的主备复制，但保持一致性\n\n2.GFS优势\n\n- 大量顺序的读和写，追加\n- 大的吞吐量\n- 数据的容灾\n\n3.GFS缺点\n\n- master的容灾\n- 小文件的读写\n- 多个客户端并发的更新同一个文件","source":"_posts/LEC3.md","raw":"---\ntitle: LEC3\ndate: 2019-01-24 23:33:17\ntags: 分布式系统6.824笔记\n---\n\n**谷歌文件系统(GFS)**\n\n**我们读这篇论文的目的**\n\n1.它是MapReduce操作的文件系统支持\n\n2.存储故障的案例研究\n\n- 交互一致性，实现简单性和性能\n- 后续设计的动机\n\n3.性能好--并行I/O性能好\n\n4.系统方面好的论文—从应用程序到网络的详细信息\n\n5.这篇论文展示了6.824这门课的所有主要主题\n\n- 性能、容错性、一致性\n\n**什么是一致性？**\n\n1.保证正确性的条件\n\n2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要\n\n- 如果应用程序执行写操作，那么后续的读操作会观察到什么？\n- 如果读取操作是来自一个不同的应用程序呢？\n\n3.弱一致性\n\nread（）操作可能返回过时的数据 --- 不是最近写入的结果\n\n4.强一致性\n\nread（）操作总是返回最新写入的数据\n\n5.权衡\n\n- 强一致对应用写入者是有好的\n- 强一致性对性能不友好\n\n6.许多正确性的条件（通常称为一致性模型）\n\n**一致性模型的历史**\n\n1.在体系结构，系统，数据库交互中被广泛使用。\n\n- 具有访问共享内存的专用缓存的并发处理器\n- 访问分布式文件系统的并发客户端\n- 分布式数据库上的并发事务\n\n2.许多不同的模型都有不同的权衡\n\n- 可串行化\n- 顺序一致性\n- 线性化\n- entry的一致性\n- 发布一致性\n\n3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中\n\n**理想的一致性模型**\n\n1.复制文件的行为类似于非复制的文件系统\n\n场景：同一台机器上有许多客户端访问单个磁盘上的文件\n\n2.如果一个应用程序写入，以后的读取会看到写入结果\n\n3.如果两个应用程序并发的写入一个文件会怎么样\n\n在文件系统值通常未定义—文件可能会写入混合乱序的内容\n\n4.如果两个应用程序并发的写入同一个文件夹\n\n```\nOne goes first, the other goes second\n```\n\n**导致不一致的来源**\n\n1.并发操作\n\n2.机器宕机\n\n3.网络分区\n\n**为什么这些想法在一个分布式文件中很难实现**\n\n1.协议会变得很复杂---很难正确的实现系统\n\n2.协议需要客户端和服务器之前的交互，会带来性能开销\n\n**GFS的设计者放弃了同时获得更好性能和简单设计的想法**\n\n1.会使得应用程序的开发者实现更加困难\n\n2.今天的论文主要讨论下面几个特性之间的权衡\n\n- 一致性\n- 容错性\n- 性能\n- 更简单的设计\n\n**GFS的目标**\n\n1.实现一个共享的文件系统\n\n2.成百上千的物理机（以Linux为基础）\n\n3.存储海量数据集\n\n**GFS存了什么？**\n\n1.作者没有实际的说明\n\n2.2003年的猜测\n\n- 搜索索引 & 数据库\n- web上所有的HTML文件\n- web上所有的图片\n\n**文件的属性**\n\n1.多兆字节的数据集\n\n2.很多文件是特别大的\n\n3.作者建议 1M文件 * 100MB = 100TB\n\n但是这是2003年的数据\n\n4.文件都是只追加存储的\n\n**主要挑战**\n\n1.很多机器故障是常见的\n\n假设一台机器每年宕机一次\n\n1000台机器，平均每天就有3台机器宕机\n\n2.高性能：很多并发的写者和读者\n\n- Map/Reduce 任务在GFS中读取和存储最终的结果\n- 注意：不是临时，中间的文件\n\n3.高效的利用网络\n\n**高层面的设计**\n\n1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的\n\n2.100多台带磁盘的块存储(chunk servers)服务器 \n\n- 存储64MB大小的文件块（每个块都是普通的linux文件）\n\n- 每个块存储三个副本在三台服务器上\n\n- 问题：为什么是3x的副本\n\n- 问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡\n\n- 问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？\n\n  是要对整个机器进行容错，而不仅仅是存储设备\n\n- 问题：为什么一个块那么大\n\n3.GFS的Master服务器知道目录的层次结构\n\n- 对于目录，里面存储了什么文件？\n\n- 对于文件，知道每一个64MB块所在的区块服务器\n\n- master将状态保存在内存中\n\n  每个块存储64B 的元数据信息\n\n- master上有元数据的专用可恢复数据库\n\n  master针对断电状况可以迅速的恢复\n\n- Shadow master会比master落后很多，但是可以被变成master\n\n**基本操作**\n\n1.客户端读取：\n\n- 发送文件名以及偏移量给master服务器\n- master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间\n- 请求最近的拥有改文件区块的服务器\n\n2.客户端写入：\n\n- 询问master在哪里存储这个数据\n- 当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储\n- 一个区块服务器是主\n- 它选择更新顺序并转发到两个备份\n\n**两种不同的容错方案**\n\n1.一种是针对master的\n\n2.一种是针对区块服务器的\n\n**针对Master的容错方案**\n\n1.单master\n\n- 客户端总是发请求给master\n- master掌控所有的操作\n\n2.持续存储限制的信息(Stores limited information persistently)\n\n- 名称空间（文件目录）\n- file到chunk的映射\n\n3.在日志中记录对这两项的更改\n\n- 在多个备份机器上复制日志\n- 客户端对状态的在记录写到log中才返回\n- 在后续要读到的很多系统中，log扮演者一个中心角色\n- logs扮演这中心角色在后续的实验中\n\n4.限制log文件的大小\n\n- 给master的状态打一个checkpoint（快照）\n- 移除在checkpoint之前的所有操作日志\n- 将checkpoint复制到备份中\n\n5.恢复\n\n- 从最后一个checkpoint恢复日志\n- 通过询问区块服务器来重新创建区块的位置信息\n\n6.Master是有单点故障风险的\n\n- 恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用\n\n- Shadow master\n\n  落后于master，它们从复制的日志中重播来恢复\n\n  服务器进行只读操作，但是可能返回过时的数据\n\n- 如果master无法恢复，从别处启动master一定要非常小心来避免两个master\n\n- 我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到\n\n**区块的容错性**\n\n1.Master向其中一个副本授予一个租约，这个租约是主区块服务器\n\n2.主决定所有操作\n\n3.客户端将数据推送至副本\n\n- 副本形成一个链\n- 这个链考虑的网络拓扑\n- 允许快速的复制\n\n4.客户端发送写请求到主服务器\n\n- 主分配序列号\n- 主在本地应用更改\n- 主转发请求到副本服务器\n- 主在收到所有副本服务器的请求响应后返回响应客户端\n\n5.如果一个副本没有响应，客户端将重试\n\n6.如果副本数量降到某个数字以下后，则主会重新复制区块\n\n7.主重新平衡副本\n\n**区块的一致性**\n\n1.一些区块可能会过时，它们错过的系统变化的操作\n\n2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器\n\n3.master和区块服务器持久化存储这个版本信息\n\n4.区块的版本信息也会发送给客户端\n\n5.版本号允许master和客户端检测过时数据\n\n**并发写/追加**\n\n1.客户端将并发的写文件的同一Region\n\n2.写入的结果是混合这些写入的--没有保证顺序\n\n- 很少有应用这样做，所以是没问题的\n- UNIX上的并发写入也会导致奇怪的结果\n\n3.许多客户端可能想要并发的追加一个日志文件\n\n- GFS支持原子操作\n- 主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器\n- 如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。\n- 客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）\n- 文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界\n\n**一致性模型**\n\n1.对于文件目录的操作是强一致的\n\n- master对元数据的操作是原子性的\n- 目录的操作遵循下面的想法\n  - 当master伟offline状态时，只有shadow master\n  - 只允许读操作，将有可能返回过期的数据\n\n2.区块的操作是弱一致性的\n\n- 一个失败的操作会导致区块的不一致\n\n  主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的\n\n- 客户端读到的可能不是最新的区块数据\n\n- 当客户端刷新租凭(lease)时，它将了解到新的版本号\n\n3.作者声称弱一致性对于应用来说不是大问题\n\n- 大部分的文件更新操作都是追加的\n- 应用程序可以再附加记录中使用UID来检查重复项\n- 应用程序可能只是读取较少的数据（但不是陈旧的数据）\n- 应用程序可以使用临时文件，或者原子的执行重命名操作\n\n**性能**\n\n1.读取有巨大的吞吐量（3副本）\n\n- 总计125MB/秒\n- 网络链路饱和\n\n2.写入不同文件的次数可能低于最大值\n\n- 作者吐槽了他们的网络栈\n- 网络失效导致了从一个副本传播到下一个副本中间有延迟\n\n3.并发的追加单个文件\n\n受限于存储最后一个区块的服务器\n\n**总结**\n\n1.GFS使用的重要FT技术\n\n- 日志&还原点(checkpoint)\n- 区块的主备复制，但保持一致性\n\n2.GFS优势\n\n- 大量顺序的读和写，追加\n- 大的吞吐量\n- 数据的容灾\n\n3.GFS缺点\n\n- master的容灾\n- 小文件的读写\n- 多个客户端并发的更新同一个文件","slug":"LEC3","published":1,"updated":"2019-06-26T11:56:34.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyod001fvkqp1lk4w2p3","content":"<p><strong>谷歌文件系统(GFS)</strong></p>\n<p><strong>我们读这篇论文的目的</strong></p>\n<p>1.它是MapReduce操作的文件系统支持</p>\n<p>2.存储故障的案例研究</p>\n<ul>\n<li>交互一致性，实现简单性和性能</li>\n<li>后续设计的动机</li>\n</ul>\n<p>3.性能好–并行I/O性能好</p>\n<p>4.系统方面好的论文—从应用程序到网络的详细信息</p>\n<p>5.这篇论文展示了6.824这门课的所有主要主题</p>\n<ul>\n<li>性能、容错性、一致性</li>\n</ul>\n<p><strong>什么是一致性？</strong></p>\n<p>1.保证正确性的条件</p>\n<p>2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要</p>\n<ul>\n<li>如果应用程序执行写操作，那么后续的读操作会观察到什么？</li>\n<li>如果读取操作是来自一个不同的应用程序呢？</li>\n</ul>\n<p>3.弱一致性</p>\n<p>read（）操作可能返回过时的数据 — 不是最近写入的结果</p>\n<p>4.强一致性</p>\n<p>read（）操作总是返回最新写入的数据</p>\n<p>5.权衡</p>\n<ul>\n<li>强一致对应用写入者是有好的</li>\n<li>强一致性对性能不友好</li>\n</ul>\n<p>6.许多正确性的条件（通常称为一致性模型）</p>\n<p><strong>一致性模型的历史</strong></p>\n<p>1.在体系结构，系统，数据库交互中被广泛使用。</p>\n<ul>\n<li>具有访问共享内存的专用缓存的并发处理器</li>\n<li>访问分布式文件系统的并发客户端</li>\n<li>分布式数据库上的并发事务</li>\n</ul>\n<p>2.许多不同的模型都有不同的权衡</p>\n<ul>\n<li>可串行化</li>\n<li>顺序一致性</li>\n<li>线性化</li>\n<li>entry的一致性</li>\n<li>发布一致性</li>\n</ul>\n<p>3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中</p>\n<p><strong>理想的一致性模型</strong></p>\n<p>1.复制文件的行为类似于非复制的文件系统</p>\n<p>场景：同一台机器上有许多客户端访问单个磁盘上的文件</p>\n<p>2.如果一个应用程序写入，以后的读取会看到写入结果</p>\n<p>3.如果两个应用程序并发的写入一个文件会怎么样</p>\n<p>在文件系统值通常未定义—文件可能会写入混合乱序的内容</p>\n<p>4.如果两个应用程序并发的写入同一个文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">One goes first, the other goes second</span><br></pre></td></tr></table></figure>\n<p><strong>导致不一致的来源</strong></p>\n<p>1.并发操作</p>\n<p>2.机器宕机</p>\n<p>3.网络分区</p>\n<p><strong>为什么这些想法在一个分布式文件中很难实现</strong></p>\n<p>1.协议会变得很复杂—很难正确的实现系统</p>\n<p>2.协议需要客户端和服务器之前的交互，会带来性能开销</p>\n<p><strong>GFS的设计者放弃了同时获得更好性能和简单设计的想法</strong></p>\n<p>1.会使得应用程序的开发者实现更加困难</p>\n<p>2.今天的论文主要讨论下面几个特性之间的权衡</p>\n<ul>\n<li>一致性</li>\n<li>容错性</li>\n<li>性能</li>\n<li>更简单的设计</li>\n</ul>\n<p><strong>GFS的目标</strong></p>\n<p>1.实现一个共享的文件系统</p>\n<p>2.成百上千的物理机（以Linux为基础）</p>\n<p>3.存储海量数据集</p>\n<p><strong>GFS存了什么？</strong></p>\n<p>1.作者没有实际的说明</p>\n<p>2.2003年的猜测</p>\n<ul>\n<li>搜索索引 &amp; 数据库</li>\n<li>web上所有的HTML文件</li>\n<li>web上所有的图片</li>\n</ul>\n<p><strong>文件的属性</strong></p>\n<p>1.多兆字节的数据集</p>\n<p>2.很多文件是特别大的</p>\n<p>3.作者建议 1M文件 * 100MB = 100TB</p>\n<p>但是这是2003年的数据</p>\n<p>4.文件都是只追加存储的</p>\n<p><strong>主要挑战</strong></p>\n<p>1.很多机器故障是常见的</p>\n<p>假设一台机器每年宕机一次</p>\n<p>1000台机器，平均每天就有3台机器宕机</p>\n<p>2.高性能：很多并发的写者和读者</p>\n<ul>\n<li>Map/Reduce 任务在GFS中读取和存储最终的结果</li>\n<li>注意：不是临时，中间的文件</li>\n</ul>\n<p>3.高效的利用网络</p>\n<p><strong>高层面的设计</strong></p>\n<p>1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的</p>\n<p>2.100多台带磁盘的块存储(chunk servers)服务器 </p>\n<ul>\n<li><p>存储64MB大小的文件块（每个块都是普通的linux文件）</p>\n</li>\n<li><p>每个块存储三个副本在三台服务器上</p>\n</li>\n<li><p>问题：为什么是3x的副本</p>\n</li>\n<li><p>问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡</p>\n</li>\n<li><p>问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？</p>\n<p>是要对整个机器进行容错，而不仅仅是存储设备</p>\n</li>\n<li><p>问题：为什么一个块那么大</p>\n</li>\n</ul>\n<p>3.GFS的Master服务器知道目录的层次结构</p>\n<ul>\n<li><p>对于目录，里面存储了什么文件？</p>\n</li>\n<li><p>对于文件，知道每一个64MB块所在的区块服务器</p>\n</li>\n<li><p>master将状态保存在内存中</p>\n<p>每个块存储64B 的元数据信息</p>\n</li>\n<li><p>master上有元数据的专用可恢复数据库</p>\n<p>master针对断电状况可以迅速的恢复</p>\n</li>\n<li><p>Shadow master会比master落后很多，但是可以被变成master</p>\n</li>\n</ul>\n<p><strong>基本操作</strong></p>\n<p>1.客户端读取：</p>\n<ul>\n<li>发送文件名以及偏移量给master服务器</li>\n<li>master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间</li>\n<li>请求最近的拥有改文件区块的服务器</li>\n</ul>\n<p>2.客户端写入：</p>\n<ul>\n<li>询问master在哪里存储这个数据</li>\n<li>当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储</li>\n<li>一个区块服务器是主</li>\n<li>它选择更新顺序并转发到两个备份</li>\n</ul>\n<p><strong>两种不同的容错方案</strong></p>\n<p>1.一种是针对master的</p>\n<p>2.一种是针对区块服务器的</p>\n<p><strong>针对Master的容错方案</strong></p>\n<p>1.单master</p>\n<ul>\n<li>客户端总是发请求给master</li>\n<li>master掌控所有的操作</li>\n</ul>\n<p>2.持续存储限制的信息(Stores limited information persistently)</p>\n<ul>\n<li>名称空间（文件目录）</li>\n<li>file到chunk的映射</li>\n</ul>\n<p>3.在日志中记录对这两项的更改</p>\n<ul>\n<li>在多个备份机器上复制日志</li>\n<li>客户端对状态的在记录写到log中才返回</li>\n<li>在后续要读到的很多系统中，log扮演者一个中心角色</li>\n<li>logs扮演这中心角色在后续的实验中</li>\n</ul>\n<p>4.限制log文件的大小</p>\n<ul>\n<li>给master的状态打一个checkpoint（快照）</li>\n<li>移除在checkpoint之前的所有操作日志</li>\n<li>将checkpoint复制到备份中</li>\n</ul>\n<p>5.恢复</p>\n<ul>\n<li>从最后一个checkpoint恢复日志</li>\n<li>通过询问区块服务器来重新创建区块的位置信息</li>\n</ul>\n<p>6.Master是有单点故障风险的</p>\n<ul>\n<li><p>恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用</p>\n</li>\n<li><p>Shadow master</p>\n<p>落后于master，它们从复制的日志中重播来恢复</p>\n<p>服务器进行只读操作，但是可能返回过时的数据</p>\n</li>\n<li><p>如果master无法恢复，从别处启动master一定要非常小心来避免两个master</p>\n</li>\n<li><p>我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到</p>\n</li>\n</ul>\n<p><strong>区块的容错性</strong></p>\n<p>1.Master向其中一个副本授予一个租约，这个租约是主区块服务器</p>\n<p>2.主决定所有操作</p>\n<p>3.客户端将数据推送至副本</p>\n<ul>\n<li>副本形成一个链</li>\n<li>这个链考虑的网络拓扑</li>\n<li>允许快速的复制</li>\n</ul>\n<p>4.客户端发送写请求到主服务器</p>\n<ul>\n<li>主分配序列号</li>\n<li>主在本地应用更改</li>\n<li>主转发请求到副本服务器</li>\n<li>主在收到所有副本服务器的请求响应后返回响应客户端</li>\n</ul>\n<p>5.如果一个副本没有响应，客户端将重试</p>\n<p>6.如果副本数量降到某个数字以下后，则主会重新复制区块</p>\n<p>7.主重新平衡副本</p>\n<p><strong>区块的一致性</strong></p>\n<p>1.一些区块可能会过时，它们错过的系统变化的操作</p>\n<p>2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器</p>\n<p>3.master和区块服务器持久化存储这个版本信息</p>\n<p>4.区块的版本信息也会发送给客户端</p>\n<p>5.版本号允许master和客户端检测过时数据</p>\n<p><strong>并发写/追加</strong></p>\n<p>1.客户端将并发的写文件的同一Region</p>\n<p>2.写入的结果是混合这些写入的–没有保证顺序</p>\n<ul>\n<li>很少有应用这样做，所以是没问题的</li>\n<li>UNIX上的并发写入也会导致奇怪的结果</li>\n</ul>\n<p>3.许多客户端可能想要并发的追加一个日志文件</p>\n<ul>\n<li>GFS支持原子操作</li>\n<li>主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器</li>\n<li>如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。</li>\n<li>客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）</li>\n<li>文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界</li>\n</ul>\n<p><strong>一致性模型</strong></p>\n<p>1.对于文件目录的操作是强一致的</p>\n<ul>\n<li>master对元数据的操作是原子性的</li>\n<li>目录的操作遵循下面的想法<ul>\n<li>当master伟offline状态时，只有shadow master</li>\n<li>只允许读操作，将有可能返回过期的数据</li>\n</ul>\n</li>\n</ul>\n<p>2.区块的操作是弱一致性的</p>\n<ul>\n<li><p>一个失败的操作会导致区块的不一致</p>\n<p>主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的</p>\n</li>\n<li><p>客户端读到的可能不是最新的区块数据</p>\n</li>\n<li><p>当客户端刷新租凭(lease)时，它将了解到新的版本号</p>\n</li>\n</ul>\n<p>3.作者声称弱一致性对于应用来说不是大问题</p>\n<ul>\n<li>大部分的文件更新操作都是追加的</li>\n<li>应用程序可以再附加记录中使用UID来检查重复项</li>\n<li>应用程序可能只是读取较少的数据（但不是陈旧的数据）</li>\n<li>应用程序可以使用临时文件，或者原子的执行重命名操作</li>\n</ul>\n<p><strong>性能</strong></p>\n<p>1.读取有巨大的吞吐量（3副本）</p>\n<ul>\n<li>总计125MB/秒</li>\n<li>网络链路饱和</li>\n</ul>\n<p>2.写入不同文件的次数可能低于最大值</p>\n<ul>\n<li>作者吐槽了他们的网络栈</li>\n<li>网络失效导致了从一个副本传播到下一个副本中间有延迟</li>\n</ul>\n<p>3.并发的追加单个文件</p>\n<p>受限于存储最后一个区块的服务器</p>\n<p><strong>总结</strong></p>\n<p>1.GFS使用的重要FT技术</p>\n<ul>\n<li>日志&amp;还原点(checkpoint)</li>\n<li>区块的主备复制，但保持一致性</li>\n</ul>\n<p>2.GFS优势</p>\n<ul>\n<li>大量顺序的读和写，追加</li>\n<li>大的吞吐量</li>\n<li>数据的容灾</li>\n</ul>\n<p>3.GFS缺点</p>\n<ul>\n<li>master的容灾</li>\n<li>小文件的读写</li>\n<li>多个客户端并发的更新同一个文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>谷歌文件系统(GFS)</strong></p>\n<p><strong>我们读这篇论文的目的</strong></p>\n<p>1.它是MapReduce操作的文件系统支持</p>\n<p>2.存储故障的案例研究</p>\n<ul>\n<li>交互一致性，实现简单性和性能</li>\n<li>后续设计的动机</li>\n</ul>\n<p>3.性能好–并行I/O性能好</p>\n<p>4.系统方面好的论文—从应用程序到网络的详细信息</p>\n<p>5.这篇论文展示了6.824这门课的所有主要主题</p>\n<ul>\n<li>性能、容错性、一致性</li>\n</ul>\n<p><strong>什么是一致性？</strong></p>\n<p>1.保证正确性的条件</p>\n<p>2.在数据是多副本并被应用并行访问的时候数据一致性显得很重要</p>\n<ul>\n<li>如果应用程序执行写操作，那么后续的读操作会观察到什么？</li>\n<li>如果读取操作是来自一个不同的应用程序呢？</li>\n</ul>\n<p>3.弱一致性</p>\n<p>read（）操作可能返回过时的数据 — 不是最近写入的结果</p>\n<p>4.强一致性</p>\n<p>read（）操作总是返回最新写入的数据</p>\n<p>5.权衡</p>\n<ul>\n<li>强一致对应用写入者是有好的</li>\n<li>强一致性对性能不友好</li>\n</ul>\n<p>6.许多正确性的条件（通常称为一致性模型）</p>\n<p><strong>一致性模型的历史</strong></p>\n<p>1.在体系结构，系统，数据库交互中被广泛使用。</p>\n<ul>\n<li>具有访问共享内存的专用缓存的并发处理器</li>\n<li>访问分布式文件系统的并发客户端</li>\n<li>分布式数据库上的并发事务</li>\n</ul>\n<p>2.许多不同的模型都有不同的权衡</p>\n<ul>\n<li>可串行化</li>\n<li>顺序一致性</li>\n<li>线性化</li>\n<li>entry的一致性</li>\n<li>发布一致性</li>\n</ul>\n<p>3.今天的第一个重点，将出现在我们这个学期读到的几乎每一篇论文中</p>\n<p><strong>理想的一致性模型</strong></p>\n<p>1.复制文件的行为类似于非复制的文件系统</p>\n<p>场景：同一台机器上有许多客户端访问单个磁盘上的文件</p>\n<p>2.如果一个应用程序写入，以后的读取会看到写入结果</p>\n<p>3.如果两个应用程序并发的写入一个文件会怎么样</p>\n<p>在文件系统值通常未定义—文件可能会写入混合乱序的内容</p>\n<p>4.如果两个应用程序并发的写入同一个文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">One goes first, the other goes second</span><br></pre></td></tr></table></figure>\n<p><strong>导致不一致的来源</strong></p>\n<p>1.并发操作</p>\n<p>2.机器宕机</p>\n<p>3.网络分区</p>\n<p><strong>为什么这些想法在一个分布式文件中很难实现</strong></p>\n<p>1.协议会变得很复杂—很难正确的实现系统</p>\n<p>2.协议需要客户端和服务器之前的交互，会带来性能开销</p>\n<p><strong>GFS的设计者放弃了同时获得更好性能和简单设计的想法</strong></p>\n<p>1.会使得应用程序的开发者实现更加困难</p>\n<p>2.今天的论文主要讨论下面几个特性之间的权衡</p>\n<ul>\n<li>一致性</li>\n<li>容错性</li>\n<li>性能</li>\n<li>更简单的设计</li>\n</ul>\n<p><strong>GFS的目标</strong></p>\n<p>1.实现一个共享的文件系统</p>\n<p>2.成百上千的物理机（以Linux为基础）</p>\n<p>3.存储海量数据集</p>\n<p><strong>GFS存了什么？</strong></p>\n<p>1.作者没有实际的说明</p>\n<p>2.2003年的猜测</p>\n<ul>\n<li>搜索索引 &amp; 数据库</li>\n<li>web上所有的HTML文件</li>\n<li>web上所有的图片</li>\n</ul>\n<p><strong>文件的属性</strong></p>\n<p>1.多兆字节的数据集</p>\n<p>2.很多文件是特别大的</p>\n<p>3.作者建议 1M文件 * 100MB = 100TB</p>\n<p>但是这是2003年的数据</p>\n<p>4.文件都是只追加存储的</p>\n<p><strong>主要挑战</strong></p>\n<p>1.很多机器故障是常见的</p>\n<p>假设一台机器每年宕机一次</p>\n<p>1000台机器，平均每天就有3台机器宕机</p>\n<p>2.高性能：很多并发的写者和读者</p>\n<ul>\n<li>Map/Reduce 任务在GFS中读取和存储最终的结果</li>\n<li>注意：不是临时，中间的文件</li>\n</ul>\n<p>3.高效的利用网络</p>\n<p><strong>高层面的设计</strong></p>\n<p>1.目录、文件、名称，open/read/write 操作，但不是POSIX标准的</p>\n<p>2.100多台带磁盘的块存储(chunk servers)服务器 </p>\n<ul>\n<li><p>存储64MB大小的文件块（每个块都是普通的linux文件）</p>\n</li>\n<li><p>每个块存储三个副本在三台服务器上</p>\n</li>\n<li><p>问题：为什么是3x的副本</p>\n</li>\n<li><p>问题：除了数据的可用性，3x的副本可以给我们带来什么？用于读取热文件的负载均衡</p>\n</li>\n<li><p>问题：为什么不直接把每个文件的副本存储在一个RAID磁盘上？</p>\n<p>是要对整个机器进行容错，而不仅仅是存储设备</p>\n</li>\n<li><p>问题：为什么一个块那么大</p>\n</li>\n</ul>\n<p>3.GFS的Master服务器知道目录的层次结构</p>\n<ul>\n<li><p>对于目录，里面存储了什么文件？</p>\n</li>\n<li><p>对于文件，知道每一个64MB块所在的区块服务器</p>\n</li>\n<li><p>master将状态保存在内存中</p>\n<p>每个块存储64B 的元数据信息</p>\n</li>\n<li><p>master上有元数据的专用可恢复数据库</p>\n<p>master针对断电状况可以迅速的恢复</p>\n</li>\n<li><p>Shadow master会比master落后很多，但是可以被变成master</p>\n</li>\n</ul>\n<p><strong>基本操作</strong></p>\n<p>1.客户端读取：</p>\n<ul>\n<li>发送文件名以及偏移量给master服务器</li>\n<li>master返回一组拥有这个文件区块的服务器，客户端会将信息缓存一段时间</li>\n<li>请求最近的拥有改文件区块的服务器</li>\n</ul>\n<p>2.客户端写入：</p>\n<ul>\n<li>询问master在哪里存储这个数据</li>\n<li>当要写入文件区块大于60MB时，master选择一组新的区块服务器去存储</li>\n<li>一个区块服务器是主</li>\n<li>它选择更新顺序并转发到两个备份</li>\n</ul>\n<p><strong>两种不同的容错方案</strong></p>\n<p>1.一种是针对master的</p>\n<p>2.一种是针对区块服务器的</p>\n<p><strong>针对Master的容错方案</strong></p>\n<p>1.单master</p>\n<ul>\n<li>客户端总是发请求给master</li>\n<li>master掌控所有的操作</li>\n</ul>\n<p>2.持续存储限制的信息(Stores limited information persistently)</p>\n<ul>\n<li>名称空间（文件目录）</li>\n<li>file到chunk的映射</li>\n</ul>\n<p>3.在日志中记录对这两项的更改</p>\n<ul>\n<li>在多个备份机器上复制日志</li>\n<li>客户端对状态的在记录写到log中才返回</li>\n<li>在后续要读到的很多系统中，log扮演者一个中心角色</li>\n<li>logs扮演这中心角色在后续的实验中</li>\n</ul>\n<p>4.限制log文件的大小</p>\n<ul>\n<li>给master的状态打一个checkpoint（快照）</li>\n<li>移除在checkpoint之前的所有操作日志</li>\n<li>将checkpoint复制到备份中</li>\n</ul>\n<p>5.恢复</p>\n<ul>\n<li>从最后一个checkpoint恢复日志</li>\n<li>通过询问区块服务器来重新创建区块的位置信息</li>\n</ul>\n<p>6.Master是有单点故障风险的</p>\n<ul>\n<li><p>恢复是很快的，因为记录master的状态文件比较小，恢复可能导致主在短时间内不可用</p>\n</li>\n<li><p>Shadow master</p>\n<p>落后于master，它们从复制的日志中重播来恢复</p>\n<p>服务器进行只读操作，但是可能返回过时的数据</p>\n</li>\n<li><p>如果master无法恢复，从别处启动master一定要非常小心来避免两个master</p>\n</li>\n<li><p>我们将看到跟强有力的计划，更复杂的计划在后续的几讲中会谈到</p>\n</li>\n</ul>\n<p><strong>区块的容错性</strong></p>\n<p>1.Master向其中一个副本授予一个租约，这个租约是主区块服务器</p>\n<p>2.主决定所有操作</p>\n<p>3.客户端将数据推送至副本</p>\n<ul>\n<li>副本形成一个链</li>\n<li>这个链考虑的网络拓扑</li>\n<li>允许快速的复制</li>\n</ul>\n<p>4.客户端发送写请求到主服务器</p>\n<ul>\n<li>主分配序列号</li>\n<li>主在本地应用更改</li>\n<li>主转发请求到副本服务器</li>\n<li>主在收到所有副本服务器的请求响应后返回响应客户端</li>\n</ul>\n<p>5.如果一个副本没有响应，客户端将重试</p>\n<p>6.如果副本数量降到某个数字以下后，则主会重新复制区块</p>\n<p>7.主重新平衡副本</p>\n<p><strong>区块的一致性</strong></p>\n<p>1.一些区块可能会过时，它们错过的系统变化的操作</p>\n<p>2.用块版本号检测过时的数据，在出租一个区块前，增加区块版本号，将它发送给主以及从区块服务器</p>\n<p>3.master和区块服务器持久化存储这个版本信息</p>\n<p>4.区块的版本信息也会发送给客户端</p>\n<p>5.版本号允许master和客户端检测过时数据</p>\n<p><strong>并发写/追加</strong></p>\n<p>1.客户端将并发的写文件的同一Region</p>\n<p>2.写入的结果是混合这些写入的–没有保证顺序</p>\n<ul>\n<li>很少有应用这样做，所以是没问题的</li>\n<li>UNIX上的并发写入也会导致奇怪的结果</li>\n</ul>\n<p>3.许多客户端可能想要并发的追加一个日志文件</p>\n<ul>\n<li>GFS支持原子操作</li>\n<li>主区块服务器(primary chunk server)选择追加记录的偏移量，并发送给所有的副本区块服务器</li>\n<li>如果无法连接副本区块服务器，主区块服务器会向客户端报告错误。</li>\n<li>客户端重试；如果重试成功，一些副本将会被两次追加（第一次追加成功的那些）</li>\n<li>文件也可能有漏洞，当GFS填充内容到区块边界时，如果再追加将跨越边界</li>\n</ul>\n<p><strong>一致性模型</strong></p>\n<p>1.对于文件目录的操作是强一致的</p>\n<ul>\n<li>master对元数据的操作是原子性的</li>\n<li>目录的操作遵循下面的想法<ul>\n<li>当master伟offline状态时，只有shadow master</li>\n<li>只允许读操作，将有可能返回过期的数据</li>\n</ul>\n</li>\n</ul>\n<p>2.区块的操作是弱一致性的</p>\n<ul>\n<li><p>一个失败的操作会导致区块的不一致</p>\n<p>主区块服务器更新区块，然后后续操作失败了，这样副本数据是是过期的</p>\n</li>\n<li><p>客户端读到的可能不是最新的区块数据</p>\n</li>\n<li><p>当客户端刷新租凭(lease)时，它将了解到新的版本号</p>\n</li>\n</ul>\n<p>3.作者声称弱一致性对于应用来说不是大问题</p>\n<ul>\n<li>大部分的文件更新操作都是追加的</li>\n<li>应用程序可以再附加记录中使用UID来检查重复项</li>\n<li>应用程序可能只是读取较少的数据（但不是陈旧的数据）</li>\n<li>应用程序可以使用临时文件，或者原子的执行重命名操作</li>\n</ul>\n<p><strong>性能</strong></p>\n<p>1.读取有巨大的吞吐量（3副本）</p>\n<ul>\n<li>总计125MB/秒</li>\n<li>网络链路饱和</li>\n</ul>\n<p>2.写入不同文件的次数可能低于最大值</p>\n<ul>\n<li>作者吐槽了他们的网络栈</li>\n<li>网络失效导致了从一个副本传播到下一个副本中间有延迟</li>\n</ul>\n<p>3.并发的追加单个文件</p>\n<p>受限于存储最后一个区块的服务器</p>\n<p><strong>总结</strong></p>\n<p>1.GFS使用的重要FT技术</p>\n<ul>\n<li>日志&amp;还原点(checkpoint)</li>\n<li>区块的主备复制，但保持一致性</li>\n</ul>\n<p>2.GFS优势</p>\n<ul>\n<li>大量顺序的读和写，追加</li>\n<li>大的吞吐量</li>\n<li>数据的容灾</li>\n</ul>\n<p>3.GFS缺点</p>\n<ul>\n<li>master的容灾</li>\n<li>小文件的读写</li>\n<li>多个客户端并发的更新同一个文件</li>\n</ul>\n"},{"title":"LEC2","date":"2019-01-17T04:50:09.000Z","_content":"\n#### 基础设施: RPC 和 线程\n\n**一个最常被问到的问题:为什么使用Go**\n\n***6.824这门课原先是使用C++的***\n\n学生花了很多时间去修与构建分布式系统无关的bug\n\n例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象\n\n***Go 语言可以让你更专注的处理分布式系统的问题***\n\n1.Go语言是类型安全的\n\n2.它有垃圾收集器（不会存在对象没有free导致的程序bug）\n\n3.对并发编程的支持很友好\n\n4.对RPC的支持很友好\n\n***我们喜欢用Go编程***\n\n1.Go很容易学习\n\n2.Go语言推荐资料 https://golang.org/doc/effective_go.html#generality\n\n**远程过程调用 (RPC)**\n\n1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写\n\n2.隐藏了客户端/服务器通信的大部分细节\n\n3.通过RPC客户端的远程调用就像普通的过程调用\n\n4.服务器的处理程序和普通的程序类似\n\n5.RPC被广泛使用\n\n**理想情况下，RPC使得网络通信看起来就像函数的调用**\n\n客户端：\n\n```\nz = fn(x, y)\n```\n\n服务器：\n\n```\nfn(x, y) {\n    compute\n    return z\n}\n```\n\nRPC旨在实现这种透明度的调用\n\nGo语言RPC的库 https://golang.org/pkg/net/rpc/\n\n**RPC 消息图**\n\nClient\t\t\t\tServer\n\nrequest --->\n\n​\t\t\t<--- response\n\n**软件架构**\n\n客户端应用存根\t\t\t处理调用\n\nRPC 库\t\t\t\t\tRPC库\n\nNet   ——————————   Net\n\n**更多的细节**\n\n1.要调用服务器的那个处理函数\n\n2.Marshalling（编组）：将数据格式化为数据包\n\n​\t1）处理数组、指针和对象是很棘手的\n\n​\t2）Go的RPC库是相当强大的\n\n​\t3）有一些东西你不能传送：例如，channels（通道）,functions（函数）\n\n3.Binding（绑定）:客户端如何知道与谁交互?\n\n​       1）客户端被提供了服务器的主机名\n\n​       2）也许名称服务将服务映射到最佳的服务器主机\n\n4.线程：\n\n​\t1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应\n\n​\t2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序\n\n**RPC问题：如何处理失败**\n\n​\t例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃\n\n**客户端RPC库中的故障是什么样的?**\n\n1.客户端从未收到服务器的响应\n\n2.客户端不知道服务器是否能看到请求\n\n3.可能服务器或者网络在发送回复之前失败了\n\n**最简单的方案：“至少一次”行为**\n\n1.RPC库等待响应一段时间\n\n2.如果没有响应到达，重新发送请求\n\n3.多次尝试\n\n4.仍然没有响应的话，向应用程序返回一个错误\n\n5.问题：应用程序容易处理至少一次的操作吗？\n\n​\t至少一次：客户端发送“从银行账户中扣除5美元”\n\n6.问题：这个客户端程序有什么问题？\n\n​\tput(\"k\", 10) 通过RPC在数据库服务器中设置key的值\t\n\n​\tput(\"k\", 20) 然后客户端执行第二次put操作到同一个key\n\n7.问题：至少一次总是OK的吗？\n\n​\t1）重复操作是可以的，例如只读操作\n\n​\t2）如果应用程序有自己对于写副本的执行计划\n\n**更好的PRC行为：“至多一次”**\n\n1.想法：服务器RPC代码检测重复请求\n\n2.返回上一个reply，而不是重新运行处理程序\n\n**如何检测重复的请求**\n\n1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送\t\n\n```\nserver:\nif seen[xid]:\n\tr = old[xid]\nelse\n\tr = handler()\n\told[xid] = r\n\tseen[xid] = true\n```\n\n**至多一次请求的复杂之处**\n\n1.这将在实验2和以后的实验中出现\n\n2.如何确保XID是唯一的？\n\n​\t大的随机数？\n\n​\t合并唯一客户端ID（IP地址？）有序列？\n\n​\t服务器必须最终放弃优化旧的RPC的信息\n\n​\t1）什么时候丢弃是安全的\n\n​\t想法：\n\n​\t唯一的客户端ID\n\n​\t上一次客户端RPC请求的序列号\n\n​\t客户端的每一个RPCC包含\"seen all replies <= X\"\n\n​\t像TCP的sequence号一样\n\n​\t或者一次只允许一个客户端PRC\n\n​\t当seq + 1到达允许服务器放弃所有的 <= seq 的请求\n\n​\t或者客户端同意小于5分钟的重试，5分钟后服务器放弃\n\n如何处理相同的请求当原来的请求仍然在执行？\n\n​\t服务器不知道要回复，不想重复运行\n\n​\t想法：给每个正在执行的RPC设置一个\"pending\" flag；等待或者忽略相同的请求\n\n**当一个 at-most-once 服务器宕机和重启怎么办？**\n\n1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求\n\n2.也许它应该吧重复的信息写到磁盘？\n\n3.也许副本服务器也应该复制重复的信息？\n\n**\"一次就好\"怎么样？**\n\n最多一次加上无限制的重试加上容错服务\n\n**Go的RPC是 “at-most-once”**\n\n1.打开TCP连接\n\n2.向TCP连接中写入请求\n\n3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求\n\n4.Go的代码里面没有重试\n\n5.Go RPC代码在没有得到回复的时候会返回一个error\n\n1）可能在一个TCP超时之后\n\n2）可能服务器没有看到请求\n\n3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败\n\n**Go RPC的 at-most-once 不足以应对Lab1**\n\n1.它只适用于单个RPC调用\n\n2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败\n\n3.Go的RPC不能检测出这种重复\n\n1）在lab1中没问题，它在应用层处理了\n\n2）Lab2需要明确的检测重复提交\n\n**线程**\n\n1.线程是一个基本的服务结构工具\n\n2.你将会在lab中广泛的使用它\n\n3.它们可能很棘手\n\n4.但是对PRC非常有用\n\n5.Go称它们为Goroutines，也有很多人称它们为线程\n\n**Thread = \"Thread of control\"**\n\n1.多线程允许程序逻辑上在同一时刻同时做很多事情\n\n2.线程共享内存\n\n3.线程之间共享程序计数器，寄存器，栈空间\n\n**多线程的一些挑战**\n\n1.共享数据\n\n1）两个线程如果同时修改了相同的变量会怎么样？\n\n2）一个线程正在读数据，另一个线程改变数据呢？\n\n3）需要保护共享数据上的不变量\n\n4）使用Go sync.Mutex锁\n\n2.线程之间的通过\n\n例如：等待所有的Map线程完成\n\n使用Go channels\n\n3.死锁\n\n1）线程1等待线程2\n\n2）线程2等待线程1\n\n4.锁粒度\n\n1）粗粒度->实现简单，但是并发性能不好\n\n2）细粒度->更好的并发性能，更多的锁竞争(races)和死锁\n\n5.让我们来看labrpc 包里如何解决这些问题\n\n1）它类似于Go的RPC系统，但是网络是一个模拟网络\n\n- 网络延迟请求和响应\n- 网络丢包请求和响应\n- 网络的重发请求和响应\n\n2）说明 threads，mutexes，channels的用法\n\n3）使用Go实现了一个完整的RPC包\n\n**网络的结构**\n\n1.网络的描述\n\n1）服务器\n\n2）客户端\n\n2.每个网络都是互斥的\n\n**RPC概述**\n\n1.在test_test.go文件里面有很多例子\n\n2.应用调用RPC\n\n```\nreply := end.Call(\"Raft.AppendEntries\", args, &reply) //发出一个RPC请求，等待回复\n```\n\n3.服务端\n\n```\nsrv := MakeServer()\nsrv.AddService(svc) -- 一个服务器可以有多种服务\n```\n\n4.k/v\n\n将srv传递给 net.AddServer()\n\n```\nsvc := MakeService(recevierPbject) -- obj's 方法会处理RPC请求\n```\n\n非常像Go的rpcs.Register()\n\n传递svc给 srv.AddService()\n\n5.服务器的数据结构\n\n1）AddService()\n\n添加一个服务名\n\n问题：为什么使用锁？\n\n问题：什么事defer()？\n\n2）Dispatch()\n\n分发一个请求到正确的服务\n\n问题：为什么持有锁？\n\n问题：为什么持有锁的范围互道函数的末尾？\n\n3）Call()\n\n使用反射查找参数的类型\n\n使用gob编码参数\n\ne.ch 是网络发送请求的通道\n\n使用一个通道来接收网络的回复（<- req.replyCh）\n\n4）MakeEnd()\n\n有一个模拟网络的线程/goroutine\n\n从e.ch中读取并处理请求\n\n每个请求都在一个单独的goroutine中处理\n\nQ：一个endpoint 可以有很多未完成的请求吗\n\nQ：为什么使用rn.mu.Lock()？\n\nQ：锁保护了什么？\n\n5）ProcessReq()\n\n查找一个服务endpoint\n\n如果网络不可靠，可能会延迟或者丢失请求\n\n分发请求到一个新的线程\n\n通过读取ech中的数据等待服务端回复直到100ms过去\n\n100ms只是用来验证服务器是不是宕机了\n\n然后回复\n\nQ：谁将会读取回复？\n\nQ：如果ProcessReq不持有rn的锁可以吗？\n\n6）Service.dispatch()\n\n给请求找到一个处理的方法\n\n解码参数\n\n调用函数\n\n编码回复\n\n返回回复信息\n\nGo的内存模型需要显示同步才能进行通信\n\n下面代码是不正确的\n\n```\nvar x int\ndone := false\ngo func() { x = f(...); done = true }\nwhile done == false { }\n```\n\n这是一个非常诱人的写法，但是Go会说这是为定义的\n\n使用通道或者sync.WaitGroup代替\n\n**学习Go的goroutines和channels**\n\nhttps://golang.org/doc/articles/race_detector.html","source":"_posts/LEC2.md","raw":"---\ntitle: LEC2\ndate: 2019-01-17 12:50:09\ntags: 分布式系统6.824笔记\n---\n\n#### 基础设施: RPC 和 线程\n\n**一个最常被问到的问题:为什么使用Go**\n\n***6.824这门课原先是使用C++的***\n\n学生花了很多时间去修与构建分布式系统无关的bug\n\n例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象\n\n***Go 语言可以让你更专注的处理分布式系统的问题***\n\n1.Go语言是类型安全的\n\n2.它有垃圾收集器（不会存在对象没有free导致的程序bug）\n\n3.对并发编程的支持很友好\n\n4.对RPC的支持很友好\n\n***我们喜欢用Go编程***\n\n1.Go很容易学习\n\n2.Go语言推荐资料 https://golang.org/doc/effective_go.html#generality\n\n**远程过程调用 (RPC)**\n\n1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写\n\n2.隐藏了客户端/服务器通信的大部分细节\n\n3.通过RPC客户端的远程调用就像普通的过程调用\n\n4.服务器的处理程序和普通的程序类似\n\n5.RPC被广泛使用\n\n**理想情况下，RPC使得网络通信看起来就像函数的调用**\n\n客户端：\n\n```\nz = fn(x, y)\n```\n\n服务器：\n\n```\nfn(x, y) {\n    compute\n    return z\n}\n```\n\nRPC旨在实现这种透明度的调用\n\nGo语言RPC的库 https://golang.org/pkg/net/rpc/\n\n**RPC 消息图**\n\nClient\t\t\t\tServer\n\nrequest --->\n\n​\t\t\t<--- response\n\n**软件架构**\n\n客户端应用存根\t\t\t处理调用\n\nRPC 库\t\t\t\t\tRPC库\n\nNet   ——————————   Net\n\n**更多的细节**\n\n1.要调用服务器的那个处理函数\n\n2.Marshalling（编组）：将数据格式化为数据包\n\n​\t1）处理数组、指针和对象是很棘手的\n\n​\t2）Go的RPC库是相当强大的\n\n​\t3）有一些东西你不能传送：例如，channels（通道）,functions（函数）\n\n3.Binding（绑定）:客户端如何知道与谁交互?\n\n​       1）客户端被提供了服务器的主机名\n\n​       2）也许名称服务将服务映射到最佳的服务器主机\n\n4.线程：\n\n​\t1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应\n\n​\t2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序\n\n**RPC问题：如何处理失败**\n\n​\t例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃\n\n**客户端RPC库中的故障是什么样的?**\n\n1.客户端从未收到服务器的响应\n\n2.客户端不知道服务器是否能看到请求\n\n3.可能服务器或者网络在发送回复之前失败了\n\n**最简单的方案：“至少一次”行为**\n\n1.RPC库等待响应一段时间\n\n2.如果没有响应到达，重新发送请求\n\n3.多次尝试\n\n4.仍然没有响应的话，向应用程序返回一个错误\n\n5.问题：应用程序容易处理至少一次的操作吗？\n\n​\t至少一次：客户端发送“从银行账户中扣除5美元”\n\n6.问题：这个客户端程序有什么问题？\n\n​\tput(\"k\", 10) 通过RPC在数据库服务器中设置key的值\t\n\n​\tput(\"k\", 20) 然后客户端执行第二次put操作到同一个key\n\n7.问题：至少一次总是OK的吗？\n\n​\t1）重复操作是可以的，例如只读操作\n\n​\t2）如果应用程序有自己对于写副本的执行计划\n\n**更好的PRC行为：“至多一次”**\n\n1.想法：服务器RPC代码检测重复请求\n\n2.返回上一个reply，而不是重新运行处理程序\n\n**如何检测重复的请求**\n\n1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送\t\n\n```\nserver:\nif seen[xid]:\n\tr = old[xid]\nelse\n\tr = handler()\n\told[xid] = r\n\tseen[xid] = true\n```\n\n**至多一次请求的复杂之处**\n\n1.这将在实验2和以后的实验中出现\n\n2.如何确保XID是唯一的？\n\n​\t大的随机数？\n\n​\t合并唯一客户端ID（IP地址？）有序列？\n\n​\t服务器必须最终放弃优化旧的RPC的信息\n\n​\t1）什么时候丢弃是安全的\n\n​\t想法：\n\n​\t唯一的客户端ID\n\n​\t上一次客户端RPC请求的序列号\n\n​\t客户端的每一个RPCC包含\"seen all replies <= X\"\n\n​\t像TCP的sequence号一样\n\n​\t或者一次只允许一个客户端PRC\n\n​\t当seq + 1到达允许服务器放弃所有的 <= seq 的请求\n\n​\t或者客户端同意小于5分钟的重试，5分钟后服务器放弃\n\n如何处理相同的请求当原来的请求仍然在执行？\n\n​\t服务器不知道要回复，不想重复运行\n\n​\t想法：给每个正在执行的RPC设置一个\"pending\" flag；等待或者忽略相同的请求\n\n**当一个 at-most-once 服务器宕机和重启怎么办？**\n\n1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求\n\n2.也许它应该吧重复的信息写到磁盘？\n\n3.也许副本服务器也应该复制重复的信息？\n\n**\"一次就好\"怎么样？**\n\n最多一次加上无限制的重试加上容错服务\n\n**Go的RPC是 “at-most-once”**\n\n1.打开TCP连接\n\n2.向TCP连接中写入请求\n\n3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求\n\n4.Go的代码里面没有重试\n\n5.Go RPC代码在没有得到回复的时候会返回一个error\n\n1）可能在一个TCP超时之后\n\n2）可能服务器没有看到请求\n\n3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败\n\n**Go RPC的 at-most-once 不足以应对Lab1**\n\n1.它只适用于单个RPC调用\n\n2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败\n\n3.Go的RPC不能检测出这种重复\n\n1）在lab1中没问题，它在应用层处理了\n\n2）Lab2需要明确的检测重复提交\n\n**线程**\n\n1.线程是一个基本的服务结构工具\n\n2.你将会在lab中广泛的使用它\n\n3.它们可能很棘手\n\n4.但是对PRC非常有用\n\n5.Go称它们为Goroutines，也有很多人称它们为线程\n\n**Thread = \"Thread of control\"**\n\n1.多线程允许程序逻辑上在同一时刻同时做很多事情\n\n2.线程共享内存\n\n3.线程之间共享程序计数器，寄存器，栈空间\n\n**多线程的一些挑战**\n\n1.共享数据\n\n1）两个线程如果同时修改了相同的变量会怎么样？\n\n2）一个线程正在读数据，另一个线程改变数据呢？\n\n3）需要保护共享数据上的不变量\n\n4）使用Go sync.Mutex锁\n\n2.线程之间的通过\n\n例如：等待所有的Map线程完成\n\n使用Go channels\n\n3.死锁\n\n1）线程1等待线程2\n\n2）线程2等待线程1\n\n4.锁粒度\n\n1）粗粒度->实现简单，但是并发性能不好\n\n2）细粒度->更好的并发性能，更多的锁竞争(races)和死锁\n\n5.让我们来看labrpc 包里如何解决这些问题\n\n1）它类似于Go的RPC系统，但是网络是一个模拟网络\n\n- 网络延迟请求和响应\n- 网络丢包请求和响应\n- 网络的重发请求和响应\n\n2）说明 threads，mutexes，channels的用法\n\n3）使用Go实现了一个完整的RPC包\n\n**网络的结构**\n\n1.网络的描述\n\n1）服务器\n\n2）客户端\n\n2.每个网络都是互斥的\n\n**RPC概述**\n\n1.在test_test.go文件里面有很多例子\n\n2.应用调用RPC\n\n```\nreply := end.Call(\"Raft.AppendEntries\", args, &reply) //发出一个RPC请求，等待回复\n```\n\n3.服务端\n\n```\nsrv := MakeServer()\nsrv.AddService(svc) -- 一个服务器可以有多种服务\n```\n\n4.k/v\n\n将srv传递给 net.AddServer()\n\n```\nsvc := MakeService(recevierPbject) -- obj's 方法会处理RPC请求\n```\n\n非常像Go的rpcs.Register()\n\n传递svc给 srv.AddService()\n\n5.服务器的数据结构\n\n1）AddService()\n\n添加一个服务名\n\n问题：为什么使用锁？\n\n问题：什么事defer()？\n\n2）Dispatch()\n\n分发一个请求到正确的服务\n\n问题：为什么持有锁？\n\n问题：为什么持有锁的范围互道函数的末尾？\n\n3）Call()\n\n使用反射查找参数的类型\n\n使用gob编码参数\n\ne.ch 是网络发送请求的通道\n\n使用一个通道来接收网络的回复（<- req.replyCh）\n\n4）MakeEnd()\n\n有一个模拟网络的线程/goroutine\n\n从e.ch中读取并处理请求\n\n每个请求都在一个单独的goroutine中处理\n\nQ：一个endpoint 可以有很多未完成的请求吗\n\nQ：为什么使用rn.mu.Lock()？\n\nQ：锁保护了什么？\n\n5）ProcessReq()\n\n查找一个服务endpoint\n\n如果网络不可靠，可能会延迟或者丢失请求\n\n分发请求到一个新的线程\n\n通过读取ech中的数据等待服务端回复直到100ms过去\n\n100ms只是用来验证服务器是不是宕机了\n\n然后回复\n\nQ：谁将会读取回复？\n\nQ：如果ProcessReq不持有rn的锁可以吗？\n\n6）Service.dispatch()\n\n给请求找到一个处理的方法\n\n解码参数\n\n调用函数\n\n编码回复\n\n返回回复信息\n\nGo的内存模型需要显示同步才能进行通信\n\n下面代码是不正确的\n\n```\nvar x int\ndone := false\ngo func() { x = f(...); done = true }\nwhile done == false { }\n```\n\n这是一个非常诱人的写法，但是Go会说这是为定义的\n\n使用通道或者sync.WaitGroup代替\n\n**学习Go的goroutines和channels**\n\nhttps://golang.org/doc/articles/race_detector.html","slug":"LEC2","published":1,"updated":"2019-06-26T11:56:34.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyoe001hvkqpt0np3ddg","content":"<h4 id=\"基础设施-RPC-和-线程\"><a href=\"#基础设施-RPC-和-线程\" class=\"headerlink\" title=\"基础设施: RPC 和 线程\"></a>基础设施: RPC 和 线程</h4><p><strong>一个最常被问到的问题:为什么使用Go</strong></p>\n<p><strong><em>6.824这门课原先是使用C++的</em></strong></p>\n<p>学生花了很多时间去修与构建分布式系统无关的bug</p>\n<p>例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象</p>\n<p><strong><em>Go 语言可以让你更专注的处理分布式系统的问题</em></strong></p>\n<p>1.Go语言是类型安全的</p>\n<p>2.它有垃圾收集器（不会存在对象没有free导致的程序bug）</p>\n<p>3.对并发编程的支持很友好</p>\n<p>4.对RPC的支持很友好</p>\n<p><strong><em>我们喜欢用Go编程</em></strong></p>\n<p>1.Go很容易学习</p>\n<p>2.Go语言推荐资料 <a href=\"https://golang.org/doc/effective_go.html#generality\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/effective_go.html#generality</a></p>\n<p><strong>远程过程调用 (RPC)</strong></p>\n<p>1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写</p>\n<p>2.隐藏了客户端/服务器通信的大部分细节</p>\n<p>3.通过RPC客户端的远程调用就像普通的过程调用</p>\n<p>4.服务器的处理程序和普通的程序类似</p>\n<p>5.RPC被广泛使用</p>\n<p><strong>理想情况下，RPC使得网络通信看起来就像函数的调用</strong></p>\n<p>客户端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = fn(x, y)</span><br></pre></td></tr></table></figure>\n<p>服务器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn(x, y) &#123;</span><br><span class=\"line\">    compute</span><br><span class=\"line\">    return z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RPC旨在实现这种透明度的调用</p>\n<p>Go语言RPC的库 <a href=\"https://golang.org/pkg/net/rpc/\" target=\"_blank\" rel=\"noopener\">https://golang.org/pkg/net/rpc/</a></p>\n<p><strong>RPC 消息图</strong></p>\n<p>Client                Server</p>\n<p>request —&gt;</p>\n<p>​            &lt;— response</p>\n<p><strong>软件架构</strong></p>\n<p>客户端应用存根            处理调用</p>\n<p>RPC 库                    RPC库</p>\n<p>Net   ——————————   Net</p>\n<p><strong>更多的细节</strong></p>\n<p>1.要调用服务器的那个处理函数</p>\n<p>2.Marshalling（编组）：将数据格式化为数据包</p>\n<p>​    1）处理数组、指针和对象是很棘手的</p>\n<p>​    2）Go的RPC库是相当强大的</p>\n<p>​    3）有一些东西你不能传送：例如，channels（通道）,functions（函数）</p>\n<p>3.Binding（绑定）:客户端如何知道与谁交互?</p>\n<p>​       1）客户端被提供了服务器的主机名</p>\n<p>​       2）也许名称服务将服务映射到最佳的服务器主机</p>\n<p>4.线程：</p>\n<p>​    1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应</p>\n<p>​    2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序</p>\n<p><strong>RPC问题：如何处理失败</strong></p>\n<p>​    例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃</p>\n<p><strong>客户端RPC库中的故障是什么样的?</strong></p>\n<p>1.客户端从未收到服务器的响应</p>\n<p>2.客户端不知道服务器是否能看到请求</p>\n<p>3.可能服务器或者网络在发送回复之前失败了</p>\n<p><strong>最简单的方案：“至少一次”行为</strong></p>\n<p>1.RPC库等待响应一段时间</p>\n<p>2.如果没有响应到达，重新发送请求</p>\n<p>3.多次尝试</p>\n<p>4.仍然没有响应的话，向应用程序返回一个错误</p>\n<p>5.问题：应用程序容易处理至少一次的操作吗？</p>\n<p>​    至少一次：客户端发送“从银行账户中扣除5美元”</p>\n<p>6.问题：这个客户端程序有什么问题？</p>\n<p>​    put(“k”, 10) 通过RPC在数据库服务器中设置key的值    </p>\n<p>​    put(“k”, 20) 然后客户端执行第二次put操作到同一个key</p>\n<p>7.问题：至少一次总是OK的吗？</p>\n<p>​    1）重复操作是可以的，例如只读操作</p>\n<p>​    2）如果应用程序有自己对于写副本的执行计划</p>\n<p><strong>更好的PRC行为：“至多一次”</strong></p>\n<p>1.想法：服务器RPC代码检测重复请求</p>\n<p>2.返回上一个reply，而不是重新运行处理程序</p>\n<p><strong>如何检测重复的请求</strong></p>\n<p>1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">if seen[xid]:</span><br><span class=\"line\">\tr = old[xid]</span><br><span class=\"line\">else</span><br><span class=\"line\">\tr = handler()</span><br><span class=\"line\">\told[xid] = r</span><br><span class=\"line\">\tseen[xid] = true</span><br></pre></td></tr></table></figure>\n<p><strong>至多一次请求的复杂之处</strong></p>\n<p>1.这将在实验2和以后的实验中出现</p>\n<p>2.如何确保XID是唯一的？</p>\n<p>​    大的随机数？</p>\n<p>​    合并唯一客户端ID（IP地址？）有序列？</p>\n<p>​    服务器必须最终放弃优化旧的RPC的信息</p>\n<p>​    1）什么时候丢弃是安全的</p>\n<p>​    想法：</p>\n<p>​    唯一的客户端ID</p>\n<p>​    上一次客户端RPC请求的序列号</p>\n<p>​    客户端的每一个RPCC包含”seen all replies &lt;= X”</p>\n<p>​    像TCP的sequence号一样</p>\n<p>​    或者一次只允许一个客户端PRC</p>\n<p>​    当seq + 1到达允许服务器放弃所有的 &lt;= seq 的请求</p>\n<p>​    或者客户端同意小于5分钟的重试，5分钟后服务器放弃</p>\n<p>如何处理相同的请求当原来的请求仍然在执行？</p>\n<p>​    服务器不知道要回复，不想重复运行</p>\n<p>​    想法：给每个正在执行的RPC设置一个”pending” flag；等待或者忽略相同的请求</p>\n<p><strong>当一个 at-most-once 服务器宕机和重启怎么办？</strong></p>\n<p>1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求</p>\n<p>2.也许它应该吧重复的信息写到磁盘？</p>\n<p>3.也许副本服务器也应该复制重复的信息？</p>\n<p><strong>“一次就好”怎么样？</strong></p>\n<p>最多一次加上无限制的重试加上容错服务</p>\n<p><strong>Go的RPC是 “at-most-once”</strong></p>\n<p>1.打开TCP连接</p>\n<p>2.向TCP连接中写入请求</p>\n<p>3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求</p>\n<p>4.Go的代码里面没有重试</p>\n<p>5.Go RPC代码在没有得到回复的时候会返回一个error</p>\n<p>1）可能在一个TCP超时之后</p>\n<p>2）可能服务器没有看到请求</p>\n<p>3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败</p>\n<p><strong>Go RPC的 at-most-once 不足以应对Lab1</strong></p>\n<p>1.它只适用于单个RPC调用</p>\n<p>2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败</p>\n<p>3.Go的RPC不能检测出这种重复</p>\n<p>1）在lab1中没问题，它在应用层处理了</p>\n<p>2）Lab2需要明确的检测重复提交</p>\n<p><strong>线程</strong></p>\n<p>1.线程是一个基本的服务结构工具</p>\n<p>2.你将会在lab中广泛的使用它</p>\n<p>3.它们可能很棘手</p>\n<p>4.但是对PRC非常有用</p>\n<p>5.Go称它们为Goroutines，也有很多人称它们为线程</p>\n<p><strong>Thread = “Thread of control”</strong></p>\n<p>1.多线程允许程序逻辑上在同一时刻同时做很多事情</p>\n<p>2.线程共享内存</p>\n<p>3.线程之间共享程序计数器，寄存器，栈空间</p>\n<p><strong>多线程的一些挑战</strong></p>\n<p>1.共享数据</p>\n<p>1）两个线程如果同时修改了相同的变量会怎么样？</p>\n<p>2）一个线程正在读数据，另一个线程改变数据呢？</p>\n<p>3）需要保护共享数据上的不变量</p>\n<p>4）使用Go sync.Mutex锁</p>\n<p>2.线程之间的通过</p>\n<p>例如：等待所有的Map线程完成</p>\n<p>使用Go channels</p>\n<p>3.死锁</p>\n<p>1）线程1等待线程2</p>\n<p>2）线程2等待线程1</p>\n<p>4.锁粒度</p>\n<p>1）粗粒度-&gt;实现简单，但是并发性能不好</p>\n<p>2）细粒度-&gt;更好的并发性能，更多的锁竞争(races)和死锁</p>\n<p>5.让我们来看labrpc 包里如何解决这些问题</p>\n<p>1）它类似于Go的RPC系统，但是网络是一个模拟网络</p>\n<ul>\n<li>网络延迟请求和响应</li>\n<li>网络丢包请求和响应</li>\n<li>网络的重发请求和响应</li>\n</ul>\n<p>2）说明 threads，mutexes，channels的用法</p>\n<p>3）使用Go实现了一个完整的RPC包</p>\n<p><strong>网络的结构</strong></p>\n<p>1.网络的描述</p>\n<p>1）服务器</p>\n<p>2）客户端</p>\n<p>2.每个网络都是互斥的</p>\n<p><strong>RPC概述</strong></p>\n<p>1.在test_test.go文件里面有很多例子</p>\n<p>2.应用调用RPC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reply := end.Call(&quot;Raft.AppendEntries&quot;, args, &amp;reply) //发出一个RPC请求，等待回复</span><br></pre></td></tr></table></figure>\n<p>3.服务端</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srv := MakeServer()</span><br><span class=\"line\">srv.AddService(svc) -- 一个服务器可以有多种服务</span><br></pre></td></tr></table></figure>\n<p>4.k/v</p>\n<p>将srv传递给 net.AddServer()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svc := MakeService(recevierPbject) -- obj&apos;s 方法会处理RPC请求</span><br></pre></td></tr></table></figure>\n<p>非常像Go的rpcs.Register()</p>\n<p>传递svc给 srv.AddService()</p>\n<p>5.服务器的数据结构</p>\n<p>1）AddService()</p>\n<p>添加一个服务名</p>\n<p>问题：为什么使用锁？</p>\n<p>问题：什么事defer()？</p>\n<p>2）Dispatch()</p>\n<p>分发一个请求到正确的服务</p>\n<p>问题：为什么持有锁？</p>\n<p>问题：为什么持有锁的范围互道函数的末尾？</p>\n<p>3）Call()</p>\n<p>使用反射查找参数的类型</p>\n<p>使用gob编码参数</p>\n<p>e.ch 是网络发送请求的通道</p>\n<p>使用一个通道来接收网络的回复（&lt;- req.replyCh）</p>\n<p>4）MakeEnd()</p>\n<p>有一个模拟网络的线程/goroutine</p>\n<p>从e.ch中读取并处理请求</p>\n<p>每个请求都在一个单独的goroutine中处理</p>\n<p>Q：一个endpoint 可以有很多未完成的请求吗</p>\n<p>Q：为什么使用rn.mu.Lock()？</p>\n<p>Q：锁保护了什么？</p>\n<p>5）ProcessReq()</p>\n<p>查找一个服务endpoint</p>\n<p>如果网络不可靠，可能会延迟或者丢失请求</p>\n<p>分发请求到一个新的线程</p>\n<p>通过读取ech中的数据等待服务端回复直到100ms过去</p>\n<p>100ms只是用来验证服务器是不是宕机了</p>\n<p>然后回复</p>\n<p>Q：谁将会读取回复？</p>\n<p>Q：如果ProcessReq不持有rn的锁可以吗？</p>\n<p>6）Service.dispatch()</p>\n<p>给请求找到一个处理的方法</p>\n<p>解码参数</p>\n<p>调用函数</p>\n<p>编码回复</p>\n<p>返回回复信息</p>\n<p>Go的内存模型需要显示同步才能进行通信</p>\n<p>下面代码是不正确的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x int</span><br><span class=\"line\">done := false</span><br><span class=\"line\">go func() &#123; x = f(...); done = true &#125;</span><br><span class=\"line\">while done == false &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个非常诱人的写法，但是Go会说这是为定义的</p>\n<p>使用通道或者sync.WaitGroup代替</p>\n<p><strong>学习Go的goroutines和channels</strong></p>\n<p><a href=\"https://golang.org/doc/articles/race_detector.html\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/articles/race_detector.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"基础设施-RPC-和-线程\"><a href=\"#基础设施-RPC-和-线程\" class=\"headerlink\" title=\"基础设施: RPC 和 线程\"></a>基础设施: RPC 和 线程</h4><p><strong>一个最常被问到的问题:为什么使用Go</strong></p>\n<p><strong><em>6.824这门课原先是使用C++的</em></strong></p>\n<p>学生花了很多时间去修与构建分布式系统无关的bug</p>\n<p>例如C++编程里面一个创建对象的问题，学生free了还需要使用的对象</p>\n<p><strong><em>Go 语言可以让你更专注的处理分布式系统的问题</em></strong></p>\n<p>1.Go语言是类型安全的</p>\n<p>2.它有垃圾收集器（不会存在对象没有free导致的程序bug）</p>\n<p>3.对并发编程的支持很友好</p>\n<p>4.对RPC的支持很友好</p>\n<p><strong><em>我们喜欢用Go编程</em></strong></p>\n<p>1.Go很容易学习</p>\n<p>2.Go语言推荐资料 <a href=\"https://golang.org/doc/effective_go.html#generality\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/effective_go.html#generality</a></p>\n<p><strong>远程过程调用 (RPC)</strong></p>\n<p>1.分布式系统中的关键部分，所有的lab都使用到了RPC，它使得网络交互的程序更容易编写</p>\n<p>2.隐藏了客户端/服务器通信的大部分细节</p>\n<p>3.通过RPC客户端的远程调用就像普通的过程调用</p>\n<p>4.服务器的处理程序和普通的程序类似</p>\n<p>5.RPC被广泛使用</p>\n<p><strong>理想情况下，RPC使得网络通信看起来就像函数的调用</strong></p>\n<p>客户端：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = fn(x, y)</span><br></pre></td></tr></table></figure>\n<p>服务器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fn(x, y) &#123;</span><br><span class=\"line\">    compute</span><br><span class=\"line\">    return z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>RPC旨在实现这种透明度的调用</p>\n<p>Go语言RPC的库 <a href=\"https://golang.org/pkg/net/rpc/\" target=\"_blank\" rel=\"noopener\">https://golang.org/pkg/net/rpc/</a></p>\n<p><strong>RPC 消息图</strong></p>\n<p>Client                Server</p>\n<p>request —&gt;</p>\n<p>​            &lt;— response</p>\n<p><strong>软件架构</strong></p>\n<p>客户端应用存根            处理调用</p>\n<p>RPC 库                    RPC库</p>\n<p>Net   ——————————   Net</p>\n<p><strong>更多的细节</strong></p>\n<p>1.要调用服务器的那个处理函数</p>\n<p>2.Marshalling（编组）：将数据格式化为数据包</p>\n<p>​    1）处理数组、指针和对象是很棘手的</p>\n<p>​    2）Go的RPC库是相当强大的</p>\n<p>​    3）有一些东西你不能传送：例如，channels（通道）,functions（函数）</p>\n<p>3.Binding（绑定）:客户端如何知道与谁交互?</p>\n<p>​       1）客户端被提供了服务器的主机名</p>\n<p>​       2）也许名称服务将服务映射到最佳的服务器主机</p>\n<p>4.线程：</p>\n<p>​    1）客户端可能启动很多线程，所以1个以上的调用未完成，匹配响应</p>\n<p>​    2）处理程序可能很慢，因此服务器经常在每一个线程中运行每个处理程序</p>\n<p><strong>RPC问题：如何处理失败</strong></p>\n<p>​    例如：数据包丢失、网络中断、服务器速度慢、服务器崩溃</p>\n<p><strong>客户端RPC库中的故障是什么样的?</strong></p>\n<p>1.客户端从未收到服务器的响应</p>\n<p>2.客户端不知道服务器是否能看到请求</p>\n<p>3.可能服务器或者网络在发送回复之前失败了</p>\n<p><strong>最简单的方案：“至少一次”行为</strong></p>\n<p>1.RPC库等待响应一段时间</p>\n<p>2.如果没有响应到达，重新发送请求</p>\n<p>3.多次尝试</p>\n<p>4.仍然没有响应的话，向应用程序返回一个错误</p>\n<p>5.问题：应用程序容易处理至少一次的操作吗？</p>\n<p>​    至少一次：客户端发送“从银行账户中扣除5美元”</p>\n<p>6.问题：这个客户端程序有什么问题？</p>\n<p>​    put(“k”, 10) 通过RPC在数据库服务器中设置key的值    </p>\n<p>​    put(“k”, 20) 然后客户端执行第二次put操作到同一个key</p>\n<p>7.问题：至少一次总是OK的吗？</p>\n<p>​    1）重复操作是可以的，例如只读操作</p>\n<p>​    2）如果应用程序有自己对于写副本的执行计划</p>\n<p><strong>更好的PRC行为：“至多一次”</strong></p>\n<p>1.想法：服务器RPC代码检测重复请求</p>\n<p>2.返回上一个reply，而不是重新运行处理程序</p>\n<p><strong>如何检测重复的请求</strong></p>\n<p>1.客户端在每个请求中都包含一个唯一ID（xid）使用相同的xid重新发送    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">if seen[xid]:</span><br><span class=\"line\">\tr = old[xid]</span><br><span class=\"line\">else</span><br><span class=\"line\">\tr = handler()</span><br><span class=\"line\">\told[xid] = r</span><br><span class=\"line\">\tseen[xid] = true</span><br></pre></td></tr></table></figure>\n<p><strong>至多一次请求的复杂之处</strong></p>\n<p>1.这将在实验2和以后的实验中出现</p>\n<p>2.如何确保XID是唯一的？</p>\n<p>​    大的随机数？</p>\n<p>​    合并唯一客户端ID（IP地址？）有序列？</p>\n<p>​    服务器必须最终放弃优化旧的RPC的信息</p>\n<p>​    1）什么时候丢弃是安全的</p>\n<p>​    想法：</p>\n<p>​    唯一的客户端ID</p>\n<p>​    上一次客户端RPC请求的序列号</p>\n<p>​    客户端的每一个RPCC包含”seen all replies &lt;= X”</p>\n<p>​    像TCP的sequence号一样</p>\n<p>​    或者一次只允许一个客户端PRC</p>\n<p>​    当seq + 1到达允许服务器放弃所有的 &lt;= seq 的请求</p>\n<p>​    或者客户端同意小于5分钟的重试，5分钟后服务器放弃</p>\n<p>如何处理相同的请求当原来的请求仍然在执行？</p>\n<p>​    服务器不知道要回复，不想重复运行</p>\n<p>​    想法：给每个正在执行的RPC设置一个”pending” flag；等待或者忽略相同的请求</p>\n<p><strong>当一个 at-most-once 服务器宕机和重启怎么办？</strong></p>\n<p>1.如果内存中最多有一次重复的信息，服务器将忘记重新启动后接受重复请求</p>\n<p>2.也许它应该吧重复的信息写到磁盘？</p>\n<p>3.也许副本服务器也应该复制重复的信息？</p>\n<p><strong>“一次就好”怎么样？</strong></p>\n<p>最多一次加上无限制的重试加上容错服务</p>\n<p><strong>Go的RPC是 “at-most-once”</strong></p>\n<p>1.打开TCP连接</p>\n<p>2.向TCP连接中写入请求</p>\n<p>3.TCP可以重新传输，但服务器的TCP将过滤掉重复的请求</p>\n<p>4.Go的代码里面没有重试</p>\n<p>5.Go RPC代码在没有得到回复的时候会返回一个error</p>\n<p>1）可能在一个TCP超时之后</p>\n<p>2）可能服务器没有看到请求</p>\n<p>3）可能服务器执行了请求，但是在回复到达客户端之前服务或者网络失败</p>\n<p><strong>Go RPC的 at-most-once 不足以应对Lab1</strong></p>\n<p>1.它只适用于单个RPC调用</p>\n<p>2.如果一个worker没有响应，master会重新发请求给其他的worker，但是原来的worker上的任务可能没有失败</p>\n<p>3.Go的RPC不能检测出这种重复</p>\n<p>1）在lab1中没问题，它在应用层处理了</p>\n<p>2）Lab2需要明确的检测重复提交</p>\n<p><strong>线程</strong></p>\n<p>1.线程是一个基本的服务结构工具</p>\n<p>2.你将会在lab中广泛的使用它</p>\n<p>3.它们可能很棘手</p>\n<p>4.但是对PRC非常有用</p>\n<p>5.Go称它们为Goroutines，也有很多人称它们为线程</p>\n<p><strong>Thread = “Thread of control”</strong></p>\n<p>1.多线程允许程序逻辑上在同一时刻同时做很多事情</p>\n<p>2.线程共享内存</p>\n<p>3.线程之间共享程序计数器，寄存器，栈空间</p>\n<p><strong>多线程的一些挑战</strong></p>\n<p>1.共享数据</p>\n<p>1）两个线程如果同时修改了相同的变量会怎么样？</p>\n<p>2）一个线程正在读数据，另一个线程改变数据呢？</p>\n<p>3）需要保护共享数据上的不变量</p>\n<p>4）使用Go sync.Mutex锁</p>\n<p>2.线程之间的通过</p>\n<p>例如：等待所有的Map线程完成</p>\n<p>使用Go channels</p>\n<p>3.死锁</p>\n<p>1）线程1等待线程2</p>\n<p>2）线程2等待线程1</p>\n<p>4.锁粒度</p>\n<p>1）粗粒度-&gt;实现简单，但是并发性能不好</p>\n<p>2）细粒度-&gt;更好的并发性能，更多的锁竞争(races)和死锁</p>\n<p>5.让我们来看labrpc 包里如何解决这些问题</p>\n<p>1）它类似于Go的RPC系统，但是网络是一个模拟网络</p>\n<ul>\n<li>网络延迟请求和响应</li>\n<li>网络丢包请求和响应</li>\n<li>网络的重发请求和响应</li>\n</ul>\n<p>2）说明 threads，mutexes，channels的用法</p>\n<p>3）使用Go实现了一个完整的RPC包</p>\n<p><strong>网络的结构</strong></p>\n<p>1.网络的描述</p>\n<p>1）服务器</p>\n<p>2）客户端</p>\n<p>2.每个网络都是互斥的</p>\n<p><strong>RPC概述</strong></p>\n<p>1.在test_test.go文件里面有很多例子</p>\n<p>2.应用调用RPC</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reply := end.Call(&quot;Raft.AppendEntries&quot;, args, &amp;reply) //发出一个RPC请求，等待回复</span><br></pre></td></tr></table></figure>\n<p>3.服务端</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">srv := MakeServer()</span><br><span class=\"line\">srv.AddService(svc) -- 一个服务器可以有多种服务</span><br></pre></td></tr></table></figure>\n<p>4.k/v</p>\n<p>将srv传递给 net.AddServer()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svc := MakeService(recevierPbject) -- obj&apos;s 方法会处理RPC请求</span><br></pre></td></tr></table></figure>\n<p>非常像Go的rpcs.Register()</p>\n<p>传递svc给 srv.AddService()</p>\n<p>5.服务器的数据结构</p>\n<p>1）AddService()</p>\n<p>添加一个服务名</p>\n<p>问题：为什么使用锁？</p>\n<p>问题：什么事defer()？</p>\n<p>2）Dispatch()</p>\n<p>分发一个请求到正确的服务</p>\n<p>问题：为什么持有锁？</p>\n<p>问题：为什么持有锁的范围互道函数的末尾？</p>\n<p>3）Call()</p>\n<p>使用反射查找参数的类型</p>\n<p>使用gob编码参数</p>\n<p>e.ch 是网络发送请求的通道</p>\n<p>使用一个通道来接收网络的回复（&lt;- req.replyCh）</p>\n<p>4）MakeEnd()</p>\n<p>有一个模拟网络的线程/goroutine</p>\n<p>从e.ch中读取并处理请求</p>\n<p>每个请求都在一个单独的goroutine中处理</p>\n<p>Q：一个endpoint 可以有很多未完成的请求吗</p>\n<p>Q：为什么使用rn.mu.Lock()？</p>\n<p>Q：锁保护了什么？</p>\n<p>5）ProcessReq()</p>\n<p>查找一个服务endpoint</p>\n<p>如果网络不可靠，可能会延迟或者丢失请求</p>\n<p>分发请求到一个新的线程</p>\n<p>通过读取ech中的数据等待服务端回复直到100ms过去</p>\n<p>100ms只是用来验证服务器是不是宕机了</p>\n<p>然后回复</p>\n<p>Q：谁将会读取回复？</p>\n<p>Q：如果ProcessReq不持有rn的锁可以吗？</p>\n<p>6）Service.dispatch()</p>\n<p>给请求找到一个处理的方法</p>\n<p>解码参数</p>\n<p>调用函数</p>\n<p>编码回复</p>\n<p>返回回复信息</p>\n<p>Go的内存模型需要显示同步才能进行通信</p>\n<p>下面代码是不正确的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x int</span><br><span class=\"line\">done := false</span><br><span class=\"line\">go func() &#123; x = f(...); done = true &#125;</span><br><span class=\"line\">while done == false &#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>这是一个非常诱人的写法，但是Go会说这是为定义的</p>\n<p>使用通道或者sync.WaitGroup代替</p>\n<p><strong>学习Go的goroutines和channels</strong></p>\n<p><a href=\"https://golang.org/doc/articles/race_detector.html\" target=\"_blank\" rel=\"noopener\">https://golang.org/doc/articles/race_detector.html</a></p>\n"},{"title":"LEC4","date":"2019-02-07T00:52:12.000Z","_content":"\n**今天的主题**\n\n1.主/从复制\n\n- 广泛使用，例如GFS的区块服务器\n- 但是今天被广泛应用于强一致\n- 特别重要，我们需要深入探索它\n\n2.VM-FT案例的学习\n\n**容错性**\n\n1.我们需要构建一个即使失败也能继续的服务\n\n2.高可用：在一些失败后仍然可用\n\n3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。\n\n4.非常困难！\n\n5.非常有用！\n\n**需要一个服务失败模型：我们将尝试处理什么？**\n\n1.独立的故障，停止计算机的故障\n\n- VM-FT假设一次只出现一个故障\n\n2.停电（最终重启）\n\n3.网络分区\n\n4.没有bugs，没有恶意攻击\n\n**核心的想法：复制**\n\n1.两台服务器\n\n2.每个副本保持着服务所需要的状态\n\n3.如果一个副本失效了，其他的可以继续提供服务\n\n**例子：MapReduce里面的matser模型**\n\n1.lab1里面的worker是高可用的，但是没有master\n\n- master是单点故障的\n\n2.我们可以有两个master吗，在一个失败的情况下？\n\n[架构图：M1, M2, workers]\n\n状态：\n\n- worker列表\n- 那些job做完了\n- 那些worker空闲\n- TCP连接的状态\n- 程序计数器\n\n**大的问题**\n\n1.要复制的状态是什么？\n\n2.副本如何获得状态？\n\n3.何时切换到副本服务器？\n\n4.切换的时候是否会表现出异常状态？\n\n5.如何修复，重新集成？\n\n**两个主要的方法**\n\n1.状态转换\n\n- 主服务器执行服务\n- 主服务器项备服务器发送新的状态\n\n2.副本的状态机\n\n- 所有的副本执行所有的操作\n- 如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态\n\n**状态转换更简单**\n\n1.但是状态空间可能比较大，转换起来很慢\n\n2.VM-FT使用复制状态机\n\n**复制状态机是很高效的**\n\n1.与数据相比，如果操作很小，但要正确执行则很复杂\n\n例如：多核心处理器执行操作的顺序，确定性\n\n2.实验使用了复制状态机\n\n**什么是复制状态机？**\n\n1.K/V对的put和get操作\n\n2.x86指令集\n\n3.影响性能和易于实现\n\n- 主/备之间需要多少交互\n- 高度抽象的机器可以交互更少的信息\n- 在x86级别上处理不确定性很难，但在Put/Get级别上更容易实现\n\n4.高级RSM仅适用于使用高级接口的程序\n\n- x86 RSM可以执行任意x86程序\n\n**一种实用的容错虚拟机系统设计**\n\nScales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010\n\n**非常健壮的系统**\n\n1.整个系统复制\n\n2.对应用程序和客户端完全透明\n\n3.任何现有软件的高可用性\n\n4.如果它效果好的话会很神奇的\n\n5.失效模型：\n\n- 独立硬件故障\n- 全站停电\n\n6.仅限于单处理器虚拟机\n\n问题：多核处理器有什么困难\n\n**概述**\n\n1.两种机器，主和备，以及其他机器\n\n2.两种网络连接：客户端到服务器，日志交换的通道\n\n3.用于持久化存储的共享磁盘\n\n4.在“锁定步骤”中备份主\n\n- 主服务器将所有的输入发送到备份\n- 备份输出将被丢弃\n\n5.主和备之间保持心跳\n\n- 如果主失败，开始备执行\n\n**输入是什么？**\n\n1.时钟中断\n\n2.网络中断\n\n3.磁盘中断\n\n**挑战:**\n\n1.使整个系统看起来像一台可靠的服务器\n\n如果主服务器发生故障，副本接管，系统外部会看到什么？\n\n如果主服务器在发送响应之前或之后宕机，客户端的请求会丢失吗？还是执行两次？\n\n什么时候主服务器发送响应给客户端？\n\n2.如何避免两次初筛？\n\n如果日志记录通道中断怎么办？\n\n3.如何保证backup称为primary的精确副本（完全一致）\n\n哪些操作必须发送到副本\n\n时钟中断？\n\n如何处理非决定论\n\n例如：中断必须以主中断相同的指令在备份时发送\n\n","source":"_posts/LEC4.md","raw":"---\ntitle: LEC4\ndate: 2019-02-07 08:52:12\ntags:\n---\n\n**今天的主题**\n\n1.主/从复制\n\n- 广泛使用，例如GFS的区块服务器\n- 但是今天被广泛应用于强一致\n- 特别重要，我们需要深入探索它\n\n2.VM-FT案例的学习\n\n**容错性**\n\n1.我们需要构建一个即使失败也能继续的服务\n\n2.高可用：在一些失败后仍然可用\n\n3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。\n\n4.非常困难！\n\n5.非常有用！\n\n**需要一个服务失败模型：我们将尝试处理什么？**\n\n1.独立的故障，停止计算机的故障\n\n- VM-FT假设一次只出现一个故障\n\n2.停电（最终重启）\n\n3.网络分区\n\n4.没有bugs，没有恶意攻击\n\n**核心的想法：复制**\n\n1.两台服务器\n\n2.每个副本保持着服务所需要的状态\n\n3.如果一个副本失效了，其他的可以继续提供服务\n\n**例子：MapReduce里面的matser模型**\n\n1.lab1里面的worker是高可用的，但是没有master\n\n- master是单点故障的\n\n2.我们可以有两个master吗，在一个失败的情况下？\n\n[架构图：M1, M2, workers]\n\n状态：\n\n- worker列表\n- 那些job做完了\n- 那些worker空闲\n- TCP连接的状态\n- 程序计数器\n\n**大的问题**\n\n1.要复制的状态是什么？\n\n2.副本如何获得状态？\n\n3.何时切换到副本服务器？\n\n4.切换的时候是否会表现出异常状态？\n\n5.如何修复，重新集成？\n\n**两个主要的方法**\n\n1.状态转换\n\n- 主服务器执行服务\n- 主服务器项备服务器发送新的状态\n\n2.副本的状态机\n\n- 所有的副本执行所有的操作\n- 如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态\n\n**状态转换更简单**\n\n1.但是状态空间可能比较大，转换起来很慢\n\n2.VM-FT使用复制状态机\n\n**复制状态机是很高效的**\n\n1.与数据相比，如果操作很小，但要正确执行则很复杂\n\n例如：多核心处理器执行操作的顺序，确定性\n\n2.实验使用了复制状态机\n\n**什么是复制状态机？**\n\n1.K/V对的put和get操作\n\n2.x86指令集\n\n3.影响性能和易于实现\n\n- 主/备之间需要多少交互\n- 高度抽象的机器可以交互更少的信息\n- 在x86级别上处理不确定性很难，但在Put/Get级别上更容易实现\n\n4.高级RSM仅适用于使用高级接口的程序\n\n- x86 RSM可以执行任意x86程序\n\n**一种实用的容错虚拟机系统设计**\n\nScales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010\n\n**非常健壮的系统**\n\n1.整个系统复制\n\n2.对应用程序和客户端完全透明\n\n3.任何现有软件的高可用性\n\n4.如果它效果好的话会很神奇的\n\n5.失效模型：\n\n- 独立硬件故障\n- 全站停电\n\n6.仅限于单处理器虚拟机\n\n问题：多核处理器有什么困难\n\n**概述**\n\n1.两种机器，主和备，以及其他机器\n\n2.两种网络连接：客户端到服务器，日志交换的通道\n\n3.用于持久化存储的共享磁盘\n\n4.在“锁定步骤”中备份主\n\n- 主服务器将所有的输入发送到备份\n- 备份输出将被丢弃\n\n5.主和备之间保持心跳\n\n- 如果主失败，开始备执行\n\n**输入是什么？**\n\n1.时钟中断\n\n2.网络中断\n\n3.磁盘中断\n\n**挑战:**\n\n1.使整个系统看起来像一台可靠的服务器\n\n如果主服务器发生故障，副本接管，系统外部会看到什么？\n\n如果主服务器在发送响应之前或之后宕机，客户端的请求会丢失吗？还是执行两次？\n\n什么时候主服务器发送响应给客户端？\n\n2.如何避免两次初筛？\n\n如果日志记录通道中断怎么办？\n\n3.如何保证backup称为primary的精确副本（完全一致）\n\n哪些操作必须发送到副本\n\n时钟中断？\n\n如何处理非决定论\n\n例如：中断必须以主中断相同的指令在备份时发送\n\n","slug":"LEC4","published":1,"updated":"2019-06-26T11:56:34.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyof001jvkqpfd2k7qyk","content":"<p><strong>今天的主题</strong></p>\n<p>1.主/从复制</p>\n<ul>\n<li>广泛使用，例如GFS的区块服务器</li>\n<li>但是今天被广泛应用于强一致</li>\n<li>特别重要，我们需要深入探索它</li>\n</ul>\n<p>2.VM-FT案例的学习</p>\n<p><strong>容错性</strong></p>\n<p>1.我们需要构建一个即使失败也能继续的服务</p>\n<p>2.高可用：在一些失败后仍然可用</p>\n<p>3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。</p>\n<p>4.非常困难！</p>\n<p>5.非常有用！</p>\n<p><strong>需要一个服务失败模型：我们将尝试处理什么？</strong></p>\n<p>1.独立的故障，停止计算机的故障</p>\n<ul>\n<li>VM-FT假设一次只出现一个故障</li>\n</ul>\n<p>2.停电（最终重启）</p>\n<p>3.网络分区</p>\n<p>4.没有bugs，没有恶意攻击</p>\n<p><strong>核心的想法：复制</strong></p>\n<p>1.两台服务器</p>\n<p>2.每个副本保持着服务所需要的状态</p>\n<p>3.如果一个副本失效了，其他的可以继续提供服务</p>\n<p><strong>例子：MapReduce里面的matser模型</strong></p>\n<p>1.lab1里面的worker是高可用的，但是没有master</p>\n<ul>\n<li>master是单点故障的</li>\n</ul>\n<p>2.我们可以有两个master吗，在一个失败的情况下？</p>\n<p>[架构图：M1, M2, workers]</p>\n<p>状态：</p>\n<ul>\n<li>worker列表</li>\n<li>那些job做完了</li>\n<li>那些worker空闲</li>\n<li>TCP连接的状态</li>\n<li>程序计数器</li>\n</ul>\n<p><strong>大的问题</strong></p>\n<p>1.要复制的状态是什么？</p>\n<p>2.副本如何获得状态？</p>\n<p>3.何时切换到副本服务器？</p>\n<p>4.切换的时候是否会表现出异常状态？</p>\n<p>5.如何修复，重新集成？</p>\n<p><strong>两个主要的方法</strong></p>\n<p>1.状态转换</p>\n<ul>\n<li>主服务器执行服务</li>\n<li>主服务器项备服务器发送新的状态</li>\n</ul>\n<p>2.副本的状态机</p>\n<ul>\n<li>所有的副本执行所有的操作</li>\n<li>如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态</li>\n</ul>\n<p><strong>状态转换更简单</strong></p>\n<p>1.但是状态空间可能比较大，转换起来很慢</p>\n<p>2.VM-FT使用复制状态机</p>\n<p><strong>复制状态机是很高效的</strong></p>\n<p>1.与数据相比，如果操作很小，但要正确执行则很复杂</p>\n<p>例如：多核心处理器执行操作的顺序，确定性</p>\n<p>2.实验使用了复制状态机</p>\n<p><strong>什么是复制状态机？</strong></p>\n<p>1.K/V对的put和get操作</p>\n<p>2.x86指令集</p>\n<p>3.影响性能和易于实现</p>\n<ul>\n<li>主/备之间需要多少交互</li>\n<li>高度抽象的机器可以交互更少的信息</li>\n<li>在x86级别上处理不确定性很难，但在Put/Get级别上更容易实现</li>\n</ul>\n<p>4.高级RSM仅适用于使用高级接口的程序</p>\n<ul>\n<li>x86 RSM可以执行任意x86程序</li>\n</ul>\n<p><strong>一种实用的容错虚拟机系统设计</strong></p>\n<p>Scales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010</p>\n<p><strong>非常健壮的系统</strong></p>\n<p>1.整个系统复制</p>\n<p>2.对应用程序和客户端完全透明</p>\n<p>3.任何现有软件的高可用性</p>\n<p>4.如果它效果好的话会很神奇的</p>\n<p>5.失效模型：</p>\n<ul>\n<li>独立硬件故障</li>\n<li>全站停电</li>\n</ul>\n<p>6.仅限于单处理器虚拟机</p>\n<p>问题：多核处理器有什么困难</p>\n<p><strong>概述</strong></p>\n<p>1.两种机器，主和备，以及其他机器</p>\n<p>2.两种网络连接：客户端到服务器，日志交换的通道</p>\n<p>3.用于持久化存储的共享磁盘</p>\n<p>4.在“锁定步骤”中备份主</p>\n<ul>\n<li>主服务器将所有的输入发送到备份</li>\n<li>备份输出将被丢弃</li>\n</ul>\n<p>5.主和备之间保持心跳</p>\n<ul>\n<li>如果主失败，开始备执行</li>\n</ul>\n<p><strong>输入是什么？</strong></p>\n<p>1.时钟中断</p>\n<p>2.网络中断</p>\n<p>3.磁盘中断</p>\n<p><strong>挑战:</strong></p>\n<p>1.使整个系统看起来像一台可靠的服务器</p>\n<p>如果主服务器发生故障，副本接管，系统外部会看到什么？</p>\n<p>如果主服务器在发送响应之前或之后宕机，客户端的请求会丢失吗？还是执行两次？</p>\n<p>什么时候主服务器发送响应给客户端？</p>\n<p>2.如何避免两次初筛？</p>\n<p>如果日志记录通道中断怎么办？</p>\n<p>3.如何保证backup称为primary的精确副本（完全一致）</p>\n<p>哪些操作必须发送到副本</p>\n<p>时钟中断？</p>\n<p>如何处理非决定论</p>\n<p>例如：中断必须以主中断相同的指令在备份时发送</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>今天的主题</strong></p>\n<p>1.主/从复制</p>\n<ul>\n<li>广泛使用，例如GFS的区块服务器</li>\n<li>但是今天被广泛应用于强一致</li>\n<li>特别重要，我们需要深入探索它</li>\n</ul>\n<p>2.VM-FT案例的学习</p>\n<p><strong>容错性</strong></p>\n<p>1.我们需要构建一个即使失败也能继续的服务</p>\n<p>2.高可用：在一些失败后仍然可用</p>\n<p>3.强一致：对与客户端来说就像只有一个服一样，比GFS文件服务更加健壮。</p>\n<p>4.非常困难！</p>\n<p>5.非常有用！</p>\n<p><strong>需要一个服务失败模型：我们将尝试处理什么？</strong></p>\n<p>1.独立的故障，停止计算机的故障</p>\n<ul>\n<li>VM-FT假设一次只出现一个故障</li>\n</ul>\n<p>2.停电（最终重启）</p>\n<p>3.网络分区</p>\n<p>4.没有bugs，没有恶意攻击</p>\n<p><strong>核心的想法：复制</strong></p>\n<p>1.两台服务器</p>\n<p>2.每个副本保持着服务所需要的状态</p>\n<p>3.如果一个副本失效了，其他的可以继续提供服务</p>\n<p><strong>例子：MapReduce里面的matser模型</strong></p>\n<p>1.lab1里面的worker是高可用的，但是没有master</p>\n<ul>\n<li>master是单点故障的</li>\n</ul>\n<p>2.我们可以有两个master吗，在一个失败的情况下？</p>\n<p>[架构图：M1, M2, workers]</p>\n<p>状态：</p>\n<ul>\n<li>worker列表</li>\n<li>那些job做完了</li>\n<li>那些worker空闲</li>\n<li>TCP连接的状态</li>\n<li>程序计数器</li>\n</ul>\n<p><strong>大的问题</strong></p>\n<p>1.要复制的状态是什么？</p>\n<p>2.副本如何获得状态？</p>\n<p>3.何时切换到副本服务器？</p>\n<p>4.切换的时候是否会表现出异常状态？</p>\n<p>5.如何修复，重新集成？</p>\n<p><strong>两个主要的方法</strong></p>\n<p>1.状态转换</p>\n<ul>\n<li>主服务器执行服务</li>\n<li>主服务器项备服务器发送新的状态</li>\n</ul>\n<p>2.副本的状态机</p>\n<ul>\n<li>所有的副本执行所有的操作</li>\n<li>如果所有副本有相同的开始状态，相同的操作，相同的操作顺序，确定的方法，会的到最终相同的状态</li>\n</ul>\n<p><strong>状态转换更简单</strong></p>\n<p>1.但是状态空间可能比较大，转换起来很慢</p>\n<p>2.VM-FT使用复制状态机</p>\n<p><strong>复制状态机是很高效的</strong></p>\n<p>1.与数据相比，如果操作很小，但要正确执行则很复杂</p>\n<p>例如：多核心处理器执行操作的顺序，确定性</p>\n<p>2.实验使用了复制状态机</p>\n<p><strong>什么是复制状态机？</strong></p>\n<p>1.K/V对的put和get操作</p>\n<p>2.x86指令集</p>\n<p>3.影响性能和易于实现</p>\n<ul>\n<li>主/备之间需要多少交互</li>\n<li>高度抽象的机器可以交互更少的信息</li>\n<li>在x86级别上处理不确定性很难，但在Put/Get级别上更容易实现</li>\n</ul>\n<p>4.高级RSM仅适用于使用高级接口的程序</p>\n<ul>\n<li>x86 RSM可以执行任意x86程序</li>\n</ul>\n<p><strong>一种实用的容错虚拟机系统设计</strong></p>\n<p>Scales, Nelson, and Venkitachalam, SIGOPS OSR Vol 44, No 4, Dec 2010</p>\n<p><strong>非常健壮的系统</strong></p>\n<p>1.整个系统复制</p>\n<p>2.对应用程序和客户端完全透明</p>\n<p>3.任何现有软件的高可用性</p>\n<p>4.如果它效果好的话会很神奇的</p>\n<p>5.失效模型：</p>\n<ul>\n<li>独立硬件故障</li>\n<li>全站停电</li>\n</ul>\n<p>6.仅限于单处理器虚拟机</p>\n<p>问题：多核处理器有什么困难</p>\n<p><strong>概述</strong></p>\n<p>1.两种机器，主和备，以及其他机器</p>\n<p>2.两种网络连接：客户端到服务器，日志交换的通道</p>\n<p>3.用于持久化存储的共享磁盘</p>\n<p>4.在“锁定步骤”中备份主</p>\n<ul>\n<li>主服务器将所有的输入发送到备份</li>\n<li>备份输出将被丢弃</li>\n</ul>\n<p>5.主和备之间保持心跳</p>\n<ul>\n<li>如果主失败，开始备执行</li>\n</ul>\n<p><strong>输入是什么？</strong></p>\n<p>1.时钟中断</p>\n<p>2.网络中断</p>\n<p>3.磁盘中断</p>\n<p><strong>挑战:</strong></p>\n<p>1.使整个系统看起来像一台可靠的服务器</p>\n<p>如果主服务器发生故障，副本接管，系统外部会看到什么？</p>\n<p>如果主服务器在发送响应之前或之后宕机，客户端的请求会丢失吗？还是执行两次？</p>\n<p>什么时候主服务器发送响应给客户端？</p>\n<p>2.如何避免两次初筛？</p>\n<p>如果日志记录通道中断怎么办？</p>\n<p>3.如何保证backup称为primary的精确副本（完全一致）</p>\n<p>哪些操作必须发送到副本</p>\n<p>时钟中断？</p>\n<p>如何处理非决定论</p>\n<p>例如：中断必须以主中断相同的指令在备份时发送</p>\n"},{"title":"LEC6-vedio","date":"2019-01-17T01:36:22.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","source":"_posts/LEC6-vedio.md","raw":"---\ntitle: LEC6-vedio\ndate: 2019-01-17 09:36:22\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>\n\n","slug":"LEC6-vedio","published":1,"updated":"2019-06-26T11:56:34.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyog001lvkqp3ya9v229","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613070&page=12\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>\n\n"},{"title":"LEC5-vedio","date":"2019-01-17T01:36:18.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC5-vedio.md","raw":"---\ntitle: LEC5-vedio\ndate: 2019-01-17 09:36:18\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC5-vedio","published":1,"updated":"2019-06-26T11:56:34.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyoh001nvkqpn7bf2a72","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613007&page=11\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC7-vedio","date":"2019-01-17T01:36:27.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC7-vedio.md","raw":"---\ntitle: LEC7-vedio\ndate: 2019-01-17 09:36:27\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC7-vedio","published":1,"updated":"2019-06-26T11:56:34.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyoi001pvkqpdvd48jor","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613132&page=13\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC8-vedio","date":"2019-01-17T01:36:32.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC8-vedio.md","raw":"---\ntitle: LEC8-vedio\ndate: 2019-01-17 09:36:32\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC8-vedio","published":1,"updated":"2019-06-26T11:56:34.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyoj001rvkqps48t2em9","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"LEC9-vedio","date":"2019-01-17T01:36:36.000Z","_content":"\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","source":"_posts/LEC9-vedio.md","raw":"---\ntitle: LEC9-vedio\ndate: 2019-01-17 09:36:36\ntags: 6.824视频\n---\n\n<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=600 height=440> </iframe>","slug":"LEC9-vedio","published":1,"updated":"2019-06-26T11:56:34.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyok001tvkqpjhshm9if","content":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>","site":{"data":{}},"excerpt":"","more":"<iframe src=\"//player.bilibili.com/player.html?aid=24223728&cid=40613192&page=14\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"600\" height=\"440\"> </iframe>"},{"title":"grpc使用","date":"2019-03-31T08:12:23.000Z","_content":"\n**关于Rpc**\n\n- Rpc的全程是 Remote Procedure Call，它是一种进程间的通信方式。允许像调用本地服务一样调用远程服务，它的具体实现方式可以不同，例如Spring的HTTP Invoker，Facebook的Thrift二进制私有协议通信和Google的高性能RPC框架gRPC。\n\n- RPC框架特点:\n  - 简单：RPC概念的语义十分简单和清晰，这样建立分布式计算就更容易。\n  - 高效：过程调用看起来十分简单高效。\n  - 通用：在单机计算中过程往往是不同算法和API，跨进程调用最重要的是通用的通信机制。\n\n**gRPC**\n\n- gRPC是一个高性能、通用的开源RPC框架，其中Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf（Protocol Buffers）序列化协议开发，支撑众多开发语言。gRPC基于HTTP/2标准设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。\n- gRPC目前提供C、Java和Go语言版本，这三个版本的源码全部托管在Github上，分别是grpc、grpc-java、grpc-go。其中C版本支持C、C++、Node.js、Ruby、OC、PHP、C#等。\n\n- gRPC框架的主要特性\n  - 支持Protobuf:gRPC使用ProtoBuf的IDL(.proto)来定义数据结构和服务。Protobuf是一个灵活、高效、结构化的数据序列化框架，相比于XML等传统的序列化工具，它更小、更快、更简单。Protobuf支持数据结构化一次可以到处使用，甚至跨语言使用，通过代码生成工具可以自动生成不同语言版本的源代码，甚至可以在使用不同版本的数据结构和结构进程进行数据传递，实现数据结构的前向兼容。目前gRPC仅支持Protobuf，且不支持在浏览器中使用。由于gRPC的设计能够支持多种数据格式，所以读者能够很容易实现对其他数据格式(XML,JSON等)的支持。\n  - 支持多种语言：gRPC支持多种语言，并能够根据语言类型自动生成客户端和服务端代码，grpc-java已经支持安卓开发。\n  - 基于HTTP/2设计：由于gRPC基于HTTP/2标准设计，所以相对于其他的RPC框架，gRPC带来了更多强大功能，如双向流、头部压缩、多复用请求等。这些功能给移动设备带来重大益处，如节省带宽、降低TCP链接次数、节省CPU使用和延长电池寿命等。同时，gRPC还能够提高了云端服务和Web应用的性能，gRPC即能在客户端应用，也能够在服务端应用，从而以透明的方式实验客户端和服务端的通信和简化通信系统的构建。\n\n**Go使用grpc开发Demo**\n\n- 安装grpc-go，这里在国内会timeout，可以通过\"科学上网\"的方式解决\n\n  ```\n  go get google.golang.org/grpc\n  ```\n\n- 安装Protocol Buffers v3\n\n  去<https://github.com/google/protobuf/releases>下载最新的稳定的版本，然后解压缩，把里面的文件放到`$PATH`中\n\n- 安装插件\n\n  ```\n  go get -u github.com/golang/protobuf/{proto,protoc-gen-go}\n  ```\n\n- 把`$GOPATH/bin`添加到`$PATH`中:\n\n  ```\n  export PATH=$PATH:$GOPATH/bin\n  ```\n\n- 示例代码结构\n\n  ```\n  |kv_demo\n  ├── kvrpc\n  │   ├── kvrpc.pb.go\n  │   ├── kvrpc.proto\n  ├── test_client.go\n  └── test_server.go\n  ```\n\n- 示例代码里面有三个重要文件，kvrpc.proto是协议文件，test_client.go是客户端代码、test_server.go是服务端代码。\n\n- kvrpc.proto，协议中定义了四个结构体KVRequest，VRequest，Status，ValueReply，KVRequest是Post请求参数返回Status反应请求是否成功。VRequest是Get请求参数，ValueReply返回取到的值。\n\n  ```\n  syntax = \"proto3\";\n  \n  package kvrpc;\n  \n  service Api {\n      rpc PostKV (KVRequest) returns (Status) {}\n      rpc GetV (VRequest) returns (ValueReply) {}\n  }\n  \n  message KVRequest {\n      string key = 1;\n      string value = 2;\n  }\n  \n  message VRequest {\n      string key = 1;\n  }\n  \n  message Status {\n      string isok = 1;\n  }\n  \n  message ValueReply {\n      string value = 1;\n  }\n  ```\n\n- 我们来看服务端代码\n\n  ```\n  package main\n  \n  import (\n      \"golang.org/x/net/context\"\n      \"google.golang.org/grpc\"\n      \"google.golang.org/grpc/reflection\"\n      pb \"github.com/turingkv/kvrpc\"\n      \"net\"\n      \"log\"\n  )\n  \n  type RServer struct{}\n  \n  func (s *RServer) PostKV(ctx context.Context, in *pb.KVRequest) (*pb.Status, error) {\n  \n      return &pb.Status{Isok: \"yes\"}, nil\n  }\n  \n  func (s *RServer) GetV(ctx context.Context, in *pb.VRequest) (*pb.ValueReply, error) {\n  \n      return &pb.ValueReply{Value: \"testvalue\"}, nil\n  }\n  \n  func main(){\n  \t  //tcp监听端口\n        lis, _ := net.Listen(\"tcp\", \":8000\")\n        log.Printf(\"Sever listen on: %d\", 8000)\n        //新建服务器\n        s := grpc.NewServer()\n        //注册服务\n        pb.RegisterApiServer(s, &RServer{})\n        reflection.Register(s)\n        s.Serve(lis)\n  }\n  ```\n\n- 再来看客户端代码\n\n  ```\n  package main\n  \n  import (\n      \"golang.org/x/net/context\"\n      \"google.golang.org/grpc\"\n      pb \"github.com/turingkv/kvrpc\"\n      \"log\"\n  )\n  \n  func main(){\n      conn, err := grpc.Dial(\"127.0.0.1:8000\", grpc.WithInsecure())\n          if err != nil {\n          log.Fatalf(\"did not connect: %v\", err)\n      }\n      defer conn.Close()\n      c := pb.NewApiClient(conn)\n  \n      r, err := c.PostKV(context.Background(), &pb.KVRequest{Key:\"key\", Value:\"hello turingturing\"})\n      if err != nil {\n          log.Fatalf(\"could not greet: %v\", err)\n      }\n      log.Printf(\"Set Value Status: %s\", r.Isok)\n  \n      r_, err := c.GetV(context.Background(), &pb.VRequest{Key:\"key\"})\n      if err != nil {\n          log.Fatalf(\"could not greet: %v\", err)\n      }\n      log.Printf(\"Get Value: %s\", r_.Value)\n  }\n  ```\n\n- 测试结果\n\n  ```\n  //服务端\n  [root@node1 turingkv]# go run test_server.go \n  2019/04/07 01:53:28 Sever listen on: 8000\n  \n  //客户端\n  [root@node1 turingkv]# go run test_client.go \n  2019/04/07 01:51:28 Set Value Status: yes\n  2019/04/07 01:51:28 Get Value: testvalue\n  ```","source":"_posts/grpc使用.md","raw":"---\ntitle: grpc使用\ndate: 2019-03-31 16:12:23\ntags:\n---\n\n**关于Rpc**\n\n- Rpc的全程是 Remote Procedure Call，它是一种进程间的通信方式。允许像调用本地服务一样调用远程服务，它的具体实现方式可以不同，例如Spring的HTTP Invoker，Facebook的Thrift二进制私有协议通信和Google的高性能RPC框架gRPC。\n\n- RPC框架特点:\n  - 简单：RPC概念的语义十分简单和清晰，这样建立分布式计算就更容易。\n  - 高效：过程调用看起来十分简单高效。\n  - 通用：在单机计算中过程往往是不同算法和API，跨进程调用最重要的是通用的通信机制。\n\n**gRPC**\n\n- gRPC是一个高性能、通用的开源RPC框架，其中Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf（Protocol Buffers）序列化协议开发，支撑众多开发语言。gRPC基于HTTP/2标准设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。\n- gRPC目前提供C、Java和Go语言版本，这三个版本的源码全部托管在Github上，分别是grpc、grpc-java、grpc-go。其中C版本支持C、C++、Node.js、Ruby、OC、PHP、C#等。\n\n- gRPC框架的主要特性\n  - 支持Protobuf:gRPC使用ProtoBuf的IDL(.proto)来定义数据结构和服务。Protobuf是一个灵活、高效、结构化的数据序列化框架，相比于XML等传统的序列化工具，它更小、更快、更简单。Protobuf支持数据结构化一次可以到处使用，甚至跨语言使用，通过代码生成工具可以自动生成不同语言版本的源代码，甚至可以在使用不同版本的数据结构和结构进程进行数据传递，实现数据结构的前向兼容。目前gRPC仅支持Protobuf，且不支持在浏览器中使用。由于gRPC的设计能够支持多种数据格式，所以读者能够很容易实现对其他数据格式(XML,JSON等)的支持。\n  - 支持多种语言：gRPC支持多种语言，并能够根据语言类型自动生成客户端和服务端代码，grpc-java已经支持安卓开发。\n  - 基于HTTP/2设计：由于gRPC基于HTTP/2标准设计，所以相对于其他的RPC框架，gRPC带来了更多强大功能，如双向流、头部压缩、多复用请求等。这些功能给移动设备带来重大益处，如节省带宽、降低TCP链接次数、节省CPU使用和延长电池寿命等。同时，gRPC还能够提高了云端服务和Web应用的性能，gRPC即能在客户端应用，也能够在服务端应用，从而以透明的方式实验客户端和服务端的通信和简化通信系统的构建。\n\n**Go使用grpc开发Demo**\n\n- 安装grpc-go，这里在国内会timeout，可以通过\"科学上网\"的方式解决\n\n  ```\n  go get google.golang.org/grpc\n  ```\n\n- 安装Protocol Buffers v3\n\n  去<https://github.com/google/protobuf/releases>下载最新的稳定的版本，然后解压缩，把里面的文件放到`$PATH`中\n\n- 安装插件\n\n  ```\n  go get -u github.com/golang/protobuf/{proto,protoc-gen-go}\n  ```\n\n- 把`$GOPATH/bin`添加到`$PATH`中:\n\n  ```\n  export PATH=$PATH:$GOPATH/bin\n  ```\n\n- 示例代码结构\n\n  ```\n  |kv_demo\n  ├── kvrpc\n  │   ├── kvrpc.pb.go\n  │   ├── kvrpc.proto\n  ├── test_client.go\n  └── test_server.go\n  ```\n\n- 示例代码里面有三个重要文件，kvrpc.proto是协议文件，test_client.go是客户端代码、test_server.go是服务端代码。\n\n- kvrpc.proto，协议中定义了四个结构体KVRequest，VRequest，Status，ValueReply，KVRequest是Post请求参数返回Status反应请求是否成功。VRequest是Get请求参数，ValueReply返回取到的值。\n\n  ```\n  syntax = \"proto3\";\n  \n  package kvrpc;\n  \n  service Api {\n      rpc PostKV (KVRequest) returns (Status) {}\n      rpc GetV (VRequest) returns (ValueReply) {}\n  }\n  \n  message KVRequest {\n      string key = 1;\n      string value = 2;\n  }\n  \n  message VRequest {\n      string key = 1;\n  }\n  \n  message Status {\n      string isok = 1;\n  }\n  \n  message ValueReply {\n      string value = 1;\n  }\n  ```\n\n- 我们来看服务端代码\n\n  ```\n  package main\n  \n  import (\n      \"golang.org/x/net/context\"\n      \"google.golang.org/grpc\"\n      \"google.golang.org/grpc/reflection\"\n      pb \"github.com/turingkv/kvrpc\"\n      \"net\"\n      \"log\"\n  )\n  \n  type RServer struct{}\n  \n  func (s *RServer) PostKV(ctx context.Context, in *pb.KVRequest) (*pb.Status, error) {\n  \n      return &pb.Status{Isok: \"yes\"}, nil\n  }\n  \n  func (s *RServer) GetV(ctx context.Context, in *pb.VRequest) (*pb.ValueReply, error) {\n  \n      return &pb.ValueReply{Value: \"testvalue\"}, nil\n  }\n  \n  func main(){\n  \t  //tcp监听端口\n        lis, _ := net.Listen(\"tcp\", \":8000\")\n        log.Printf(\"Sever listen on: %d\", 8000)\n        //新建服务器\n        s := grpc.NewServer()\n        //注册服务\n        pb.RegisterApiServer(s, &RServer{})\n        reflection.Register(s)\n        s.Serve(lis)\n  }\n  ```\n\n- 再来看客户端代码\n\n  ```\n  package main\n  \n  import (\n      \"golang.org/x/net/context\"\n      \"google.golang.org/grpc\"\n      pb \"github.com/turingkv/kvrpc\"\n      \"log\"\n  )\n  \n  func main(){\n      conn, err := grpc.Dial(\"127.0.0.1:8000\", grpc.WithInsecure())\n          if err != nil {\n          log.Fatalf(\"did not connect: %v\", err)\n      }\n      defer conn.Close()\n      c := pb.NewApiClient(conn)\n  \n      r, err := c.PostKV(context.Background(), &pb.KVRequest{Key:\"key\", Value:\"hello turingturing\"})\n      if err != nil {\n          log.Fatalf(\"could not greet: %v\", err)\n      }\n      log.Printf(\"Set Value Status: %s\", r.Isok)\n  \n      r_, err := c.GetV(context.Background(), &pb.VRequest{Key:\"key\"})\n      if err != nil {\n          log.Fatalf(\"could not greet: %v\", err)\n      }\n      log.Printf(\"Get Value: %s\", r_.Value)\n  }\n  ```\n\n- 测试结果\n\n  ```\n  //服务端\n  [root@node1 turingkv]# go run test_server.go \n  2019/04/07 01:53:28 Sever listen on: 8000\n  \n  //客户端\n  [root@node1 turingkv]# go run test_client.go \n  2019/04/07 01:51:28 Set Value Status: yes\n  2019/04/07 01:51:28 Get Value: testvalue\n  ```","slug":"grpc使用","published":1,"updated":"2019-06-26T11:56:34.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyol001vvkqph62k57ut","content":"<p><strong>关于Rpc</strong></p>\n<ul>\n<li><p>Rpc的全程是 Remote Procedure Call，它是一种进程间的通信方式。允许像调用本地服务一样调用远程服务，它的具体实现方式可以不同，例如Spring的HTTP Invoker，Facebook的Thrift二进制私有协议通信和Google的高性能RPC框架gRPC。</p>\n</li>\n<li><p>RPC框架特点:</p>\n<ul>\n<li>简单：RPC概念的语义十分简单和清晰，这样建立分布式计算就更容易。</li>\n<li>高效：过程调用看起来十分简单高效。</li>\n<li>通用：在单机计算中过程往往是不同算法和API，跨进程调用最重要的是通用的通信机制。</li>\n</ul>\n</li>\n</ul>\n<p><strong>gRPC</strong></p>\n<ul>\n<li>gRPC是一个高性能、通用的开源RPC框架，其中Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf（Protocol Buffers）序列化协议开发，支撑众多开发语言。gRPC基于HTTP/2标准设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</li>\n<li><p>gRPC目前提供C、Java和Go语言版本，这三个版本的源码全部托管在Github上，分别是grpc、grpc-java、grpc-go。其中C版本支持C、C++、Node.js、Ruby、OC、PHP、C#等。</p>\n</li>\n<li><p>gRPC框架的主要特性</p>\n<ul>\n<li>支持Protobuf:gRPC使用ProtoBuf的IDL(.proto)来定义数据结构和服务。Protobuf是一个灵活、高效、结构化的数据序列化框架，相比于XML等传统的序列化工具，它更小、更快、更简单。Protobuf支持数据结构化一次可以到处使用，甚至跨语言使用，通过代码生成工具可以自动生成不同语言版本的源代码，甚至可以在使用不同版本的数据结构和结构进程进行数据传递，实现数据结构的前向兼容。目前gRPC仅支持Protobuf，且不支持在浏览器中使用。由于gRPC的设计能够支持多种数据格式，所以读者能够很容易实现对其他数据格式(XML,JSON等)的支持。</li>\n<li>支持多种语言：gRPC支持多种语言，并能够根据语言类型自动生成客户端和服务端代码，grpc-java已经支持安卓开发。</li>\n<li>基于HTTP/2设计：由于gRPC基于HTTP/2标准设计，所以相对于其他的RPC框架，gRPC带来了更多强大功能，如双向流、头部压缩、多复用请求等。这些功能给移动设备带来重大益处，如节省带宽、降低TCP链接次数、节省CPU使用和延长电池寿命等。同时，gRPC还能够提高了云端服务和Web应用的性能，gRPC即能在客户端应用，也能够在服务端应用，从而以透明的方式实验客户端和服务端的通信和简化通信系统的构建。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Go使用grpc开发Demo</strong></p>\n<ul>\n<li><p>安装grpc-go，这里在国内会timeout，可以通过”科学上网”的方式解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get google.golang.org/grpc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装Protocol Buffers v3</p>\n<p>去<a href=\"https://github.com/google/protobuf/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/google/protobuf/releases</a>下载最新的稳定的版本，然后解压缩，把里面的文件放到<code>$PATH</code>中</p>\n</li>\n<li><p>安装插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把<code>$GOPATH/bin</code>添加到<code>$PATH</code>中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例代码结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|kv_demo</span><br><span class=\"line\">├── kvrpc</span><br><span class=\"line\">│   ├── kvrpc.pb.go</span><br><span class=\"line\">│   ├── kvrpc.proto</span><br><span class=\"line\">├── test_client.go</span><br><span class=\"line\">└── test_server.go</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例代码里面有三个重要文件，kvrpc.proto是协议文件，test_client.go是客户端代码、test_server.go是服务端代码。</p>\n</li>\n<li><p>kvrpc.proto，协议中定义了四个结构体KVRequest，VRequest，Status，ValueReply，KVRequest是Post请求参数返回Status反应请求是否成功。VRequest是Get请求参数，ValueReply返回取到的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">package kvrpc;</span><br><span class=\"line\"></span><br><span class=\"line\">service Api &#123;</span><br><span class=\"line\">    rpc PostKV (KVRequest) returns (Status) &#123;&#125;</span><br><span class=\"line\">    rpc GetV (VRequest) returns (ValueReply) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message KVRequest &#123;</span><br><span class=\"line\">    string key = 1;</span><br><span class=\"line\">    string value = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message VRequest &#123;</span><br><span class=\"line\">    string key = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message Status &#123;</span><br><span class=\"line\">    string isok = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message ValueReply &#123;</span><br><span class=\"line\">    string value = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我们来看服务端代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;golang.org/x/net/context&quot;</span><br><span class=\"line\">    &quot;google.golang.org/grpc&quot;</span><br><span class=\"line\">    &quot;google.golang.org/grpc/reflection&quot;</span><br><span class=\"line\">    pb &quot;github.com/turingkv/kvrpc&quot;</span><br><span class=\"line\">    &quot;net&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type RServer struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *RServer) PostKV(ctx context.Context, in *pb.KVRequest) (*pb.Status, error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &amp;pb.Status&#123;Isok: &quot;yes&quot;&#125;, nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *RServer) GetV(ctx context.Context, in *pb.VRequest) (*pb.ValueReply, error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &amp;pb.ValueReply&#123;Value: &quot;testvalue&quot;&#125;, nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main()&#123;</span><br><span class=\"line\">\t  //tcp监听端口</span><br><span class=\"line\">      lis, _ := net.Listen(&quot;tcp&quot;, &quot;:8000&quot;)</span><br><span class=\"line\">      log.Printf(&quot;Sever listen on: %d&quot;, 8000)</span><br><span class=\"line\">      //新建服务器</span><br><span class=\"line\">      s := grpc.NewServer()</span><br><span class=\"line\">      //注册服务</span><br><span class=\"line\">      pb.RegisterApiServer(s, &amp;RServer&#123;&#125;)</span><br><span class=\"line\">      reflection.Register(s)</span><br><span class=\"line\">      s.Serve(lis)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再来看客户端代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;golang.org/x/net/context&quot;</span><br><span class=\"line\">    &quot;google.golang.org/grpc&quot;</span><br><span class=\"line\">    pb &quot;github.com/turingkv/kvrpc&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    conn, err := grpc.Dial(&quot;127.0.0.1:8000&quot;, grpc.WithInsecure())</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">        log.Fatalf(&quot;did not connect: %v&quot;, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    defer conn.Close()</span><br><span class=\"line\">    c := pb.NewApiClient(conn)</span><br><span class=\"line\"></span><br><span class=\"line\">    r, err := c.PostKV(context.Background(), &amp;pb.KVRequest&#123;Key:&quot;key&quot;, Value:&quot;hello turingturing&quot;&#125;)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        log.Fatalf(&quot;could not greet: %v&quot;, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.Printf(&quot;Set Value Status: %s&quot;, r.Isok)</span><br><span class=\"line\"></span><br><span class=\"line\">    r_, err := c.GetV(context.Background(), &amp;pb.VRequest&#123;Key:&quot;key&quot;&#125;)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        log.Fatalf(&quot;could not greet: %v&quot;, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.Printf(&quot;Get Value: %s&quot;, r_.Value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//服务端</span><br><span class=\"line\">[root@node1 turingkv]# go run test_server.go </span><br><span class=\"line\">2019/04/07 01:53:28 Sever listen on: 8000</span><br><span class=\"line\"></span><br><span class=\"line\">//客户端</span><br><span class=\"line\">[root@node1 turingkv]# go run test_client.go </span><br><span class=\"line\">2019/04/07 01:51:28 Set Value Status: yes</span><br><span class=\"line\">2019/04/07 01:51:28 Get Value: testvalue</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>关于Rpc</strong></p>\n<ul>\n<li><p>Rpc的全程是 Remote Procedure Call，它是一种进程间的通信方式。允许像调用本地服务一样调用远程服务，它的具体实现方式可以不同，例如Spring的HTTP Invoker，Facebook的Thrift二进制私有协议通信和Google的高性能RPC框架gRPC。</p>\n</li>\n<li><p>RPC框架特点:</p>\n<ul>\n<li>简单：RPC概念的语义十分简单和清晰，这样建立分布式计算就更容易。</li>\n<li>高效：过程调用看起来十分简单高效。</li>\n<li>通用：在单机计算中过程往往是不同算法和API，跨进程调用最重要的是通用的通信机制。</li>\n</ul>\n</li>\n</ul>\n<p><strong>gRPC</strong></p>\n<ul>\n<li>gRPC是一个高性能、通用的开源RPC框架，其中Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf（Protocol Buffers）序列化协议开发，支撑众多开发语言。gRPC基于HTTP/2标准设计，带来诸如双向流、流控、头部压缩、单TCP连接上的多复用请求等特性。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</li>\n<li><p>gRPC目前提供C、Java和Go语言版本，这三个版本的源码全部托管在Github上，分别是grpc、grpc-java、grpc-go。其中C版本支持C、C++、Node.js、Ruby、OC、PHP、C#等。</p>\n</li>\n<li><p>gRPC框架的主要特性</p>\n<ul>\n<li>支持Protobuf:gRPC使用ProtoBuf的IDL(.proto)来定义数据结构和服务。Protobuf是一个灵活、高效、结构化的数据序列化框架，相比于XML等传统的序列化工具，它更小、更快、更简单。Protobuf支持数据结构化一次可以到处使用，甚至跨语言使用，通过代码生成工具可以自动生成不同语言版本的源代码，甚至可以在使用不同版本的数据结构和结构进程进行数据传递，实现数据结构的前向兼容。目前gRPC仅支持Protobuf，且不支持在浏览器中使用。由于gRPC的设计能够支持多种数据格式，所以读者能够很容易实现对其他数据格式(XML,JSON等)的支持。</li>\n<li>支持多种语言：gRPC支持多种语言，并能够根据语言类型自动生成客户端和服务端代码，grpc-java已经支持安卓开发。</li>\n<li>基于HTTP/2设计：由于gRPC基于HTTP/2标准设计，所以相对于其他的RPC框架，gRPC带来了更多强大功能，如双向流、头部压缩、多复用请求等。这些功能给移动设备带来重大益处，如节省带宽、降低TCP链接次数、节省CPU使用和延长电池寿命等。同时，gRPC还能够提高了云端服务和Web应用的性能，gRPC即能在客户端应用，也能够在服务端应用，从而以透明的方式实验客户端和服务端的通信和简化通信系统的构建。</li>\n</ul>\n</li>\n</ul>\n<p><strong>Go使用grpc开发Demo</strong></p>\n<ul>\n<li><p>安装grpc-go，这里在国内会timeout，可以通过”科学上网”的方式解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get google.golang.org/grpc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>安装Protocol Buffers v3</p>\n<p>去<a href=\"https://github.com/google/protobuf/releases\" target=\"_blank\" rel=\"noopener\">https://github.com/google/protobuf/releases</a>下载最新的稳定的版本，然后解压缩，把里面的文件放到<code>$PATH</code>中</p>\n</li>\n<li><p>安装插件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>把<code>$GOPATH/bin</code>添加到<code>$PATH</code>中:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例代码结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">|kv_demo</span><br><span class=\"line\">├── kvrpc</span><br><span class=\"line\">│   ├── kvrpc.pb.go</span><br><span class=\"line\">│   ├── kvrpc.proto</span><br><span class=\"line\">├── test_client.go</span><br><span class=\"line\">└── test_server.go</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>示例代码里面有三个重要文件，kvrpc.proto是协议文件，test_client.go是客户端代码、test_server.go是服务端代码。</p>\n</li>\n<li><p>kvrpc.proto，协议中定义了四个结构体KVRequest，VRequest，Status，ValueReply，KVRequest是Post请求参数返回Status反应请求是否成功。VRequest是Get请求参数，ValueReply返回取到的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">package kvrpc;</span><br><span class=\"line\"></span><br><span class=\"line\">service Api &#123;</span><br><span class=\"line\">    rpc PostKV (KVRequest) returns (Status) &#123;&#125;</span><br><span class=\"line\">    rpc GetV (VRequest) returns (ValueReply) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message KVRequest &#123;</span><br><span class=\"line\">    string key = 1;</span><br><span class=\"line\">    string value = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message VRequest &#123;</span><br><span class=\"line\">    string key = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message Status &#123;</span><br><span class=\"line\">    string isok = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message ValueReply &#123;</span><br><span class=\"line\">    string value = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>我们来看服务端代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;golang.org/x/net/context&quot;</span><br><span class=\"line\">    &quot;google.golang.org/grpc&quot;</span><br><span class=\"line\">    &quot;google.golang.org/grpc/reflection&quot;</span><br><span class=\"line\">    pb &quot;github.com/turingkv/kvrpc&quot;</span><br><span class=\"line\">    &quot;net&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">type RServer struct&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *RServer) PostKV(ctx context.Context, in *pb.KVRequest) (*pb.Status, error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &amp;pb.Status&#123;Isok: &quot;yes&quot;&#125;, nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (s *RServer) GetV(ctx context.Context, in *pb.VRequest) (*pb.ValueReply, error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return &amp;pb.ValueReply&#123;Value: &quot;testvalue&quot;&#125;, nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main()&#123;</span><br><span class=\"line\">\t  //tcp监听端口</span><br><span class=\"line\">      lis, _ := net.Listen(&quot;tcp&quot;, &quot;:8000&quot;)</span><br><span class=\"line\">      log.Printf(&quot;Sever listen on: %d&quot;, 8000)</span><br><span class=\"line\">      //新建服务器</span><br><span class=\"line\">      s := grpc.NewServer()</span><br><span class=\"line\">      //注册服务</span><br><span class=\"line\">      pb.RegisterApiServer(s, &amp;RServer&#123;&#125;)</span><br><span class=\"line\">      reflection.Register(s)</span><br><span class=\"line\">      s.Serve(lis)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再来看客户端代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import (</span><br><span class=\"line\">    &quot;golang.org/x/net/context&quot;</span><br><span class=\"line\">    &quot;google.golang.org/grpc&quot;</span><br><span class=\"line\">    pb &quot;github.com/turingkv/kvrpc&quot;</span><br><span class=\"line\">    &quot;log&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">func main()&#123;</span><br><span class=\"line\">    conn, err := grpc.Dial(&quot;127.0.0.1:8000&quot;, grpc.WithInsecure())</span><br><span class=\"line\">        if err != nil &#123;</span><br><span class=\"line\">        log.Fatalf(&quot;did not connect: %v&quot;, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    defer conn.Close()</span><br><span class=\"line\">    c := pb.NewApiClient(conn)</span><br><span class=\"line\"></span><br><span class=\"line\">    r, err := c.PostKV(context.Background(), &amp;pb.KVRequest&#123;Key:&quot;key&quot;, Value:&quot;hello turingturing&quot;&#125;)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        log.Fatalf(&quot;could not greet: %v&quot;, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.Printf(&quot;Set Value Status: %s&quot;, r.Isok)</span><br><span class=\"line\"></span><br><span class=\"line\">    r_, err := c.GetV(context.Background(), &amp;pb.VRequest&#123;Key:&quot;key&quot;&#125;)</span><br><span class=\"line\">    if err != nil &#123;</span><br><span class=\"line\">        log.Fatalf(&quot;could not greet: %v&quot;, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    log.Printf(&quot;Get Value: %s&quot;, r_.Value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试结果</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//服务端</span><br><span class=\"line\">[root@node1 turingkv]# go run test_server.go </span><br><span class=\"line\">2019/04/07 01:53:28 Sever listen on: 8000</span><br><span class=\"line\"></span><br><span class=\"line\">//客户端</span><br><span class=\"line\">[root@node1 turingkv]# go run test_client.go </span><br><span class=\"line\">2019/04/07 01:51:28 Set Value Status: yes</span><br><span class=\"line\">2019/04/07 01:51:28 Get Value: testvalue</span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"一些管用的配置","date":"2019-06-29T04:23:11.000Z","_content":"\n- Linux终端看世界，涉及到软件，shadowsocks，polipo，关键配置如下\n\nss配置\n\n```\nsslocal -s 11.22.33.44 -p 50003 -k \"123456\" -l 1080 -t 600 -m aes-256-cfb\n-s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加\"\"）, -t超时默认300,-m是加密方法默认aes-256-cfb，\n```\n\npolipo配置-(默认路径 /etc/polipo/config)\n\n```\n# This file only needs to list configuration variables that deviate\n# from the default values.  See /usr/share/doc/polipo/examples/config.sample\n# and \"polipo -v\" for variables you can tweak and further information.\nlogSyslog = false\nlogFile = \"/var/log/polipo/polipo.log\"\n \nsocksParentProxy = \"127.0.0.1:1080\"\nsocksProxyType = socks5\n \nchunkHighMark = 50331648\nobjectHighMark = 16384\n \nserverMaxSlots = 64\nserverSlots = 16\nserverSlots1 = 32\n \nproxyAddress = \"0.0.0.0\"\nproxyPort = 8123\n```\n\n```\n/etc/init.d/polipo restart\n```\n\n- vim必备良药，git地址\n\nhttps://github.com/ycm-core/YouCompleteMe.git\n\n\n\n","source":"_posts/一些管用的配置.md","raw":"---\ntitle: 一些管用的配置\ndate: 2019-06-29 12:23:11\ntags: 各种开发必要的配置摘记\n---\n\n- Linux终端看世界，涉及到软件，shadowsocks，polipo，关键配置如下\n\nss配置\n\n```\nsslocal -s 11.22.33.44 -p 50003 -k \"123456\" -l 1080 -t 600 -m aes-256-cfb\n-s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加\"\"）, -t超时默认300,-m是加密方法默认aes-256-cfb，\n```\n\npolipo配置-(默认路径 /etc/polipo/config)\n\n```\n# This file only needs to list configuration variables that deviate\n# from the default values.  See /usr/share/doc/polipo/examples/config.sample\n# and \"polipo -v\" for variables you can tweak and further information.\nlogSyslog = false\nlogFile = \"/var/log/polipo/polipo.log\"\n \nsocksParentProxy = \"127.0.0.1:1080\"\nsocksProxyType = socks5\n \nchunkHighMark = 50331648\nobjectHighMark = 16384\n \nserverMaxSlots = 64\nserverSlots = 16\nserverSlots1 = 32\n \nproxyAddress = \"0.0.0.0\"\nproxyPort = 8123\n```\n\n```\n/etc/init.d/polipo restart\n```\n\n- vim必备良药，git地址\n\nhttps://github.com/ycm-core/YouCompleteMe.git\n\n\n\n","slug":"一些管用的配置","published":1,"updated":"2019-06-29T05:11:47.157Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyom001xvkqp9397z727","content":"<ul>\n<li>Linux终端看世界，涉及到软件，shadowsocks，polipo，关键配置如下</li>\n</ul>\n<p>ss配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sslocal -s 11.22.33.44 -p 50003 -k &quot;123456&quot; -l 1080 -t 600 -m aes-256-cfb</span><br><span class=\"line\">-s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加&quot;&quot;）, -t超时默认300,-m是加密方法默认aes-256-cfb，</span><br></pre></td></tr></table></figure>\n<p>polipo配置-(默认路径 /etc/polipo/config)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># This file only needs to list configuration variables that deviate</span><br><span class=\"line\"># from the default values.  See /usr/share/doc/polipo/examples/config.sample</span><br><span class=\"line\"># and &quot;polipo -v&quot; for variables you can tweak and further information.</span><br><span class=\"line\">logSyslog = false</span><br><span class=\"line\">logFile = &quot;/var/log/polipo/polipo.log&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">socksParentProxy = &quot;127.0.0.1:1080&quot;</span><br><span class=\"line\">socksProxyType = socks5</span><br><span class=\"line\"> </span><br><span class=\"line\">chunkHighMark = 50331648</span><br><span class=\"line\">objectHighMark = 16384</span><br><span class=\"line\"> </span><br><span class=\"line\">serverMaxSlots = 64</span><br><span class=\"line\">serverSlots = 16</span><br><span class=\"line\">serverSlots1 = 32</span><br><span class=\"line\"> </span><br><span class=\"line\">proxyAddress = &quot;0.0.0.0&quot;</span><br><span class=\"line\">proxyPort = 8123</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/polipo restart</span><br></pre></td></tr></table></figure>\n<ul>\n<li>vim必备良药，git地址</li>\n</ul>\n<p><a href=\"https://github.com/ycm-core/YouCompleteMe.git\" target=\"_blank\" rel=\"noopener\">https://github.com/ycm-core/YouCompleteMe.git</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>Linux终端看世界，涉及到软件，shadowsocks，polipo，关键配置如下</li>\n</ul>\n<p>ss配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sslocal -s 11.22.33.44 -p 50003 -k &quot;123456&quot; -l 1080 -t 600 -m aes-256-cfb</span><br><span class=\"line\">-s表示服务IP, -p指的是服务端的端口，-l是本地端口默认是1080, -k 是密码（要加&quot;&quot;）, -t超时默认300,-m是加密方法默认aes-256-cfb，</span><br></pre></td></tr></table></figure>\n<p>polipo配置-(默认路径 /etc/polipo/config)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># This file only needs to list configuration variables that deviate</span><br><span class=\"line\"># from the default values.  See /usr/share/doc/polipo/examples/config.sample</span><br><span class=\"line\"># and &quot;polipo -v&quot; for variables you can tweak and further information.</span><br><span class=\"line\">logSyslog = false</span><br><span class=\"line\">logFile = &quot;/var/log/polipo/polipo.log&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">socksParentProxy = &quot;127.0.0.1:1080&quot;</span><br><span class=\"line\">socksProxyType = socks5</span><br><span class=\"line\"> </span><br><span class=\"line\">chunkHighMark = 50331648</span><br><span class=\"line\">objectHighMark = 16384</span><br><span class=\"line\"> </span><br><span class=\"line\">serverMaxSlots = 64</span><br><span class=\"line\">serverSlots = 16</span><br><span class=\"line\">serverSlots1 = 32</span><br><span class=\"line\"> </span><br><span class=\"line\">proxyAddress = &quot;0.0.0.0&quot;</span><br><span class=\"line\">proxyPort = 8123</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/init.d/polipo restart</span><br></pre></td></tr></table></figure>\n<ul>\n<li>vim必备良药，git地址</li>\n</ul>\n<p><a href=\"https://github.com/ycm-core/YouCompleteMe.git\" target=\"_blank\" rel=\"noopener\">https://github.com/ycm-core/YouCompleteMe.git</a></p>\n"},{"title":"迦百农","date":"2019-03-10T03:26:46.000Z","_content":"\n![迦百农](迦百农/迦百农.jpg)\n\n​\t电影还没有在国内上映，就用特殊手段提前看了。确实是一部分好片，等电影上映到影院补上电影票。\n\n​      《迦百农》是这样一部电影，一旦你看完它，你就想去帮助一个人，成为一个人，让人们生活的更好。卡百农是一部属于全世界的电影，它是如此的真实，把多个尺度，多个层次，多种感情展现的淋漓尽致，贯穿你的心灵。\n\n​\t![002](迦百农/002.jpg)\n\n​\t这部电影讲述了一个出生在贫困中的孩子，他有很多兄弟姐妹，他父母不工作，所以把他们所有的大兄弟姐妹派到街上去买果汁，搬煤气罐…任何能维持生计的东西，但这不应该是一个12岁的孩子应该承受的。父母甚至卖了他们11岁的女儿给房东当老婆，这样他们就可以过上更好的生活，小男孩拼命反抗却无能为力，最后他离家出走，逃离这令人绝望的原生家庭。离家路上，他有幸被非法移民拉希尔领养。虽然拉希尔同样贫困，还偷偷带了一个私生子尤纳斯，可她给予了扎因从未体会的家庭温暖。随着拉希尔被拘留，面临遣返，扎因失去了庇护所。扎因开始独自抚养尤纳斯，他拼尽全力，也无法终止悲剧的轮回。\n\n\n\n![003](迦百农/003.jpg)\n\n​\t这部电影的感情会把你切碎，让你想接触屏幕，去拥抱所有的孩子。\n\n​\t在现实生活中扮演扎恩的男孩子也叫扎恩，他的表演很有力量。很高兴查到一个消息，导演娜丁宣布了他的现状：\n\n> 他目前获得了挪威的护照，已经被安置在那里三、四个月了。他有生以来第一次去上学。他正在学习如何读写。他重新获得了童年。他在花园里玩耍；他不再玩刀子和垃圾了。\n\n![004](迦百农/004.jpg)\n\n​\t可是在嫩巴黎还有无数个案例，那些孩子们，他们的现状呢？","source":"_posts/迦百农.md","raw":"---\ntitle: 迦百农\ndate: 2019-03-10 11:26:46\ntags: movies\n---\n\n![迦百农](迦百农/迦百农.jpg)\n\n​\t电影还没有在国内上映，就用特殊手段提前看了。确实是一部分好片，等电影上映到影院补上电影票。\n\n​      《迦百农》是这样一部电影，一旦你看完它，你就想去帮助一个人，成为一个人，让人们生活的更好。卡百农是一部属于全世界的电影，它是如此的真实，把多个尺度，多个层次，多种感情展现的淋漓尽致，贯穿你的心灵。\n\n​\t![002](迦百农/002.jpg)\n\n​\t这部电影讲述了一个出生在贫困中的孩子，他有很多兄弟姐妹，他父母不工作，所以把他们所有的大兄弟姐妹派到街上去买果汁，搬煤气罐…任何能维持生计的东西，但这不应该是一个12岁的孩子应该承受的。父母甚至卖了他们11岁的女儿给房东当老婆，这样他们就可以过上更好的生活，小男孩拼命反抗却无能为力，最后他离家出走，逃离这令人绝望的原生家庭。离家路上，他有幸被非法移民拉希尔领养。虽然拉希尔同样贫困，还偷偷带了一个私生子尤纳斯，可她给予了扎因从未体会的家庭温暖。随着拉希尔被拘留，面临遣返，扎因失去了庇护所。扎因开始独自抚养尤纳斯，他拼尽全力，也无法终止悲剧的轮回。\n\n\n\n![003](迦百农/003.jpg)\n\n​\t这部电影的感情会把你切碎，让你想接触屏幕，去拥抱所有的孩子。\n\n​\t在现实生活中扮演扎恩的男孩子也叫扎恩，他的表演很有力量。很高兴查到一个消息，导演娜丁宣布了他的现状：\n\n> 他目前获得了挪威的护照，已经被安置在那里三、四个月了。他有生以来第一次去上学。他正在学习如何读写。他重新获得了童年。他在花园里玩耍；他不再玩刀子和垃圾了。\n\n![004](迦百农/004.jpg)\n\n​\t可是在嫩巴黎还有无数个案例，那些孩子们，他们的现状呢？","slug":"迦百农","published":1,"updated":"2019-06-26T11:56:34.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxirvyon001zvkqpdo09hm54","content":"<p><img src=\"/2019/03/10/迦百农/迦百农.jpg\" alt=\"迦百农\"></p>\n<p>​    电影还没有在国内上映，就用特殊手段提前看了。确实是一部分好片，等电影上映到影院补上电影票。</p>\n<p>​      《迦百农》是这样一部电影，一旦你看完它，你就想去帮助一个人，成为一个人，让人们生活的更好。卡百农是一部属于全世界的电影，它是如此的真实，把多个尺度，多个层次，多种感情展现的淋漓尽致，贯穿你的心灵。</p>\n<p>​    <img src=\"/2019/03/10/迦百农/002.jpg\" alt=\"002\"></p>\n<p>​    这部电影讲述了一个出生在贫困中的孩子，他有很多兄弟姐妹，他父母不工作，所以把他们所有的大兄弟姐妹派到街上去买果汁，搬煤气罐…任何能维持生计的东西，但这不应该是一个12岁的孩子应该承受的。父母甚至卖了他们11岁的女儿给房东当老婆，这样他们就可以过上更好的生活，小男孩拼命反抗却无能为力，最后他离家出走，逃离这令人绝望的原生家庭。离家路上，他有幸被非法移民拉希尔领养。虽然拉希尔同样贫困，还偷偷带了一个私生子尤纳斯，可她给予了扎因从未体会的家庭温暖。随着拉希尔被拘留，面临遣返，扎因失去了庇护所。扎因开始独自抚养尤纳斯，他拼尽全力，也无法终止悲剧的轮回。</p>\n<p><img src=\"/2019/03/10/迦百农/003.jpg\" alt=\"003\"></p>\n<p>​    这部电影的感情会把你切碎，让你想接触屏幕，去拥抱所有的孩子。</p>\n<p>​    在现实生活中扮演扎恩的男孩子也叫扎恩，他的表演很有力量。很高兴查到一个消息，导演娜丁宣布了他的现状：</p>\n<blockquote>\n<p>他目前获得了挪威的护照，已经被安置在那里三、四个月了。他有生以来第一次去上学。他正在学习如何读写。他重新获得了童年。他在花园里玩耍；他不再玩刀子和垃圾了。</p>\n</blockquote>\n<p><img src=\"/2019/03/10/迦百农/004.jpg\" alt=\"004\"></p>\n<p>​    可是在嫩巴黎还有无数个案例，那些孩子们，他们的现状呢？</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/2019/03/10/迦百农/迦百农.jpg\" alt=\"迦百农\"></p>\n<p>​    电影还没有在国内上映，就用特殊手段提前看了。确实是一部分好片，等电影上映到影院补上电影票。</p>\n<p>​      《迦百农》是这样一部电影，一旦你看完它，你就想去帮助一个人，成为一个人，让人们生活的更好。卡百农是一部属于全世界的电影，它是如此的真实，把多个尺度，多个层次，多种感情展现的淋漓尽致，贯穿你的心灵。</p>\n<p>​    <img src=\"/2019/03/10/迦百农/002.jpg\" alt=\"002\"></p>\n<p>​    这部电影讲述了一个出生在贫困中的孩子，他有很多兄弟姐妹，他父母不工作，所以把他们所有的大兄弟姐妹派到街上去买果汁，搬煤气罐…任何能维持生计的东西，但这不应该是一个12岁的孩子应该承受的。父母甚至卖了他们11岁的女儿给房东当老婆，这样他们就可以过上更好的生活，小男孩拼命反抗却无能为力，最后他离家出走，逃离这令人绝望的原生家庭。离家路上，他有幸被非法移民拉希尔领养。虽然拉希尔同样贫困，还偷偷带了一个私生子尤纳斯，可她给予了扎因从未体会的家庭温暖。随着拉希尔被拘留，面临遣返，扎因失去了庇护所。扎因开始独自抚养尤纳斯，他拼尽全力，也无法终止悲剧的轮回。</p>\n<p><img src=\"/2019/03/10/迦百农/003.jpg\" alt=\"003\"></p>\n<p>​    这部电影的感情会把你切碎，让你想接触屏幕，去拥抱所有的孩子。</p>\n<p>​    在现实生活中扮演扎恩的男孩子也叫扎恩，他的表演很有力量。很高兴查到一个消息，导演娜丁宣布了他的现状：</p>\n<blockquote>\n<p>他目前获得了挪威的护照，已经被安置在那里三、四个月了。他有生以来第一次去上学。他正在学习如何读写。他重新获得了童年。他在花园里玩耍；他不再玩刀子和垃圾了。</p>\n</blockquote>\n<p><img src=\"/2019/03/10/迦百农/004.jpg\" alt=\"004\"></p>\n<p>​    可是在嫩巴黎还有无数个案例，那些孩子们，他们的现状呢？</p>\n"}],"PostAsset":[{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/StorageHierarchy.png","slug":"StorageHierarchy.png","post":"cjxirvym90005vkqp6finyhmd","modified":1,"renderable":0},{"_id":"source/_posts/2018总结/2018.jpeg","post":"cjxirvym10001vkqpi03trtow","slug":"2018.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/迦百农/001.jpg","post":"cjxirvyon001zvkqpdo09hm54","slug":"001.jpg","modified":1,"renderable":1},{"_id":"source/_posts/迦百农/002.jpg","post":"cjxirvyon001zvkqpdo09hm54","slug":"002.jpg","modified":1,"renderable":1},{"_id":"source/_posts/迦百农/003.jpg","post":"cjxirvyon001zvkqpdo09hm54","slug":"003.jpg","modified":1,"renderable":1},{"_id":"source/_posts/迦百农/004.jpg","post":"cjxirvyon001zvkqpdo09hm54","slug":"004.jpg","modified":1,"renderable":1},{"_id":"source/_posts/迦百农/迦百农.jpg","post":"cjxirvyon001zvkqpdo09hm54","slug":"迦百农.jpg","modified":1,"renderable":1},{"_id":"source/_posts/LEC1/QQ20190309-231854@2x.png","post":"cjxirvynw000svkqpf1hznn8g","slug":"QQ20190309-231854@2x.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/Conjunction.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"Conjunction.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/Disjunction.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"Disjunction.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN-2.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"PREDICATE-PUSHDOWN-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/PREDICATE-PUSHDOWN.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"PREDICATE-PUSHDOWN.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/PROJECTION-PUSHDOWN-2.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"PROJECTION-PUSHDOWN-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/QUERY-PLANNING-OVERVIEW.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"QUERY-PLANNING-OVERVIEW.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/SC-1.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"SC-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/SC-2.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"SC-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/SC-3.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"SC-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/SC-4.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"SC-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-13-NOTES/关系代数等价.png","post":"cjxirvyn4000fvkqpxiv07rqp","slug":"关系代数等价.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/DSM.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"DSM.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/NSM-1.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"NSM-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/NSM-2.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"NSM-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/NSM-3.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"NSM-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/OLAP-OLTP.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"OLAP-OLTP.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/OLAP.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"OLAP.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/OLTP.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"OLTP.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/external-f.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"external-f.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/lager_v.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"lager_v.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/oriented1.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"oriented1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/oriented2.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"oriented2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/oriented3.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"oriented3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/oriented4.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"oriented4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/oriented5.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"oriented5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-04-NOTES/var.png","post":"cjxirvymb0007vkqpmf1cqy3q","slug":"var.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-1.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"HORIZONTAL-PARTITIONING-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/HORIZONTAL-PARTITIONING-2.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"HORIZONTAL-PARTITIONING-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-1.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"INTER-OPERATOR-V-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-2.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"INTER-OPERATOR-V-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTER-OPERATOR-V-3.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"INTER-OPERATOR-V-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-1.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"INTRA-OPERATOR-H-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-2.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"INTRA-OPERATOR-H-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-3.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"INTRA-OPERATOR-H-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-4.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"INTRA-OPERATOR-H-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-5.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"INTRA-OPERATOR-H-5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/INTRA-OPERATOR-H-6.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"INTRA-OPERATOR-H-6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/MULTI-DISK-PARALLELISM.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"MULTI-DISK-PARALLELISM.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/PROCESS-PER-WORKER.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"PROCESS-PER-WORKER.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/PROCESS-POOL.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"PROCESS-POOL.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/RAID-1-Mirroring.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"RAID-1-Mirroring.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/THREAD-PER-WORKER.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"THREAD-PER-WORKER.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING-2.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"VERTICAL-PARTITIONING-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/VERTICAL-PARTITIONING.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"VERTICAL-PARTITIONING.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-14-NOTES/stream.png","post":"cjxirvynd000hvkqpm5meui2n","slug":"stream.png","modified":1,"renderable":1},{"_id":"source/_posts/LEC1/001.png","slug":"001.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/002.png","slug":"002.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/MapReduce.png","post":"cjxirvynw000svkqpf1hznn8g","slug":"MapReduce.png","modified":1,"renderable":1},{"_id":"source/_posts/LEC1/MapReduceApi.png","post":"cjxirvynw000svkqpf1hznn8g","slug":"MapReduceApi.png","modified":1,"renderable":1},{"_id":"source/_posts/LEC1/QQ20190309-230116@2x.png","slug":"QQ20190309-230116@2x.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-230220@2x.png","slug":"QQ20190309-230220@2x.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-230801@2x.png","slug":"QQ20190309-230801@2x.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-231221@2x.png","slug":"QQ20190309-231221@2x.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-231930@2x.png","slug":"QQ20190309-231930@2x.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-233752@2x.png","slug":"QQ20190309-233752@2x.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-234415@2x.png","slug":"QQ20190309-234415@2x.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-234523@2x.png","slug":"QQ20190309-234523@2x.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-234749@2x.png","slug":"QQ20190309-234749@2x.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190309-235308@2x.png","slug":"QQ20190309-235308@2x.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-101849.png","slug":"QQ20190310-101849.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-102424.png","slug":"QQ20190310-102424.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-103037.png","slug":"QQ20190310-103037.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-103536.png","slug":"QQ20190310-103536.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-103722.png","slug":"QQ20190310-103722.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-104242.png","slug":"QQ20190310-104242.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-104738.png","slug":"QQ20190310-104738.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-104800.png","slug":"QQ20190310-104800.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/LEC1/QQ20190310-105207.png","slug":"QQ20190310-105207.png","post":"cjxirvynw000svkqpf1hznn8g","modified":1,"renderable":0},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/Clustered-bplus-tree.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"Clustered-bplus-tree.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-1.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"EXTERNAL-MERGE-SORT-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-2.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"EXTERNAL-MERGE-SORT-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-3.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"EXTERNAL-MERGE-SORT-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-4.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"EXTERNAL-MERGE-SORT-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/EXTERNAL-MERGE-SORT-5.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"EXTERNAL-MERGE-SORT-5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/External-merge-sort1.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"External-merge-sort1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/External-merge-sort2.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"External-merge-sort2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/External-merge-sort3.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"External-merge-sort3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/External-merge-sort4.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"External-merge-sort4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/External-merge-sort5.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"External-merge-sort5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-1.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"HASHING-AGGREGATE-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-2.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"HASHING-AGGREGATE-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-3.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"HASHING-AGGREGATE-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-4.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"HASHING-AGGREGATE-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-5.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"HASHING-AGGREGATE-5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-6.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"HASHING-AGGREGATE-6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-AGGREGATE-7.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"HASHING-AGGREGATE-7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-1.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"HASHING-SUMMARIZATION-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-2.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"HASHING-SUMMARIZATION-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/HASHING-SUMMARIZATION-3.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"HASHING-SUMMARIZATION-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-1.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"SORTING-AGGREGATION-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-2.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"SORTING-AGGREGATION-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-3.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"SORTING-AGGREGATION-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-4.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"SORTING-AGGREGATION-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/SORTING-AGGREGATION-5.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"SORTING-AGGREGATION-5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-11-NOTES/Unclustered-bplus-tree.png","post":"cjxirvynm000jvkqpig8sdl37","slug":"Unclustered-bplus-tree.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes1.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"b-plus-tree-leaf-nodes1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes2.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"b-plus-tree-leaf-nodes2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes3.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"b-plus-tree-leaf-nodes3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-leaf-nodes4.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"b-plus-tree-leaf-nodes4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search1.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"b-plus-tree-search1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search2.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"b-plus-tree-search2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree-search3.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"b-plus-tree-search3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree1.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"b-plus-tree1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/b-plus-tree2.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"b-plus-tree2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/bulk-insert1.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"bulk-insert1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/bulk-insert2.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"bulk-insert2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/bulk-insert3.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"bulk-insert3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/duplicate-keys.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"duplicate-keys.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling1.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"pointer-swizzling1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling2.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"pointer-swizzling2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling3.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"pointer-swizzling3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling4.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"pointer-swizzling4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/pointer-swizzling5.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"pointer-swizzling5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/prefix-compression1.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"prefix-compression1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/prefix-compression2.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"prefix-compression2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search1.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"search1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search2.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"search2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search3.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"search3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search4.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"search4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search5.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"search5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search6.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"search6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/search7.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"search7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/suffix-trun1.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"suffix-trun1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/suffix-trun2.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"suffix-trun2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-07-NOTES/value-list.png","post":"cjxirvymf0008vkqpi7x09hv7","slug":"value-list.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/ACCESSTIMES.png","post":"cjxirvym90005vkqp6finyhmd","slug":"ACCESSTIMES.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/DirPages.png","post":"cjxirvym90005vkqp6finyhmd","slug":"DirPages.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/PageLinkList.png","post":"cjxirvym90005vkqp6finyhmd","slug":"PageLinkList.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction1.png","post":"cjxirvym90005vkqp6finyhmd","slug":"compaction1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction2.png","post":"cjxirvym90005vkqp6finyhmd","slug":"compaction2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction3.png","post":"cjxirvym90005vkqp6finyhmd","slug":"compaction3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction4.png","post":"cjxirvym90005vkqp6finyhmd","slug":"compaction4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction5.png","post":"cjxirvym90005vkqp6finyhmd","slug":"compaction5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction6.png","post":"cjxirvym90005vkqp6finyhmd","slug":"compaction6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/compaction7.png","post":"cjxirvym90005vkqp6finyhmd","slug":"compaction7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/denormalized1.png","post":"cjxirvym90005vkqp6finyhmd","slug":"denormalized1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/denormalized2.png","post":"cjxirvym90005vkqp6finyhmd","slug":"denormalized2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/denormalized3.png","post":"cjxirvym90005vkqp6finyhmd","slug":"denormalized3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/log1.png","post":"cjxirvym90005vkqp6finyhmd","slug":"log1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/log2.png","post":"cjxirvym90005vkqp6finyhmd","slug":"log2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/log3.png","post":"cjxirvym90005vkqp6finyhmd","slug":"log3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/mmap1.png","post":"cjxirvym90005vkqp6finyhmd","slug":"mmap1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/mmap2.png","post":"cjxirvym90005vkqp6finyhmd","slug":"mmap2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/mmap3.png","post":"cjxirvym90005vkqp6finyhmd","slug":"mmap3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/mmap4.png","post":"cjxirvym90005vkqp6finyhmd","slug":"mmap4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/mmap5.png","post":"cjxirvym90005vkqp6finyhmd","slug":"mmap5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/page_header.png","post":"cjxirvym90005vkqp6finyhmd","slug":"page_header.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/pages.png","post":"cjxirvym90005vkqp6finyhmd","slug":"pages.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/record-ids.png","post":"cjxirvym90005vkqp6finyhmd","slug":"record-ids.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/slot-page1.png","post":"cjxirvym90005vkqp6finyhmd","slug":"slot-page1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/slot-page2.png","post":"cjxirvym90005vkqp6finyhmd","slug":"slot-page2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple-data.png","post":"cjxirvym90005vkqp6finyhmd","slug":"tuple-data.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple-header.png","post":"cjxirvym90005vkqp6finyhmd","slug":"tuple-header.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple1.png","post":"cjxirvym90005vkqp6finyhmd","slug":"tuple1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple2.png","post":"cjxirvym90005vkqp6finyhmd","slug":"tuple2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple3.png","post":"cjxirvym90005vkqp6finyhmd","slug":"tuple3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-03-NOTES/tuple4.png","post":"cjxirvym90005vkqp6finyhmd","slug":"tuple4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/BASIC-HASH-JOIN-ALGORITHM-1.png","post":"cjxirvyn1000evkqplz6s24th","slug":"BASIC-HASH-JOIN-ALGORITHM-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/BLOCK-NESTED-LOOP-JOIN-1.png","post":"cjxirvyn1000evkqplz6s24th","slug":"BLOCK-NESTED-LOOP-JOIN-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-1.png","post":"cjxirvyn1000evkqplz6s24th","slug":"GRACE-HASH-JOIN-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-2.png","post":"cjxirvyn1000evkqplz6s24th","slug":"GRACE-HASH-JOIN-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/GRACE-HASH-JOIN-3.png","post":"cjxirvyn1000evkqplz6s24th","slug":"GRACE-HASH-JOIN-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/INDEX-NESTED-LOOP-JOIN-1.png","post":"cjxirvyn1000evkqplz6s24th","slug":"INDEX-NESTED-LOOP-JOIN-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-1.png","post":"cjxirvyn1000evkqplz6s24th","slug":"JOIN-OPERATOR-OUTPUT-DATA-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-2.png","post":"cjxirvyn1000evkqplz6s24th","slug":"JOIN-OPERATOR-OUTPUT-DATA-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-DATA-3.png","post":"cjxirvyn1000evkqplz6s24th","slug":"JOIN-OPERATOR-OUTPUT-DATA-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-1.png","post":"cjxirvyn1000evkqplz6s24th","slug":"JOIN-OPERATOR-OUTPUT-RECORD-IDS-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-2.png","post":"cjxirvyn1000evkqplz6s24th","slug":"JOIN-OPERATOR-OUTPUT-RECORD-IDS-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/JOIN-OPERATOR-OUTPUT-RECORD-IDS-3.png","post":"cjxirvyn1000evkqplz6s24th","slug":"JOIN-OPERATOR-OUTPUT-RECORD-IDS-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/Join-OPERATOR-1.png","post":"cjxirvyn1000evkqplz6s24th","slug":"Join-OPERATOR-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/Normalized-tables.png","post":"cjxirvyn1000evkqplz6s24th","slug":"Normalized-tables.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-1.png","post":"cjxirvyn1000evkqplz6s24th","slug":"RECURSIVE-PARTITIONING-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-2.png","post":"cjxirvyn1000evkqplz6s24th","slug":"RECURSIVE-PARTITIONING-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-3.png","post":"cjxirvyn1000evkqplz6s24th","slug":"RECURSIVE-PARTITIONING-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-4.png","post":"cjxirvyn1000evkqplz6s24th","slug":"RECURSIVE-PARTITIONING-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-5.png","post":"cjxirvyn1000evkqplz6s24th","slug":"RECURSIVE-PARTITIONING-5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/RECURSIVE-PARTITIONING-6.png","post":"cjxirvyn1000evkqplz6s24th","slug":"RECURSIVE-PARTITIONING-6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SIMPLE-NESTED-LOOP-JOIN-1.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SIMPLE-NESTED-LOOP-JOIN-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-1.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-10.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-10.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-11.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-11.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-12.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-12.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-2.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-3.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-4.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-5.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-6.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-7.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-8.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-12-NOTES/SORT-MERGE-JOIN-9.png","post":"cjxirvyn1000evkqplz6s24th","slug":"SORT-MERGE-JOIN-9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-1.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"CONFLICT-SERIALIZABILITY-INTUITION-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-2.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"CONFLICT-SERIALIZABILITY-INTUITION-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-3.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"CONFLICT-SERIALIZABILITY-INTUITION-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-4.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"CONFLICT-SERIALIZABILITY-INTUITION-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-5.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"CONFLICT-SERIALIZABILITY-INTUITION-5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-6.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"CONFLICT-SERIALIZABILITY-INTUITION-6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-7.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"CONFLICT-SERIALIZABILITY-INTUITION-7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-8.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"CONFLICT-SERIALIZABILITY-INTUITION-8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/CONFLICT-SERIALIZABILITY-INTUITION-9.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"CONFLICT-SERIALIZABILITY-INTUITION-9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-1.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"EXAMPLE-1-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-1-2.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"EXAMPLE-1-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-1.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"EXAMPLE-2-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-2.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"EXAMPLE-2-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-2-3.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"EXAMPLE-2-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-1.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"EXAMPLE-3-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-2.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"EXAMPLE-3-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-3.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"EXAMPLE-3-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/EXAMPLE-3-4.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"EXAMPLE-3-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/Exmple.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"Exmple.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-1.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"INTERLEAVING-EXAMPLE-(BAD)-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-2.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"INTERLEAVING-EXAMPLE-(BAD)-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(BAD)-3.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"INTERLEAVING-EXAMPLE-(BAD)-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD)-1.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"INTERLEAVING-EXAMPLE-(GOOD)-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/INTERLEAVING-EXAMPLE-(GOOD)-2.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"INTERLEAVING-EXAMPLE-(GOOD)-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/Overwriting-Uncommitted-Data.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"Overwriting-Uncommitted-Data.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/Reading-Uncommitted-Data.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"Reading-Uncommitted-Data.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/SERIAL-EXECUTION-EXAMPLE.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"SERIAL-EXECUTION-EXAMPLE.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/Status.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"Status.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/Unrepeatable-Reads.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"Unrepeatable-Reads.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-1.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"VIEW-SERIALIZABILITY-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-2.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"VIEW-SERIALIZABILITY-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-3.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"VIEW-SERIALIZABILITY-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-4.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"VIEW-SERIALIZABILITY-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-5.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"VIEW-SERIALIZABILITY-5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-16-NOTES/VIEW-SERIALIZABILITY-6.png","post":"cjxirvynr000mvkqpq8z2sv51","slug":"VIEW-SERIALIZABILITY-6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-1.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"evalution-1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-2.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"evalution-2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-3.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"evalution-3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-4.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"evalution-4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-5.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"evalution-5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-6.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"evalution-6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/evalution-7.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"evalution-7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/heap-cluster1.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"heap-cluster1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/heap-cluster2.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"heap-cluster2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/index-scan1.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"index-scan1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/index-scan2.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"index-scan2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/index-scan3.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"index-scan3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/index-scan4.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"index-scan4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/iter-model1.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"iter-model1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/iter-model2.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"iter-model2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/iter-model3.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"iter-model3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/iter-model4.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"iter-model4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/iter-model5.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"iter-model5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/late1.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"late1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/late2.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"late2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/late3.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"late3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/late4.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"late4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/mate-model1.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"mate-model1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/mate-model2.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"mate-model2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/mate-model3.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"mate-model3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/mate-model4.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"mate-model4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/mate-model5.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"mate-model5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/multi-index-scan1.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"multi-index-scan1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/multi-index-scan2.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"multi-index-scan2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/multi-index-scan3.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"multi-index-scan3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/query-plan.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"query-plan.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/vect-model1.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"vect-model1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/vect-model2.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"vect-model2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/vect-model3.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"vect-model3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/zone-map1.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"zone-map1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/zone-map2.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"zone-map2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-10-NOTES/zone-map3.png","post":"cjxirvymx000dvkqpvj2657ki","slug":"zone-map3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/Buffer-pool-meta-data.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"Buffer-pool-meta-data.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/DISK-ORIENTED.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"DISK-ORIENTED.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/Pin.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"Pin.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock1.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"clock1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock2.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"clock2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock3.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"clock3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock4.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"clock4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock5.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"clock5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock6.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"clock6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock7.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"clock7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/clock8.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"clock8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-page1.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"index-page1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-page2.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"index-page2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-page3.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"index-page3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-pre1.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"index-pre1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-pre2.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"index-pre2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-pre3.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"index-pre3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/index-pre4.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"index-pre4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre1.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"pre1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre2.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"pre2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre3.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"pre3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre4.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"pre4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre5.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"pre5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/pre6.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"pre6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/read-disk1.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"read-disk1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/read-disk2.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"read-disk2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/read-disk3.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"read-disk3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan1.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"scan1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan10.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"scan10.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan2.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"scan2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan3.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"scan3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan4.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"scan4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan5.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"scan5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan6.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"scan6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan7.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"scan7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan8.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"scan8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/scan9.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"scan9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq1.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"seq1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq2.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"seq2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq3.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"seq3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq4.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"seq4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq5.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"seq5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-05-NOTES/seq6.png","post":"cjxirvymj0009vkqp8h8fc2pd","slug":"seq6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/chained-hash1.png","post":"cjxirvymm000avkqppiw366mg","slug":"chained-hash1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/chained-hash2.png","post":"cjxirvymm000avkqppiw366mg","slug":"chained-hash2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash1.png","post":"cjxirvymm000avkqppiw366mg","slug":"cuckoo-hash1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash2.png","post":"cjxirvymm000avkqppiw366mg","slug":"cuckoo-hash2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash3.png","post":"cjxirvymm000avkqppiw366mg","slug":"cuckoo-hash3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash4.png","post":"cjxirvymm000avkqppiw366mg","slug":"cuckoo-hash4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash5.png","post":"cjxirvymm000avkqppiw366mg","slug":"cuckoo-hash5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash6.png","post":"cjxirvymm000avkqppiw366mg","slug":"cuckoo-hash6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash7.png","post":"cjxirvymm000avkqppiw366mg","slug":"cuckoo-hash7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash8.png","post":"cjxirvymm000avkqppiw366mg","slug":"cuckoo-hash8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/cuckoo-hash9.png","post":"cjxirvymm000avkqppiw366mg","slug":"cuckoo-hash9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash1.png","post":"cjxirvymm000avkqppiw366mg","slug":"extendible-hash1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash2.png","post":"cjxirvymm000avkqppiw366mg","slug":"extendible-hash2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash3.png","post":"cjxirvymm000avkqppiw366mg","slug":"extendible-hash3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash4.png","post":"cjxirvymm000avkqppiw366mg","slug":"extendible-hash4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash5.png","post":"cjxirvymm000avkqppiw366mg","slug":"extendible-hash5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash6.png","post":"cjxirvymm000avkqppiw366mg","slug":"extendible-hash6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash7.png","post":"cjxirvymm000avkqppiw366mg","slug":"extendible-hash7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash8.png","post":"cjxirvymm000avkqppiw366mg","slug":"extendible-hash8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/extendible-hash9.png","post":"cjxirvymm000avkqppiw366mg","slug":"extendible-hash9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/hash-benchmark.png","post":"cjxirvymm000avkqppiw366mg","slug":"hash-benchmark.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash1.png","post":"cjxirvymm000avkqppiw366mg","slug":"linear-hash1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash10.png","post":"cjxirvymm000avkqppiw366mg","slug":"linear-hash10.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash2.png","post":"cjxirvymm000avkqppiw366mg","slug":"linear-hash2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash3.png","post":"cjxirvymm000avkqppiw366mg","slug":"linear-hash3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash4.png","post":"cjxirvymm000avkqppiw366mg","slug":"linear-hash4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash6.png","post":"cjxirvymm000avkqppiw366mg","slug":"linear-hash6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash7.png","post":"cjxirvymm000avkqppiw366mg","slug":"linear-hash7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash8.png","post":"cjxirvymm000avkqppiw366mg","slug":"linear-hash8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/linear-hash9.png","post":"cjxirvymm000avkqppiw366mg","slug":"linear-hash9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe1.png","post":"cjxirvymm000avkqppiw366mg","slug":"liner-probe1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe2.png","post":"cjxirvymm000avkqppiw366mg","slug":"liner-probe2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe3.png","post":"cjxirvymm000avkqppiw366mg","slug":"liner-probe3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe4.png","post":"cjxirvymm000avkqppiw366mg","slug":"liner-probe4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe5.png","post":"cjxirvymm000avkqppiw366mg","slug":"liner-probe5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/liner-probe6.png","post":"cjxirvymm000avkqppiw366mg","slug":"liner-probe6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/probe-hash.png","post":"cjxirvymm000avkqppiw366mg","slug":"probe-hash.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash1.png","post":"cjxirvymm000avkqppiw366mg","slug":"robin-hash1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash2.png","post":"cjxirvymm000avkqppiw366mg","slug":"robin-hash2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash3.png","post":"cjxirvymm000avkqppiw366mg","slug":"robin-hash3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash4.png","post":"cjxirvymm000avkqppiw366mg","slug":"robin-hash4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash5.png","post":"cjxirvymm000avkqppiw366mg","slug":"robin-hash5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash6.png","post":"cjxirvymm000avkqppiw366mg","slug":"robin-hash6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash7.png","post":"cjxirvymm000avkqppiw366mg","slug":"robin-hash7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash8.png","post":"cjxirvymm000avkqppiw366mg","slug":"robin-hash8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/robin-hash9.png","post":"cjxirvymm000avkqppiw366mg","slug":"robin-hash9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/static-hash1.png","post":"cjxirvymm000avkqppiw366mg","slug":"static-hash1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/static-hash2.png","post":"cjxirvymm000avkqppiw366mg","slug":"static-hash2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-06-NOTES/status.png","post":"cjxirvymm000avkqppiw366mg","slug":"status.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/covering-index1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"covering-index1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"functional-index1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index2.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"functional-index2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index3.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"functional-index3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index4.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"functional-index4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index5.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"functional-index5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/functional-index6.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"functional-index6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/implicit-index1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"implicit-index1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/in-mem-index1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"in-mem-index1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/index-include1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"index-include1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/index-include2.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"index-include2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/index-include3.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"index-include3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/observation1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"observation1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/observation2.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"observation2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/partial-index1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"partial-index1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree-bck1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree-bck1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree-bck2.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree-bck2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree-bck3.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree-bck3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree10.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree10.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree11.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree11.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree2.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree3.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree4.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree5.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree6.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree7.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree8.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/r-tree9.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"r-tree9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list10.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list10.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list11.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list11.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list12.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list12.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list13.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list13.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list14.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list14.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list15.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list15.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list16.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list16.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list17.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list17.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list18.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list18.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list19.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list19.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list2.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list20.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list20.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list21.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list21.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list22.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list22.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list3.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list4.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list5.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list6.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list7.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list8.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/skip-list9.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"skip-list9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/wikipadia-example1.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"wikipadia-example1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-08-NOTES/wikipadia-example2.png","post":"cjxirvymq000bvkqpsbms8wlb","slug":"wikipadia-example2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better1.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"better1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better2.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"better2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better3.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"better3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better4.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"better4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better5.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"better5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better6.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"better6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better7.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"better7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/better8.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"better8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent1.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"delay-parent1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent10.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"delay-parent10.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent2.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"delay-parent2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent3.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"delay-parent3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent4.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"delay-parent4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent5.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"delay-parent5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent6.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"delay-parent6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent7.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"delay-parent7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent8.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"delay-parent8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/delay-parent9.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"delay-parent9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch1.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch10.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch10.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch11.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch11.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch12.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch12.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch13.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch13.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch14.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch14.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch15.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch15.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch16.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch16.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch17.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch17.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch18.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch18.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch19.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch19.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch2.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch20.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch20.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch21.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch21.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch22.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch22.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch23.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch23.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch24.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch24.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch25.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch25.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch3.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch4.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch5.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch6.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch7.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch8.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/latch9.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"latch9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan1.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan10.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan10.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan11.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan11.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan12.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan12.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan13.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan13.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan14.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan14.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan15.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan15.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan2.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan3.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan4.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan5.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan6.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan7.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan8.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan8.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/leaf-node-scan9.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"leaf-node-scan9.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr1.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"muti-thr1.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr2.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"muti-thr2.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr3.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"muti-thr3.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr4.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"muti-thr4.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr5.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"muti-thr5.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr6.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"muti-thr6.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/muti-thr7.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"muti-thr7.png","modified":1,"renderable":1},{"_id":"source/_posts/CMU-DBMS-COURSE-09-NOTES/observation1.png","post":"cjxirvymu000cvkqpkd5m0j1k","slug":"observation1.png","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[{"post_id":"cjxirvyn1000evkqplz6s24th","tag_id":"cjxirvyn9000gvkqp7px3y5nn","_id":"cjxirvynr000lvkqpqax7ug3m"},{"post_id":"cjxirvynd000hvkqpm5meui2n","tag_id":"cjxirvynn000kvkqp2lw1yyul","_id":"cjxirvynu000qvkqp6ztu5359"},{"post_id":"cjxirvynr000mvkqpq8z2sv51","tag_id":"cjxirvynt000ovkqp77hwb031","_id":"cjxirvynx000uvkqpnqeweqar"},{"post_id":"cjxirvyny000wvkqpxiem8ffk","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyo0000zvkqp2dngwd8j"},{"post_id":"cjxirvynv000rvkqpcyclrl1v","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyo10011vkqpbdyibxyu"},{"post_id":"cjxirvynz000xvkqp88xf884v","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyo40014vkqpqabvj1vo"},{"post_id":"cjxirvyo00010vkqp19znm6yw","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyo50016vkqpacud2z7u"},{"post_id":"cjxirvynw000svkqpf1hznn8g","tag_id":"cjxirvyo0000yvkqpe2v4i2ck","_id":"cjxirvyoa0018vkqp5k0hkxxa"},{"post_id":"cjxirvyo10012vkqpyyewj3xp","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyob001avkqpbgu15zx5"},{"post_id":"cjxirvyo40015vkqp7x5rghz4","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyoc001cvkqpmmlwcnre"},{"post_id":"cjxirvynx000vvkqpy2nk6h3l","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyod001evkqp58z1l8ku"},{"post_id":"cjxirvyo50017vkqp5ane4tip","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyoe001gvkqp2zr189wv"},{"post_id":"cjxirvyoa0019vkqpgr4hz8ul","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyof001ivkqphtwfb4fm"},{"post_id":"cjxirvyob001bvkqpih7dfrwb","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyog001kvkqp0gd0ifyu"},{"post_id":"cjxirvyoc001dvkqpthitib6e","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyoh001mvkqp9qvkd2ph"},{"post_id":"cjxirvyod001fvkqp1lk4w2p3","tag_id":"cjxirvyo0000yvkqpe2v4i2ck","_id":"cjxirvyoi001ovkqpgdvkc4e5"},{"post_id":"cjxirvyoe001hvkqpt0np3ddg","tag_id":"cjxirvyo0000yvkqpe2v4i2ck","_id":"cjxirvyoi001qvkqpic0shijf"},{"post_id":"cjxirvyog001lvkqp3ya9v229","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyok001svkqp3xpd5dyy"},{"post_id":"cjxirvyoh001nvkqpn7bf2a72","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyol001uvkqpwcfj138z"},{"post_id":"cjxirvyoi001pvkqpdvd48jor","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyom001wvkqp3ho59f1v"},{"post_id":"cjxirvyoj001rvkqps48t2em9","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyon001yvkqphu8qb4py"},{"post_id":"cjxirvyok001tvkqpjhshm9if","tag_id":"cjxirvynw000tvkqptoiaw4kh","_id":"cjxirvyoo0021vkqptd9jux3h"},{"post_id":"cjxirvyom001xvkqp9397z727","tag_id":"cjxirvyoo0020vkqpiw3xyeco","_id":"cjxirvyop0023vkqpxjeuuxg6"},{"post_id":"cjxirvyon001zvkqpdo09hm54","tag_id":"cjxirvyop0022vkqpwoazn69w","_id":"cjxirvyop0024vkqpau60sgtn"}],"Tag":[{"name":"Join Algorithms","_id":"cjxirvyn9000gvkqp7px3y5nn"},{"name":"Parallel Execution","_id":"cjxirvynn000kvkqp2lw1yyul"},{"name":"Concurrency control theory","_id":"cjxirvynt000ovkqp77hwb031"},{"name":"6.824视频","_id":"cjxirvynw000tvkqptoiaw4kh"},{"name":"分布式系统6.824笔记","_id":"cjxirvyo0000yvkqpe2v4i2ck"},{"name":"各种开发必要的配置摘记","_id":"cjxirvyoo0020vkqpiw3xyeco"},{"name":"movies","_id":"cjxirvyop0022vkqpwoazn69w"}]}}
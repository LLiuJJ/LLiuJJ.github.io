<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="简单工厂模式，策略模式," />










<meta name="description" content="简单的工厂模式模式的定义简单工厂模式(Simple Factory Pattern)：又称静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数不同返回不同的示例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 模式结构简单工厂模式包含如下角色 Factory: 工厂角色 ​    工厂角色负责实现创">
<meta name="keywords" content="简单工厂模式，策略模式">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式整理(-)">
<meta property="og:url" content="https://vajn.github.io/2018/05/27/desgin-pattern/index.html">
<meta property="og:site_name" content="用心感受生活">
<meta property="og:description" content="简单的工厂模式模式的定义简单工厂模式(Simple Factory Pattern)：又称静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数不同返回不同的示例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 模式结构简单工厂模式包含如下角色 Factory: 工厂角色 ​    工厂角色负责实现创">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://vajn.github.io/2018/05/27/desgin-pattern/images/简单工厂模式_Hk5GOvU1m.png">
<meta property="og:image" content="https://vajn.github.io/2018/05/27/desgin-pattern/images/策略模式_rJ4cAcDym.png">
<meta property="og:image" content="https://vajn.github.io/2018/05/27/desgin-pattern/images/装饰器模式.png">
<meta property="og:image" content="https://vajn.github.io/2018/05/27/desgin-pattern/images/代理模式.png">
<meta property="og:image" content="https://vajn.github.io/2018/05/27/desgin-pattern/images/工厂方法模式.png">
<meta property="og:image" content="https://vajn.github.io/2018/05/27/desgin-pattern/images/模版方法.png">
<meta property="og:image" content="https://vajn.github.io/2018/05/27/desgin-pattern/images/外观模式.png">
<meta property="og:updated_time" content="2018-06-02T03:23:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="设计模式整理(-)">
<meta name="twitter:description" content="简单的工厂模式模式的定义简单工厂模式(Simple Factory Pattern)：又称静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数不同返回不同的示例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 模式结构简单工厂模式包含如下角色 Factory: 工厂角色 ​    工厂角色负责实现创">
<meta name="twitter:image" content="https://vajn.github.io/2018/05/27/desgin-pattern/images/简单工厂模式_Hk5GOvU1m.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://vajn.github.io/2018/05/27/desgin-pattern/"/>





  <title>设计模式整理(-) | 用心感受生活</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">用心感受生活</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://vajn.github.io/2018/05/27/desgin-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jie Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="用心感受生活">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">设计模式整理(-)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-27T22:16:31+08:00">
                2018-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="简单的工厂模式"><a href="#简单的工厂模式" class="headerlink" title="简单的工厂模式"></a>简单的工厂模式</h2><h3 id="模式的定义"><a href="#模式的定义" class="headerlink" title="模式的定义"></a>模式的定义</h3><p>简单工厂模式(Simple Factory Pattern)：又称静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数不同返回不同的示例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p>简单工厂模式包含如下角色</p>
<p>Factory: 工厂角色</p>
<p>​    工厂角色负责实现创建所有实例内部的逻辑</p>
<p>Product: 抽象产品角色</p>
<p>​    抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</p>
<p>ConcreteProduct: 具体产品角色</p>
<p>​    具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类实现</p>
<h3 id="简单工厂模式的优点"><a href="#简单工厂模式的优点" class="headerlink" title="简单工厂模式的优点"></a>简单工厂模式的优点</h3><p>​    工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类来创建对象。</p>
<p>​    客户端无须知道所创建的具体产品的类名，只需要知道具体产品所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</p>
<p>​    通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p>
<h3 id="简单工厂模式的缺点"><a href="#简单工厂模式的缺点" class="headerlink" title="简单工厂模式的缺点"></a>简单工厂模式的缺点</h3><p>​    由于工程类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要收到影响。</p>
<p>​    使用简单工厂模式将会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度。</p>
<p>​    系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，又可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p><img src="/2018/05/27/desgin-pattern/images/简单工厂模式_Hk5GOvU1m.png" alt="简单工厂模式_Hk5GOvU1m"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.SimpleFactoryPattern.OperationDemo;</span><br><span class="line"></span><br><span class="line">public class Operation &#123;</span><br><span class="line"></span><br><span class="line">    private Double numberA = 0.0;</span><br><span class="line">    private Double numberB = 0.0;</span><br><span class="line"></span><br><span class="line">    public Double getNumberA() &#123;</span><br><span class="line">        return numberA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNumberA(Double numberA) &#123;</span><br><span class="line">        this.numberA = numberA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getNumberB() &#123;</span><br><span class="line">        return numberB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNumberB(Double numberB) &#123;</span><br><span class="line">        this.numberB = numberB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double GetResult()&#123;</span><br><span class="line">        double result = 0.0;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.SimpleFactoryPattern.OperationDemo;</span><br><span class="line"></span><br><span class="line">public class OperationAdd extends Operation &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double GetResult() &#123;</span><br><span class="line"></span><br><span class="line">        double result = 0;</span><br><span class="line">        result = getNumberA() + getNumberB();</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.SimpleFactoryPattern.OperationDemo;</span><br><span class="line"></span><br><span class="line">public class OperationDiv extends Operation &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double GetResult() &#123;</span><br><span class="line"></span><br><span class="line">        Double result = 0.0;</span><br><span class="line">        result = getNumberA() / getNumberB();</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.SimpleFactoryPattern.OperationDemo;</span><br><span class="line"></span><br><span class="line">public class OperationFactory &#123;</span><br><span class="line"></span><br><span class="line">    public static Operation createOperate(String operate)</span><br><span class="line">    &#123;</span><br><span class="line">        Operation oper = null;</span><br><span class="line">        switch (operate)</span><br><span class="line">        &#123;</span><br><span class="line">            case &quot;+&quot;:</span><br><span class="line">                oper = new OperationAdd();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;-&quot;:</span><br><span class="line">                oper = new OperationSub();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;*&quot;:</span><br><span class="line">                oper = new OperationMul();</span><br><span class="line">                break;</span><br><span class="line">            case &quot;/&quot;:</span><br><span class="line">                oper = new OperationDiv();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return oper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.SimpleFactoryPattern.OperationDemo;</span><br><span class="line"></span><br><span class="line">public class OperationMul extends Operation&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double GetResult() &#123;</span><br><span class="line"></span><br><span class="line">        Double result = 0.0;</span><br><span class="line">        result = getNumberA() * getNumberB();</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.SimpleFactoryPattern.OperationDemo;</span><br><span class="line"></span><br><span class="line">public class OperationSub extends Operation&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double GetResult() &#123;</span><br><span class="line"></span><br><span class="line">        double result = 0.0;</span><br><span class="line">        result = getNumberA() - getNumberB();</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.SimpleFactoryPattern.OperationDemo;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line"></span><br><span class="line">        Operation operation;</span><br><span class="line">        operation = OperationFactory.createOperate(&quot;/&quot;);</span><br><span class="line">        operation.setNumberA(23.3);</span><br><span class="line">        operation.setNumberB(22.3);</span><br><span class="line">        System.out.println(operation.GetResult());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>- 创建型模式对类的实例化过程进行了抽象，能够将对象的创建和对象的使用过程分离</p>
<p>- 简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的示例。简单工厂模式专门定义一个类来负责创建其他类的示例，被创建的示例通常都有共同的父类。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p>
<p>策略模式是一种对象行为型模式</p>
<h3 id="模式结构-1"><a href="#模式结构-1" class="headerlink" title="模式结构"></a>模式结构</h3><p>策略模式包含如下角色：</p>
<p>Context：环境类</p>
<p>Strategy：抽象策略类</p>
<p>ConcreteStrategy：具体策略类</p>
<p><img src="/2018/05/27/desgin-pattern/images/策略模式_rJ4cAcDym.png" alt="策略模式_rJ4cAcDym"></p>
<p><strong>示例代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.StrategyPattern;</span><br><span class="line"></span><br><span class="line">public abstract class Strategy &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 抽象算法方法</span><br><span class="line">     */</span><br><span class="line">    public abstract void algorithmInterface();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.StrategyPattern;</span><br><span class="line"></span><br><span class="line">public class ConcreateStrategyA extends Strategy&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void algorithmInterface() &#123;</span><br><span class="line">        System.out.println(&quot;algorithm A implements !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.StrategyPattern;</span><br><span class="line"></span><br><span class="line">public class ConcreateStrategyB extends Strategy&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void algorithmInterface() &#123;</span><br><span class="line">        System.out.println(&quot;algorithm B implements !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.StrategyPattern;</span><br><span class="line"></span><br><span class="line">public class ConcreateStrategyC extends Strategy&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void algorithmInterface() &#123;</span><br><span class="line">        System.out.println(&quot;algorithm C implements !&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.StrategyPattern;</span><br><span class="line"></span><br><span class="line">public class Context &#123;</span><br><span class="line"></span><br><span class="line">    Strategy mStrategy;</span><br><span class="line"></span><br><span class="line">    public Context(Strategy strategy)&#123;</span><br><span class="line">        this.mStrategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ContextInterface()&#123;</span><br><span class="line">        mStrategy.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.StrategyPattern;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        Context context;</span><br><span class="line">        context = new Context(new ConcreateStrategyA());</span><br><span class="line">        context.ContextInterface();</span><br><span class="line"></span><br><span class="line">        context = new Context(new ConcreateStrategyB());</span><br><span class="line">        context.ContextInterface();</span><br><span class="line"></span><br><span class="line">        context = new Context(new ConcreateStrategyC());</span><br><span class="line">        context.ContextInterface();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h3><p>- 策略模式是一个比较容易理解和使用的设计模式，策略模式是算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句简单的话来理解，就是”准备一组算法，并将每一个算法封装起来，使得它们可以互换”</p>
<p>- 在策略模式中，应当由客户端自己决定什么情况下使用什么具体的策略角色。</p>
<p>- 策略模式仅仅封装算法，提供新算法插入到已有的系统中，以及老算法从系统中“退休”方便，策略模式并不决定在何时使用何种算法，算法的选择有客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所具有策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</p>
<h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>- 如果一个系统里面有许多类，它们时间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</p>
<p>- 一个系统需要动态的在集中算法中选择一种</p>
<p>- 如果一个对象有很多种行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
<p>- 不希望客户端知道复杂的、与算法相关的数据结构，在具体的策略类中封装算法和相关数据结构，提高算法的保密性和安全性。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>- 在策略模式中定义了一系列的算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是对象行为模式的一种。</p>
<p>- 策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有抽象类的父类；具体策略类实现了在抽象策略类中定义的算法。</p>
<p>- 策略模式是对算法的封装，它把算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</p>
<p>- 策略模式主要优点在于对”开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加算法，它很好的管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数没可能会存在很多策略类。</p>
<p>-策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，适用策略模式可以动态的让一个对象在许多行为中选择一种行为；避险适用难以维护的多重条件选择语句；希望在具体策略类中封装算法和相关数据结构。</p>
<h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>SRP，就一个类而言，应该仅有一个引起它变化的原因。</p>
<h3 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h3><p>软件实体(类、模块、函数等等应该可以扩展，但是不可以修改。[ASD]</p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>A:高层模块不应该依赖低层模块。两个都应该依赖于抽象</p>
<p>B:抽象不应该依赖细节。细节应该依赖抽象。[ASD]</p>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>子类型必须能够替换掉它们的父类型。[ASD]</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><h3 id="模式定义-1"><a href="#模式定义-1" class="headerlink" title="模式定义"></a>模式定义</h3><p>装饰模式(Decorator Pattern)：动态地给一个对象添加额外的职责，就增加对象的功能来说，装饰模式比生成子类更为灵活。其别名也可以称为包装器，与适配器模式别名相同，但它们适用于不同的场合。</p>
<h3 id="模式结构-2"><a href="#模式结构-2" class="headerlink" title="模式结构"></a>模式结构</h3><p>Component：抽象构件</p>
<p>ConcreteComponent：具体构件</p>
<p>Decorator：抽象装饰类</p>
<p>ConcreteDecorator：具体装饰类</p>
<p><img src="/2018/05/27/desgin-pattern/images/装饰器模式.png" alt="装饰器模式"></p>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.DecoratorPattern.demo;</span><br><span class="line"></span><br><span class="line">public abstract class Component &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void Operation();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.DecoratorPattern.demo;</span><br><span class="line"></span><br><span class="line">public class ConcreateComponent extends Component &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void Operation() &#123;</span><br><span class="line">        System.out.println(&quot;具体对象操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.DecoratorPattern.demo;</span><br><span class="line"></span><br><span class="line">public class ConcreateComponentA extends Decorator&#123;</span><br><span class="line"></span><br><span class="line">    private String addedState;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void Operation() &#123;</span><br><span class="line">        super.Operation();</span><br><span class="line">        addedState = &quot; New State&quot;;</span><br><span class="line">        System.out.println(&quot;具体对对象A的操作&quot;+ addedState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.DecoratorPattern.demo;</span><br><span class="line"></span><br><span class="line">public class ConcreateComponentB extends Decorator&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void Operation() &#123;</span><br><span class="line">        super.Operation();</span><br><span class="line">        addedBehaivor();</span><br><span class="line">        System.out.println(&quot;具体装饰对象B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addedBehaivor()&#123;</span><br><span class="line">        //用来区别A</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.DecoratorPattern.demo;</span><br><span class="line"></span><br><span class="line">public abstract class Decorator extends Component&#123;</span><br><span class="line"></span><br><span class="line">    protected Component mComponent;</span><br><span class="line"></span><br><span class="line">    public void setmComponent(Component mComponent) &#123;</span><br><span class="line">        this.mComponent = mComponent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void Operation() &#123;</span><br><span class="line">        if (mComponent != null)&#123;</span><br><span class="line">            mComponent.Operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.DecoratorPattern.demo;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        ConcreateComponent component = new ConcreateComponent();</span><br><span class="line">        ConcreateComponentA decoratorA = new ConcreateComponentA();</span><br><span class="line">        ConcreateComponentB decoratorB = new ConcreateComponentB();</span><br><span class="line"></span><br><span class="line">        decoratorB.setmComponent(component);</span><br><span class="line">        decoratorB.Operation();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        decoratorA.setmComponent(component);</span><br><span class="line">        decoratorA.Operation();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">具体对象操作</span><br><span class="line">具体装饰对象B</span><br><span class="line">具体对象操作</span><br><span class="line">具体对对象A的操作 New State</span><br></pre></td></tr></table></figure>
<h3 id="模式分析-1"><a href="#模式分析-1" class="headerlink" title="模式分析"></a>模式分析</h3><ul>
<li>与继承关系相比，关联关系主要优势在于不会破话类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象。</li>
<li>使用装饰器模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象功能加以扩展。</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h3><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户端需要的额外服务。</p>
<p>通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</p>
<h3 id="模式定义-2"><a href="#模式定义-2" class="headerlink" title="模式定义"></a>模式定义</h3><p>代理模式(Proxy Pattern)：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p>
<h3 id="模式结构-3"><a href="#模式结构-3" class="headerlink" title="模式结构"></a>模式结构</h3><p>代理模式包含如下角色：</p>
<p>Subject：抽象主题角色</p>
<p>Proxy：代理主题角色</p>
<p>RealSubject：真实主题角色</p>
<p><img src="/2018/05/27/desgin-pattern/images/代理模式.png" alt="代理模式"></p>
<p>示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.ProxyPattern;</span><br><span class="line"></span><br><span class="line">public abstract class Subject &#123;</span><br><span class="line">    public abstract void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.ProxyPattern;</span><br><span class="line"></span><br><span class="line">public class RealSubject extends Subject &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        System.out.println(&quot;真实请求&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.ProxyPattern;</span><br><span class="line"></span><br><span class="line">public class Proxy extends Subject&#123;</span><br><span class="line"></span><br><span class="line">    private RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line"></span><br><span class="line">        if (realSubject == null)&#123;</span><br><span class="line">            realSubject = new RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;代理请求前修饰&quot;);</span><br><span class="line"></span><br><span class="line">        realSubject.request();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;代理请求后修饰&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.ProxyPattern;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Proxy proxy = new Proxy();</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</li>
<li>远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li>
<li>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li>
<li>保护代理可以控制对真实对象的使用权限。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求处理速度变慢。</li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li>
</ul>
<h3 id="适用的环境"><a href="#适用的环境" class="headerlink" title="适用的环境"></a>适用的环境</h3><ul>
<li>远程代理(Remote)代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可以是在另一台主机中。</li>
<li>虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个资源消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li>
<li>Copy-on-Write代理：它是虚拟代理的一种，把复制操作延迟到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>
<li>保护代理：控制一个对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li>缓冲代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙代理：保护目标不让恶意用户接近。</li>
<li>同步化代理：使几个用户能够同时使用一个对象而没有冲突。</li>
<li>智能引用代理：当一个对象被引用时，提供一些额外操作，如将此对象被调用的次数记录下来。</li>
</ul>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul>
<li>动态代理是一种较为高级的代理模式，它典型应用就是Spring AOP。</li>
<li>在传统的代理模式中，客户端通过Proxy调用RealSubject类的request()方法，同时还在代理类中封装了其他方法（preRequest(), afterRequest()），可以处理一些其他问题。</li>
<li>如果按照这种方法使用代理模式，那么真实主题角色必须对应一个代理主题角色，这将导致系统中类个数急剧增加，因此需要想办法减少系统中类的个数，此外，如何在事先不知道真实主题角色的情况下使用代理主题角色，这些都是动态代理需要解决的问题。</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</p>
<p>代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接的调用真实主题角色中定义的方法。代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式实现的非常复杂。远程代理一个位于不同地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速的响应客户端的处理请求。如果需要创建一个资源消耗较大的对象，先创建一消耗相对较小的对象来表示，真实对象只在需要时才会被创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源消耗，对戏㷣痛进行优化并提高运行速度。保护模式可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</p>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="模式定义-3"><a href="#模式定义-3" class="headerlink" title="模式定义"></a>模式定义</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 </p>
<h3 id="模式结构-4"><a href="#模式结构-4" class="headerlink" title="模式结构"></a>模式结构</h3><ul>
<li>Product：抽象产品</li>
<li>ConcreteProduct：具体产品</li>
<li>Factory：抽象工厂</li>
<li>ConcreteFactory：具体的工厂</li>
</ul>
<p><img src="/2018/05/27/desgin-pattern/images/工厂方法模式.png" alt="工厂方法模式"></p>
<h3 id="模式分析-2"><a href="#模式分析-2" class="headerlink" title="模式分析"></a>模式分析</h3><p>工厂方法模式是简单工厂模式的进一步的抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体的工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况加引进新产品。</p>
<h3 id="示例代码（简单工厂模式修改版）"><a href="#示例代码（简单工厂模式修改版）" class="headerlink" title="示例代码（简单工厂模式修改版）"></a>示例代码（简单工厂模式修改版）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public abstract class Operation &#123;</span><br><span class="line"></span><br><span class="line">    private Double numberA;</span><br><span class="line"></span><br><span class="line">    private Double numberB;</span><br><span class="line"></span><br><span class="line">    public Double getNumberA() &#123;</span><br><span class="line">        return numberA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNumberA(Double numberA) &#123;</span><br><span class="line">        this.numberA = numberA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getNumberB() &#123;</span><br><span class="line">        return numberB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNumberB(Double numberB) &#123;</span><br><span class="line">        this.numberB = numberB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getResult()&#123;</span><br><span class="line">        double result = 0;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public class OperationAdd extends Operation &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double getResult() &#123;</span><br><span class="line">        return getNumberA() + getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public class OperationDiv extends Operation&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double getResult() &#123;</span><br><span class="line">        return getNumberA() / getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public class OperationMul extends Operation &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double getResult() &#123;</span><br><span class="line">        return getNumberA() * getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public class OperationSub extends Operation &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double getResult() &#123;</span><br><span class="line">        return getNumberA() - getNumberB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public interface IFactory &#123;</span><br><span class="line"></span><br><span class="line">    public Operation createOperation();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public class AddFactory implements IFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Operation createOperation() &#123;</span><br><span class="line">        return new OperationAdd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public class SubFactory implements IFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Operation createOperation() &#123;</span><br><span class="line">        return new OperationSub();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public class MulFactory implements IFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Operation createOperation() &#123;</span><br><span class="line">        return new OperationMul();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public class DivFactory implements IFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Operation createOperation() &#123;</span><br><span class="line">        return new OperationDiv();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FactoryPattern;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        IFactory operFactory = new AddFactory();</span><br><span class="line">        Operation addOperation = operFactory.createOperation();</span><br><span class="line">        addOperation.setNumberA(12.4);</span><br><span class="line">        addOperation.setNumberB(22.4);</span><br><span class="line">        double result = addOperation.getResult();</span><br><span class="line">        System.out.println(&quot;add result: &quot; + result);</span><br><span class="line"></span><br><span class="line">        operFactory = new SubFactory();</span><br><span class="line">        Operation subOperation = operFactory.createOperation();</span><br><span class="line">        subOperation.setNumberA(22.5);</span><br><span class="line">        subOperation.setNumberB(12.8);</span><br><span class="line">        result = subOperation.getResult();</span><br><span class="line">        System.out.println(&quot;sub result: &quot; + result);</span><br><span class="line"></span><br><span class="line">        operFactory = new MulFactory();</span><br><span class="line">        Operation mulOperation = operFactory.createOperation();</span><br><span class="line">        mulOperation.setNumberA(12.0);</span><br><span class="line">        mulOperation.setNumberB(2.0);</span><br><span class="line">        result = mulOperation.getResult();</span><br><span class="line">        System.out.println(&quot;mul result：&quot; + result);</span><br><span class="line"></span><br><span class="line">        operFactory = new DivFactory();</span><br><span class="line">        Operation divOperation = operFactory.createOperation();</span><br><span class="line">        divOperation.setNumberA(23.4);</span><br><span class="line">        divOperation.setNumberB(2.0);</span><br><span class="line">        result = divOperation.getResult();</span><br><span class="line">        System.out.println(&quot;div result：&quot; + result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工厂方法模式的优点"><a href="#工厂方法模式的优点" class="headerlink" title="工厂方法模式的优点"></a>工厂方法模式的优点</h3><ul>
<li>在工厂方法模式中，工厂方法用来创建客户需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需要产品对应的工厂，无需关系创建细节，甚至无须知道具体产品类的类名。</li>
<li>基于工厂角色和产品角色多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li>
<li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品所提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产皮就可以了。这样，系统的可扩展性会非常好，符合“开闭原则”</li>
</ul>
<h3 id="工厂方法模式的缺点"><a href="#工厂方法模式的缺点" class="headerlink" title="工厂方法模式的缺点"></a>工厂方法模式的缺点</h3><ul>
<li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li>
<li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li>
</ul>
<h3 id="适用的环境-1"><a href="#适用的环境-1" class="headerlink" title="适用的环境"></a>适用的环境</h3><ul>
<li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
<li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li>
<li>工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li>
<li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li>
<li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li>
<li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li>
</ul>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库的调用。</p>
<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>用原型示例制定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><p>1、当一个系统应该独立于它的产品创建，构成和表示时。</p>
<p>2、到要实例化的类是在运行时刻指定时，例如，通过动装载。</p>
<p>3、为了避免创建一个与产品类层次平行的工厂类层次时。</p>
<p>4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化类更方便一些。</p>
<h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><ul>
<li>实现克隆操作，在Java类中继承Cloneable，重写clone()</li>
<li>原型模式同样用于隔离类对象的使用者和具体类型之间的耦合关系，它同样要求这些“易变类”拥有稳定的接口。</li>
</ul>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>性能提高</li>
<li>逃避构造函数约束</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于一个已有的类不一定很容易</li>
<li>必须实现Cloneable接口</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>资源优化场景</li>
<li>类初始化需要消耗非常多的资源，这个资源包括数据、硬件资源等</li>
<li>性能和安全要求的场景</li>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>一个对象多个修改者的场景</li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用</li>
<li>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.PrototypePattern;</span><br><span class="line"></span><br><span class="line">public abstract class Shape implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    private String id;</span><br><span class="line">    protected String type;</span><br><span class="line"></span><br><span class="line">    abstract void draw();</span><br><span class="line"></span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone()&#123;</span><br><span class="line"></span><br><span class="line">        Object clone = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            clone = super.clone();</span><br><span class="line">        &#125;catch (CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return clone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.cx.PrototypePattern;</span><br><span class="line"></span><br><span class="line">public class Circle extends Shape &#123;</span><br><span class="line"></span><br><span class="line">    public Circle()&#123;</span><br><span class="line">        type = &quot;Circle&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Inside Circle::draw() method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.cx.PrototypePattern;</span><br><span class="line"></span><br><span class="line">public class Rectangle extends Shape &#123;</span><br><span class="line"></span><br><span class="line">    public Rectangle()&#123;</span><br><span class="line">        type = &quot;Rectangle&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Inside Rectangle::draw() method.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.PrototypePattern;</span><br><span class="line"></span><br><span class="line">public class Square extends Shape&#123;</span><br><span class="line"></span><br><span class="line">    public Square()&#123;</span><br><span class="line">        type = &quot;Square&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Inside Square::draw() method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.cx.PrototypePattern;</span><br><span class="line"></span><br><span class="line">import java.util.Hashtable;</span><br><span class="line"></span><br><span class="line">public class ShapeCache &#123;</span><br><span class="line"></span><br><span class="line">    private static Hashtable&lt;String, Shape&gt; shapeMap</span><br><span class="line">            = new Hashtable&lt;String, Shape&gt;();</span><br><span class="line"></span><br><span class="line">    public static Shape getShape(String shapeId)&#123;</span><br><span class="line">        Shape cacheShape = shapeMap.get(shapeId);</span><br><span class="line">        return (Shape)cacheShape.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void loadCache()&#123;</span><br><span class="line"></span><br><span class="line">        Circle circle = new Circle();</span><br><span class="line">        circle.setId(&quot;1&quot;);</span><br><span class="line">        shapeMap.put(circle.getId(), circle);</span><br><span class="line"></span><br><span class="line">        Square square = new Square();</span><br><span class="line">        square.setId(&quot;2&quot;);</span><br><span class="line">        shapeMap.put(square.getId(), square);</span><br><span class="line"></span><br><span class="line">        Rectangle rectangle = new Rectangle();</span><br><span class="line">        rectangle.setId(&quot;3&quot;);</span><br><span class="line">        shapeMap.put(rectangle.getId(), rectangle);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.cx.PrototypePattern;</span><br><span class="line"></span><br><span class="line">public class PrototypePatternDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        ShapeCache.loadCache();</span><br><span class="line"></span><br><span class="line">        Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;);</span><br><span class="line">        System.out.println(&quot;Shape : &quot; + clonedShape.getType());</span><br><span class="line"></span><br><span class="line">        Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;);</span><br><span class="line">        System.out.println(&quot;Shqpe : &quot; + clonedShape2.getType());</span><br><span class="line"></span><br><span class="line">        Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;);</span><br><span class="line">        System.out.println(&quot;Shape : &quot; + clonedShape3.getType());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape : Circle</span><br><span class="line">Shqpe : Square</span><br><span class="line">Shape : Rectangle</span><br></pre></td></tr></table></figure>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在模版方法模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用者将以抽象类中定义的方式进行。这种设计模式属于行为型模式。</p>
<h3 id="模式意图"><a href="#模式意图" class="headerlink" title="模式意图"></a>模式意图</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<h3 id="主要解决的问题"><a href="#主要解决的问题" class="headerlink" title="主要解决的问题"></a>主要解决的问题</h3><p>一些方法通用，却在每一个子类都重新写了这一方法。</p>
<h3 id="何时使用-1"><a href="#何时使用-1" class="headerlink" title="何时使用"></a>何时使用</h3><p>有一些通用的方法</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>将这些通用的算法抽象出来</p>
<h3 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h3><p>在抽象类中定义骨架，具体在子类中实现</p>
<h3 id="应用的实例"><a href="#应用的实例" class="headerlink" title="应用的实例"></a>应用的实例</h3><ul>
<li>在造房子的时候，地基、走线、水管都一样，周游在建筑后期才有加壁橱等差异。</li>
<li>spring中对Hibernate的支持，将一些已经定义好的方法封装起来，比如开启事务、获取session、关闭session等，程序员不重复写那些已经规范好的代码，直接给一个实体类就可以保存。</li>
</ul>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>封装不变部分，扩展可变部分。</li>
<li>提取公共代码，便于维护。</li>
<li>行为由父类控制，子类实现。</li>
</ul>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。</li>
</ul>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>有多个子类共有的方法，且逻辑相同。</li>
<li>重要的、复杂的方法，可以考虑模板方法。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>为防止恶意的操作，一般模板方法都加上final关键字。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p><img src="/2018/05/27/desgin-pattern/images/模版方法.png" alt="模版方法"></p>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.TemplatePattern;</span><br><span class="line"></span><br><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void primitiveOperation1();</span><br><span class="line"></span><br><span class="line">    public abstract void primitiveOperation2();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 模版方法，给出了逻辑股价，而逻辑的组成是一些相应的抽象操作，将具体的操作推迟到了子类实现</span><br><span class="line">     */</span><br><span class="line">    public final void TemplateMethod()&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;共同操作&quot;);</span><br><span class="line"></span><br><span class="line">        primitiveOperation1();</span><br><span class="line">        primitiveOperation2();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.TemplatePattern;</span><br><span class="line"></span><br><span class="line">public class ConcrateClassA extends AbstractClass&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void primitiveOperation1() &#123;</span><br><span class="line">        System.out.println(&quot;具体类A的方法1实现&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void primitiveOperation2() &#123;</span><br><span class="line">        System.out.println(&quot;具体类A的方法2实现&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package com.cx.TemplatePattern;</span><br><span class="line"></span><br><span class="line">public class ConcrateClassB extends AbstractClass &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void primitiveOperation1() &#123;</span><br><span class="line">        System.out.println(&quot;具体类B的方法1实现&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void primitiveOperation2() &#123;</span><br><span class="line">        System.out.println(&quot;具体类B的方法2实现&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.TemplatePattern;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String []args)&#123;</span><br><span class="line"></span><br><span class="line">        AbstractClass abstractClass;</span><br><span class="line">        abstractClass = new ConcrateClassA();</span><br><span class="line">        abstractClass.TemplateMethod();</span><br><span class="line"></span><br><span class="line">        abstractClass = new ConcrateClassB();</span><br><span class="line">        abstractClass.TemplateMethod();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="模式定义-4"><a href="#模式定义-4" class="headerlink" title="模式定义"></a>模式定义</h3><p>外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，他是一种对象结构型模式。</p>
<h3 id="模式结构-5"><a href="#模式结构-5" class="headerlink" title="模式结构"></a>模式结构</h3><p>外观模式包含如下角色：</p>
<ul>
<li>Facade：外观角色</li>
<li>SubSystem：子系统角色</li>
</ul>
<p><img src="/2018/05/27/desgin-pattern/images/外观模式.png" alt="外观模式"></p>
<ul>
<li>示例代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package com.cx.FacadePattern;</span><br><span class="line"></span><br><span class="line">public class SubSystemOne &#123;</span><br><span class="line"></span><br><span class="line">    public void methodOne()&#123;</span><br><span class="line">        System.out.println(&quot;子系统方法一&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FacadePattern;</span><br><span class="line"></span><br><span class="line">public class SubSystemTwo &#123;</span><br><span class="line"></span><br><span class="line">    public void methodTwo()&#123;</span><br><span class="line">        System.out.println(&quot;子系统方法二&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FacadePattern;</span><br><span class="line"></span><br><span class="line">public class SubSystemThree &#123;</span><br><span class="line"></span><br><span class="line">    public void methodThree()&#123;</span><br><span class="line">        System.out.println(&quot;子系统方法三&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FacadePattern;</span><br><span class="line"></span><br><span class="line">public class SubSystemFour &#123;</span><br><span class="line"></span><br><span class="line">    public void methodFour()&#123;</span><br><span class="line">        System.out.println(&quot;子系统方法四&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FacadePattern;</span><br><span class="line"></span><br><span class="line">public class Facade &#123;</span><br><span class="line"></span><br><span class="line">    private SubSystemOne one;</span><br><span class="line">    private SubSystemTwo two;</span><br><span class="line">    private SubSystemThree three;</span><br><span class="line">    private SubSystemFour four;</span><br><span class="line"></span><br><span class="line">    public Facade()&#123;</span><br><span class="line">        one = new SubSystemOne();</span><br><span class="line">        two = new SubSystemTwo();</span><br><span class="line">        three = new SubSystemThree();</span><br><span class="line">        four = new SubSystemFour();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void methodA()&#123;</span><br><span class="line">        System.out.println(&quot;方法组A ---------&quot;);</span><br><span class="line">        one.methodOne();</span><br><span class="line">        two.methodTwo();</span><br><span class="line">        four.methodFour();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void methodB()&#123;</span><br><span class="line">        System.out.println(&quot;方法组B ---------&quot;);</span><br><span class="line">        two.methodTwo();</span><br><span class="line">        three.methodThree();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">package com.cx.FacadePattern;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Facade facade = new Facade();</span><br><span class="line"></span><br><span class="line">        facade.methodA();</span><br><span class="line">        facade.methodB();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------运行结果---------------------------------------</span><br><span class="line">方法组A ---------</span><br><span class="line">子系统方法一</span><br><span class="line">子系统方法二</span><br><span class="line">子系统方法四</span><br><span class="line">方法组B ---------</span><br><span class="line">子系统方法二</span><br><span class="line">子系统方法三</span><br><span class="line">---------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="模式分析-3"><a href="#模式分析-3" class="headerlink" title="模式分析"></a>模式分析</h3><p>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。外观模式也是”迪米特法则”的体现，通过引入一个外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。外观模式要求一个子系统外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。外观模式的目的在于降低系统的复杂程度。外观模式很大程度上提高了客户端使用的便捷性，使得客户端无需关系子系统的工作细节，通过外观角色即可调用相关功能。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>对客户端屏蔽子系统组件，减少了客户端处理对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</li>
<li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li>
<li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不要要编译所有其他子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li>
<li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li>
</ul>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不能很好的限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li>
<li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改类或客户端的源代码，违背了“开闭原则”。</li>
</ul>
<h3 id="适用环境-1"><a href="#适用环境-1" class="headerlink" title="适用环境"></a>适用环境</h3><ul>
<li>当要为一个复杂的子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以通过如果外观类直接访问子系统。</li>
<li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li>
<li>在层次化结构中，可以使用外观模式定义系统中的每一层入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li>
</ul>
<h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><h5 id="一个系统有多个外观类"><a href="#一个系统有多个外观类" class="headerlink" title="一个系统有多个外观类"></a>一个系统有多个外观类</h5><p>在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。在很多情况下为乐节约系统资源，一般将外观类设计为单例类。当然这并不意味着在整个系统里只能有一个外观类，在一个系统中可设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。</p>
<h4 id="不要试图通过外观类为子系统增加新行为"><a href="#不要试图通过外观类为子系统增加新行为" class="headerlink" title="不要试图通过外观类为子系统增加新行为"></a>不要试图通过外观类为子系统增加新行为</h4><p>不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统中加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。</p>
<h4 id="外观模式与迪米特法则"><a href="#外观模式与迪米特法则" class="headerlink" title="外观模式与迪米特法则"></a>外观模式与迪米特法则</h4><p>外观模式创造出一个外观对象，将客户端所涉及的术语一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。</p>
<h4 id="抽象外观类的引入"><a href="#抽象外观类的引入" class="headerlink" title="抽象外观类的引入"></a>抽象外观类的引入</h4><p>外观模式最大的缺点在于违背了“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。对于新的业务需求，不修改原有外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/简单工厂模式，策略模式/" rel="tag"># 简单工厂模式，策略模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/28/for-offer/" rel="prev" title="for_offer">
                for_offer <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jie Liu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的工厂模式"><span class="nav-number">1.</span> <span class="nav-text">简单的工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模式的定义"><span class="nav-number">1.1.</span> <span class="nav-text">模式的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式结构"><span class="nav-number">1.2.</span> <span class="nav-text">模式结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单工厂模式的优点"><span class="nav-number">1.3.</span> <span class="nav-text">简单工厂模式的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单工厂模式的缺点"><span class="nav-number">1.4.</span> <span class="nav-text">简单工厂模式的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例代码"><span class="nav-number">1.5.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#策略模式"><span class="nav-number">2.</span> <span class="nav-text">策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模式定义"><span class="nav-number">2.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式结构-1"><span class="nav-number">2.2.</span> <span class="nav-text">模式结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式分析"><span class="nav-number">2.3.</span> <span class="nav-text">模式分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适用环境"><span class="nav-number">2.4.</span> <span class="nav-text">适用环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">2.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计模式原则"><span class="nav-number">3.</span> <span class="nav-text">设计模式原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一职责原则"><span class="nav-number">3.1.</span> <span class="nav-text">单一职责原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开放-封闭原则"><span class="nav-number">3.2.</span> <span class="nav-text">开放-封闭原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖倒转原则"><span class="nav-number">3.3.</span> <span class="nav-text">依赖倒转原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#里氏代换原则"><span class="nav-number">3.4.</span> <span class="nav-text">里氏代换原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迪米特法则"><span class="nav-number">3.5.</span> <span class="nav-text">迪米特法则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰模式"><span class="nav-number">4.</span> <span class="nav-text">装饰模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模式定义-1"><span class="nav-number">4.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式结构-2"><span class="nav-number">4.2.</span> <span class="nav-text">模式结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例代码-1"><span class="nav-number">4.3.</span> <span class="nav-text">示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式分析-1"><span class="nav-number">4.4.</span> <span class="nav-text">模式分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理模式"><span class="nav-number">5.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模式动机"><span class="nav-number">5.1.</span> <span class="nav-text">模式动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式定义-2"><span class="nav-number">5.2.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式结构-3"><span class="nav-number">5.3.</span> <span class="nav-text">模式结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点"><span class="nav-number">5.4.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点"><span class="nav-number">5.5.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适用的环境"><span class="nav-number">5.6.</span> <span class="nav-text">适用的环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态代理"><span class="nav-number">5.7.</span> <span class="nav-text">动态代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">5.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#工厂方法模式"><span class="nav-number">6.</span> <span class="nav-text">工厂方法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模式定义-3"><span class="nav-number">6.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式结构-4"><span class="nav-number">6.2.</span> <span class="nav-text">模式结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式分析-2"><span class="nav-number">6.3.</span> <span class="nav-text">模式分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例代码（简单工厂模式修改版）"><span class="nav-number">6.4.</span> <span class="nav-text">示例代码（简单工厂模式修改版）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂方法模式的优点"><span class="nav-number">6.5.</span> <span class="nav-text">工厂方法模式的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂方法模式的缺点"><span class="nav-number">6.6.</span> <span class="nav-text">工厂方法模式的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适用的环境-1"><span class="nav-number">6.7.</span> <span class="nav-text">适用的环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-3"><span class="nav-number">6.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型模式"><span class="nav-number">7.</span> <span class="nav-text">原型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#意图"><span class="nav-number">7.1.</span> <span class="nav-text">意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何时使用"><span class="nav-number">7.2.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键代码"><span class="nav-number">7.3.</span> <span class="nav-text">关键代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-1"><span class="nav-number">7.4.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-1"><span class="nav-number">7.5.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">7.6.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">7.7.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模版方法模式"><span class="nav-number">8.</span> <span class="nav-text">模版方法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">8.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式意图"><span class="nav-number">8.2.</span> <span class="nav-text">模式意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主要解决的问题"><span class="nav-number">8.3.</span> <span class="nav-text">主要解决的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何时使用-1"><span class="nav-number">8.4.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用"><span class="nav-number">8.5.</span> <span class="nav-text">如何使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键代码-1"><span class="nav-number">8.6.</span> <span class="nav-text">关键代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用的实例"><span class="nav-number">8.7.</span> <span class="nav-text">应用的实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-2"><span class="nav-number">8.8.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-2"><span class="nav-number">8.9.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景-1"><span class="nav-number">8.10.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">8.11.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具体实现"><span class="nav-number">8.12.</span> <span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外观模式"><span class="nav-number">9.</span> <span class="nav-text">外观模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模式定义-4"><span class="nav-number">9.1.</span> <span class="nav-text">模式定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式结构-5"><span class="nav-number">9.2.</span> <span class="nav-text">模式结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式分析-3"><span class="nav-number">9.3.</span> <span class="nav-text">模式分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优点-3"><span class="nav-number">9.4.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-3"><span class="nav-number">9.5.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适用环境-1"><span class="nav-number">9.6.</span> <span class="nav-text">适用环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式扩展"><span class="nav-number">9.7.</span> <span class="nav-text">模式扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一个系统有多个外观类"><span class="nav-number">9.7.0.1.</span> <span class="nav-text">一个系统有多个外观类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不要试图通过外观类为子系统增加新行为"><span class="nav-number">9.7.1.</span> <span class="nav-text">不要试图通过外观类为子系统增加新行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外观模式与迪米特法则"><span class="nav-number">9.7.2.</span> <span class="nav-text">外观模式与迪米特法则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象外观类的引入"><span class="nav-number">9.7.3.</span> <span class="nav-text">抽象外观类的引入</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jie Liu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
